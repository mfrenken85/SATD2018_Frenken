UNKNOWN	// post a new callback	97132
UNKNOWN	// Sets the alarm to go off in a certain number of milliseconds. If the alarm is already set,	97128
UNKNOWN	// its overwritten and only the new alarm setting is used	97129
UNKNOWN	// this is called when our timer runs out	97130
UNKNOWN	// We still need to wait some time to trigger spring loaded mode--	97131
UNKNOWN	/**     * Returns the application title     *      * @return application title     */	97133
UNKNOWN	/**     * Updates the app widgets whose id has changed during the restore process.     */	97134
UNKNOWN	// The widget no long exists.	97135
UNKNOWN	// Unregister the widget IDs which are not present on the workspace. This could happen	97136
UNKNOWN	// when a widget place holder is removed from workspace, before this method is called.	97137
UNKNOWN	/**     * Add the supplied ApplicationInfo objects to the list, and enqueue it into the     * list to broadcast when notify() is called.     *     * If the app is already in the list, doesnt add it.     */	97138
UNKNOWN	// TODO: do we clear these too?	97139
UNKNOWN	/**     * Add the icons for the supplied apk called packageName.     */	97140
UNKNOWN	/**     * Remove the apps for the given apk identified by packageName.     */	97141
UNKNOWN	/**     * Add and remove icons for this package which has been updated.     */	97142
UNKNOWN	// Find disabled/removed activities and remove them from data and add them	97143
UNKNOWN	// to the removed list.	97144
UNKNOWN	// Find enabled activities and add them to the adapter	97145
UNKNOWN	// Also updates existing activities with new labels/icons	97146
UNKNOWN	// Remove all data for this package.	97147
UNKNOWN	/**     * Returns whether <em>apps</em> contains <em>component</em>.     */	97148
UNKNOWN	/**     * Query the launcher apps service for whether the supplied package has     * MAIN/LAUNCHER activities in the supplied package.     */	97149
UNKNOWN	/**     * Returns whether <em>apps</em> contains <em>component</em>.     */	97150
UNKNOWN	/**     * Find an ApplicationInfo object for the given packageName and className.     */	97151
UNKNOWN	/**     * Clears all the key listeners for the individual icons.     */	97152
UNKNOWN	// TODO: revisit this	97168
UNKNOWN	/**     * Convenience methods to select specific tabs.  We want to set the content type immediately     * in these cases, but we note that we still call setCurrentTabByTag() so that the tab view     * reflects the new content (but doesnt do the animation and logic associated with changing     * tabs manually).     */	97153
UNKNOWN	/**     * Setup the tab host and create all necessary tabs.     */	97154
UNKNOWN	/**     * Returns the content type for the specified tab tag.     */	97155
UNKNOWN	/**     * Returns the tab tag for a given content type.     */	97156
UNKNOWN	/**     * Disable focus on anything under this view in the hierarchy if we are not visible.     */	97157
UNKNOWN	// Reset immediately	97158
UNKNOWN	// We unload the widget previews when the UI is hidden, so need to reload pages	97159
UNKNOWN	// Load the current page synchronously, and the neighboring pages asynchronously	97160
UNKNOWN	// Clear the widget pages of all their subviews - this will trigger the widget previews	97161
UNKNOWN	// to delete their bitmaps	97162
UNKNOWN	/* LauncherTransitionable overrides */	97163
UNKNOWN	// Going from All Apps -> Workspace	97164
UNKNOWN	// Going from Workspace -> All Apps	97165
UNKNOWN	// Make sure the current page is loaded (we start loading the side pages after the	97166
UNKNOWN	// transition to prevent slowing down the animation)	97167
UNKNOWN	// Make sure adjacent pages are loaded (we wait until after the transition to	97169
UNKNOWN	// prevent slowing down the animation)	97170
UNKNOWN	// Opening apps, need to announce what page we are on.	97171
UNKNOWN	// Notify the user when the page changes	97172
UNKNOWN	// Going from Workspace -> All Apps	97173
UNKNOWN	// NOTE: We should do this at the end since we check visibility state in some of the	97174
UNKNOWN	// cling initialization/dismiss code above.	97175
UNKNOWN	/**     *  Here we bound the deltas such that the frame cannot be stretched beyond the extents     *  of the CellLayout, and such that the frames borders cant cross.     */	97176
UNKNOWN	/**     *  Based on the deltas, we resize the frame, and, if needed, we resize the widget.     */	97177
UNKNOWN	/**     *  Based on the current deltas, we determine if and how to resize the widget.     */	97178
UNKNOWN	// For each border, we bound the resizing based on the minimum width, and the maximum	97179
UNKNOWN	// expandability.	97180
UNKNOWN	// Update the widgets dimensions and position according to the deltas computed above	97181
UNKNOWN	// We always want the final commit to match the feedback, so we make sure to use the	97182
UNKNOWN	// last used direction vector when committing the resize / reorder.	97183
UNKNOWN	// Compute landscape size	97184
UNKNOWN	// Compute portrait size	97185
UNKNOWN	/**     * This is the final step of the resize. Here we save the new widget size and position     * to LauncherModel and animate the resize frame.     */	97186
UNKNOWN	// We need to make sure the frames touchable regions lie fully within the bounds of the 	97187
UNKNOWN	// DragLayer. We allow the actual handles to be clipped, but we shift the touch regions	97188
UNKNOWN	// down accordingly to provide a proper touch target.	97189
UNKNOWN	// In this case we shift the touch region down to start at the top of the DragLayer	97190
UNKNOWN	// In this case we shift the touch region up to end at the bottom of the DragLayer	97191
UNKNOWN	// Do nothing	97192
UNKNOWN	// Do nothing	97193
UNKNOWN	// Do nothing	97194
UNKNOWN	// Do nothing	97195
UNKNOWN	// Find the rect to animate to (the view is center aligned)	97196
UNKNOWN	// Center the destination rect about the trash icon	97197
UNKNOWN	// Ensure we are using the right text size	97198
UNKNOWN	// Call the superclass onTouchEvent first, because sometimes it changes the state to	97199
UNKNOWN	// isPressed() on an ACTION_UP	97200
UNKNOWN	// So that the pressed outline is visible immediately on setStayPressed(),	97201
UNKNOWN	// we pre-create it on ACTION_DOWN (it takes a small but perceptible amount of time	97202
UNKNOWN	// to create it)	97203
UNKNOWN	// If weve touched down and up on an item, and its still not pressed, then	97204
UNKNOWN	// destroy the pressed outline	97205
UNKNOWN	// Only show the shadow effect when persistent pressed state is set.	97206
UNKNOWN	// Pre-create shadow so show immediately on click.	97207
UNKNOWN	// Unlike touch events, keypress event propagate pressed state change immediately,	97208
UNKNOWN	// without waiting for onClickHandler to execute. Disable pressed state changes here	97209
UNKNOWN	// to avoid flickering.	97210
UNKNOWN	// If text is transparent, dont draw any shadow	97211
UNKNOWN	// We enhance the shadow by drawing the shadow twice	97212
UNKNOWN	// Keep track of the set of screens which need to be added to the db.	97213
UNKNOWN	// Read the extras	97214
UNKNOWN	// Send a broadcast to configure the widget	97215
UNKNOWN	// We can only have folders with >= 2 items, so we need to remove the	97216
UNKNOWN	// folder and clean up if less than 2 items were included, or some	97217
UNKNOWN	// failed to add, and less than 2 were actually added	97218
UNKNOWN	// Delete the folder	97219
UNKNOWN	// If we have a single item, promote it to where the folder	97220
UNKNOWN	// would have been.	97221
UNKNOWN	//noinspection StatementWithEmptyBody	97222
UNKNOWN	/**     * Return attribute value, attempting launcher-specific namespace first     * before falling back to anonymous attribute.     */	97223
UNKNOWN	/**     * Return attribute resource value, attempting launcher-specific namespace     * first before falling back to anonymous attribute.     */	97224
UNKNOWN	// Read the extras	97225
UNKNOWN	// Send a broadcast to configure the widget	97226
UNKNOWN	// We can only have folders with >= 2 items, so we need to remove the	97227
UNKNOWN	// folder and clean up if less than 2 items were included, or some	97228
UNKNOWN	// failed to add, and less than 2 were actually added	97229
UNKNOWN	// Delete the folder	97230
UNKNOWN	// If we have a single item, promote it to where the folder	97231
UNKNOWN	// would have been.	97232
UNKNOWN	/** Schedule runnable to run after everything thats on the queue right now. */	97233
UNKNOWN	/** Schedule runnable to run when the queue goes idle. */	97234
UNKNOWN	//noinspection StatementWithEmptyBody	97235
UNKNOWN	/** Runs all queued Runnables from the calling thread. */	97236
UNKNOWN	// Get the drawable	97237
UNKNOWN	// Get the hover color	97238
UNKNOWN	// The current drawable is set to either the remove drawable or the uninstall drawable	97239
UNKNOWN	// and is initially set to the remove drawable, as set in the layout xml.	97240
UNKNOWN	// Remove the text in the Phone UI in landscape	97241
UNKNOWN	// If we are dragging an application from AppsCustomize, only show the control if we can	97242
UNKNOWN	// delete the app (it was downloaded), and rename the string to uninstall in such a case.	97243
UNKNOWN	// Hide the delete target if it is a widget from AppsCustomize.	97244
UNKNOWN	// Restore the hover color if we are deleting	97245
UNKNOWN	// Only allow manifest shortcuts to initiate an un-install.	97246
UNKNOWN	// Uninstall the application if it is being dragged from AppsCustomize	97247
UNKNOWN	// Remove the folder from the workspace and delete the contents from launcher model	97248
UNKNOWN	// Remove the widget from the workspace	97249
UNKNOWN	// Deleting an app widget ID is a void call but writes to disk before returning	97250
UNKNOWN	// to the caller...	97251
UNKNOWN	/**     * Creates an animation from the current drag view to the delete trash icon.     */	97252
UNKNOWN	// Calculate how far along the velocity vector we should put the intermediate point on	97253
UNKNOWN	// the bezier curve	97254
UNKNOWN	// intermediate t/l	97255
UNKNOWN	// drag view t/l	97256
UNKNOWN	// delete target t/l	97257
UNKNOWN	// Dont highlight the icon as its animating	97258
UNKNOWN	// Dont highlight the target if we are flinging from AllApps	97259
UNKNOWN	// Defer animating out the drop target if we are animating to it	97260
UNKNOWN	// NOTE: Because it takes time for the first frame of animation to actually be	97261
UNKNOWN	// called and we expect the animation to be a continuation of the fling, we have	97262
UNKNOWN	// to account for the time that has elapsed since the fling finished.  And since	97263
UNKNOWN	// we dont have a startDelay, we will always get call to update when we call	97264
UNKNOWN	// start() (which we want to ignore).	97265
UNKNOWN	// If we are dragging from AllApps, then we allow AppsCustomizePagedView to clean up	97266
UNKNOWN	// itself, otherwise, complete the drop to initiate the deletion process	97267
UNKNOWN	// If we are dragging from AllApps, then we allow AppsCustomizePagedView to clean up	97268
UNKNOWN	// itself, otherwise, complete the drop to initiate the deletion process	97269
UNKNOWN	// Clean up any references to source/generated bitmaps	97270
UNKNOWN	// Load each of the widget previews in the background	97271
UNKNOWN	// All the widget previews are loaded, so we can just callback to inflate the page	97272
UNKNOWN	// Load the widget previews	97366
UNKNOWN	// Load the widget previews	97367
UNKNOWN	/*     * PagedViewWithDraggableItems implementation     */	97290
UNKNOWN	/** Returns the item index of the center item on this page so that we can restore to this     *  item index when we rotate. */	97273
UNKNOWN	/** Get the index of the item to restore to if we need to restore the current page. */	97274
UNKNOWN	/** Returns the page in the current orientation which is expected to contain the specified     *  item index. */	97275
UNKNOWN	/** Restores the page for an item at the specified index */	97276
UNKNOWN	// Now that the data is ready, we can calculate the content width, the number of cells to	97277
UNKNOWN	// use for each page	97278
UNKNOWN	// Force a measure to update recalculate the gaps	97279
UNKNOWN	// This code triggers requestLayout so must be posted outside of the	97280
UNKNOWN	// layout pass.	97281
UNKNOWN	// This code triggers requestLayout so must be posted outside of the	97282
UNKNOWN	// layout pass.	97283
UNKNOWN	// Get the list of widgets and shortcuts	97284
UNKNOWN	// Ensure that all widgets we show can be added on a workspace of this size	97285
UNKNOWN	// just add shortcuts	97286
UNKNOWN	// When we have exited all apps or are in transition, disregard clicks	97287
UNKNOWN	// Let the user know that they have to long press to add a widget	97288
UNKNOWN	// Create a little animation to show that the widget can move	97289
UNKNOWN	// Disable dragging by pulling an app down for now.	97291
UNKNOWN	// We want the first widget layout to be the correct size. This will be important	97292
UNKNOWN	// for width size reporting to the AppWidgetManager.	97293
UNKNOWN	// We want the first widget layout to be the correct size. This will be important	97294
UNKNOWN	// for width size reporting to the AppWidgetManager.	97295
UNKNOWN	// We are anticipating a long press, and we use this time to load bind and instantiate	97296
UNKNOWN	// the widget. This will need to be cleaned up if it turns out no long press occurs.	97297
UNKNOWN	// Just in case the cleanup process wasnt properly executed. This shouldnt happen.	97298
UNKNOWN	// If the widget was not added, we may need to do further cleanup.	97299
UNKNOWN	// We never did any preloading, so just remove pending callbacks to do so	97300
UNKNOWN	// Delete the widget id which was allocated	97301
UNKNOWN	// We never got around to inflating the widget, so remove the callback to do so.	97302
UNKNOWN	// Delete the widget id which was allocated	97303
UNKNOWN	// The widget was inflated and added to the DragLayer -- remove it.	97304
UNKNOWN	// Get the widget preview as the drag representation	97305
UNKNOWN	// If the ImageView doesnt have a drawable yet, the widget preview hasnt been loaded and	97306
UNKNOWN	// we abort the drag.	97307
UNKNOWN	// Compose the drag image	97308
UNKNOWN	// This can happen in some weird cases involving multi-touch. We cant start dragging	97309
UNKNOWN	// the widget if this is null, so we break out.	97310
UNKNOWN	// Compare the size of the drag preview to the preview in the AppsCustomize tray	97311
UNKNOWN	// The bitmap in the AppsCustomize tray is always the the same size, so there	97312
UNKNOWN	// might be extra pixels around the preview itself - this accounts for that	97313
UNKNOWN	// Dont clip alpha values for the drag outline if were using the default widget preview	97314
UNKNOWN	// Save the preview for the outline generation, then dim the preview	97315
UNKNOWN	// Start the drag	97316
UNKNOWN	// We delay entering spring-loaded mode slightly to make sure the UI	97317
UNKNOWN	// thready is free of any work.	97318
UNKNOWN	// We dont enter spring-loaded mode if the drag has been cancelled	97319
UNKNOWN	// Go into spring loaded mode (must happen before we startDrag())	97320
UNKNOWN	// We dont enter spring-loaded mode if the drag has been cancelled	97321
UNKNOWN	// Go into spring loaded mode (must happen before we startDrag())	97322
UNKNOWN	/**     * Clean up after dragging.     *     * @param target where the item was dragged to (can be null if the item was flung)     */	97323
UNKNOWN	// Exit spring loaded mode if we have not successfully dropped or have not handled the	97324
UNKNOWN	// drop in Workspace	97325
UNKNOWN	// Return early and wait for onFlingToDeleteCompleted if this was the result of a fling	97326
UNKNOWN	// Display an error message if the drag failed due to there not being enough space on the	97327
UNKNOWN	// target layout we were dropping on.	97328
UNKNOWN	// We just dismiss the drag when we fling, so cleanup here	97329
UNKNOWN	// Clean up all the async tasks	97330
UNKNOWN	// Weve already preallocated the views for the data to load into, so clear them as well	97331
UNKNOWN	// Widgets appear to be cleared every time you leave, always force invalidate for them	97332
UNKNOWN	// Update the thread priorities given the direction lookahead	97333
UNKNOWN	/*     * Apps PagedView implementation     */	97334
UNKNOWN	// Note: We force a measure here to get around the fact that when we do layout calculations	97335
UNKNOWN	// immediately after syncing, we dont have a proper width.  That said, we already know the	97336
UNKNOWN	// expected page width, so we can actually optimize by hiding all the TextView-based	97337
UNKNOWN	// children that are expensive to measure, and let that happen naturally later.	97338
UNKNOWN	// ensure that we have the right number of items on the pages	97339
UNKNOWN	/**     * A helper to return the priority for loading of the specified widget page.     */	97340
UNKNOWN	// If we are snapping to another page, use that index as the target page index	97341
UNKNOWN	// We use the distance from the target page as an initial guess of priority, but if there	97342
UNKNOWN	// are no pages of higher priority than the page specified, then bump up the priority of	97343
UNKNOWN	// the specified page.	97344
UNKNOWN	/**     * Return the appropriate thread priority for loading for a given page (we give the current     * page much higher priority)     */	97345
UNKNOWN	// TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below	97346
UNKNOWN	/**     * Creates and executes a new AsyncTask to load a page of widget previews.     */	97347
UNKNOWN	// Prune all tasks that are no longer needed	97348
UNKNOWN	// We introduce a slight delay to order the loading of side pages so that we dont thrash	97349
UNKNOWN	// do cleanup inside onSyncWidgetPageItems	97350
UNKNOWN	// Ensure that the task is appropriately prioritized and runs in parallel	97351
UNKNOWN	// do cleanup inside onSyncWidgetPageItems	97352
UNKNOWN	/*     * Widgets PagedView implementation     */	97353
UNKNOWN	// Note: We force a measure here to get around the fact that when we do layout calculations	97354
UNKNOWN	// immediately after syncing, we dont have a proper width.	97355
UNKNOWN	// Calculate the dimensions of each cell we are giving to each widget	97356
UNKNOWN	// Prepare the set of widgets to load previews for in the background	97357
UNKNOWN	// Prepopulate the pages with the other widget info, and fill in the previews later	97358
UNKNOWN	// Fill in the widget information	97359
UNKNOWN	// Determine the widget spans and min resize spans.	97360
UNKNOWN	// Fill in the shortcuts information	97361
UNKNOWN	// Layout each widget	97362
UNKNOWN	// wait until a call on onLayout to start loading, because	97363
UNKNOWN	// PagedViewWidget.getPreviewSize() will return 0 if it hasnt been laid out	97364
UNKNOWN	// TODO: can we do a measure/layout immediately?	97365
UNKNOWN	// loadWidgetPreviewsInBackground can be called without a task to load a set of widget	97368
UNKNOWN	// previews synchronously	97369
UNKNOWN	// Ensure that this task starts running at the correct priority	97370
UNKNOWN	// Load each of the widget/shortcut previews	97371
UNKNOWN	// Ensure we havent been cancelled yet	97372
UNKNOWN	// Before work on each item, ensure that this task is running at the correct	97373
UNKNOWN	// priority	97374
UNKNOWN	// Update all thread priorities	97375
UNKNOWN	// We want our pages to be z-ordered such that the further a page is to the left, the higher	97376
UNKNOWN	// it is in the z-order. This is important to insure touch events are handled correctly.	97377
UNKNOWN	// In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.	97378
UNKNOWN	// make sure were caching at least two pages always	97379
UNKNOWN	/**     * Used by the parent to get the content width to set the tab bar to     * @return     */	97380
UNKNOWN	// We reset the save index when we change pages so that it will be recalculated on next	97381
UNKNOWN	// rotation	97382
UNKNOWN	/*     * AllAppsView implementation     */	97383
UNKNOWN	/**     * We should call thise method whenever the core data changes (mApps, mWidgets) so that we can     * appropriately determine when to invalidate the PagedView page data.  In cases where the data     * has yet to be set, we can requestLayout() and wait for onDataReady() to be called in the     * next onMeasure() pass, which will trigger an invalidatePageData() itself.     */	97384
UNKNOWN	// The next layout pass will trigger data-ready if both widgets and apps are set, so	97385
UNKNOWN	// request a layout to trigger the page data when ready.	97386
UNKNOWN	// We add it in place, in alphabetical order	97387
UNKNOWN	// loop through all the apps and remove apps that have the same component	97388
UNKNOWN	// We remove and re-add the updated applications list because its properties may have	97389
UNKNOWN	// changed (ie. the title), and this will ensure that the items will be in their proper	97390
UNKNOWN	// place in the list.	97391
UNKNOWN	// If we have reset, then we should not continue to restore the previous state	97392
UNKNOWN	// TODO: Dump information related to current list of Applications, Widgets, etc.	97393
UNKNOWN	// TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we	97394
UNKNOWN	// should stop this now.	97395
UNKNOWN	// Stop all background tasks	97396
UNKNOWN	// Put the page indicators above the hotseat	97447
UNKNOWN	// Layout AllApps	97448
UNKNOWN	// Center the all apps page indicator	97449
UNKNOWN	/**     * Apply any Partner customization grid overrides.     *     * Currently we support: all apps row / column count.     */	97397
UNKNOWN	// AllApps uses the original non-scaled icon size	97398
UNKNOWN	/**     * Determine the exact visual footprint of the all apps button, taking into account scaling     * and internal padding of the drawable.     */	97399
UNKNOWN	// There are three possible configurations that the dynamic grid accounts for, portrait,	97400
UNKNOWN	// landscape with the nav bar at the bottom, and landscape with the nav bar at the side.	97401
UNKNOWN	// To prevent waiting for fitSystemWindows(), we make the observation that in landscape,	97402
UNKNOWN	// the height is the smallest height (either with the nav bar at the bottom or to the	97403
UNKNOWN	// side) and otherwise, the height is simply the largest possible height for a portrait	97404
UNKNOWN	// device.	97405
UNKNOWN	// Check to see if the icons fit in the new available height.  If not, then we need to	97406
UNKNOWN	// shrink the icon size.	97407
UNKNOWN	// Make the callbacks	97408
UNKNOWN	// Search Bar	97409
UNKNOWN	// Calculate the actual text height	97410
UNKNOWN	// Folder	97411
UNKNOWN	// All Apps	97412
UNKNOWN	/** Returns the closest device profile given the width and height and a list of profiles */	97413
UNKNOWN	/** Returns the closest device profiles ordered by closeness to the specified width and height */	97414
UNKNOWN	// Sort the profiles by their closeness to the dimensions	97415
UNKNOWN	/** Returns the search bar top offset */	97416
UNKNOWN	/** Returns the search bar bounds in the current orientation */	97417
UNKNOWN	/** Returns the search bar bounds in the specified orientation */	97418
UNKNOWN	// Pad the left and right of the workspace to ensure consistent spacing	97419
UNKNOWN	// between all icons	97420
UNKNOWN	// XXX: If the icon size changes across orientations, we will have to take	97421
UNKNOWN	//      that into account here too.	97422
UNKNOWN	/** Returns the bounds of the workspace page indicators. */	97423
UNKNOWN	/** Returns the workspace padding in the specified orientation */	97424
UNKNOWN	// Pad the left and right of the workspace with search/hotseat bar sizes	97425
UNKNOWN	// Pad the left and right of the workspace to ensure consistent spacing	97426
UNKNOWN	// between all icons	97427
UNKNOWN	// Pad the top and bottom of the workspace with search/hotseat bar sizes	97428
UNKNOWN	// In landscape mode the page spacing is set to the default.	97429
UNKNOWN	// In portrait, we want the pages spaced such that there is no	97430
UNKNOWN	// overhang of the previous / next page into the current page viewport.	97431
UNKNOWN	// We assume symmetrical padding in portrait mode.	97432
UNKNOWN	// The rect returned will be extended to below the system ui that covers the workspace	97433
UNKNOWN	// Layout the search bar space	97434
UNKNOWN	// Vertical search bar space	97435
UNKNOWN	//            searchBar.setPadding(	97436
UNKNOWN	//                    0, 2 * edgeMarginPx, 0,	97437
UNKNOWN	//                    2 * edgeMarginPx);	97438
UNKNOWN	// Horizontal search bar space	97439
UNKNOWN	//            searchBar.setPadding(	97440
UNKNOWN	//                    2 * edgeMarginPx,	97441
UNKNOWN	//                    getSearchBarTopOffset(),	97442
UNKNOWN	//                    2 * edgeMarginPx, 0);	97443
UNKNOWN	// Layout the workspace	97444
UNKNOWN	// Layout the page indicators	97445
UNKNOWN	// Hide the page indicators when we have vertical search/hotseat	97446
UNKNOWN	// Constrain the dimensions of all apps so that it does not span the full width	97450
UNKNOWN	// Only adjust the side paddings on landscape phones, or tablets	97451
UNKNOWN	// The icons are centered, so we cant just offset by the page indicator height	97452
UNKNOWN	// because the empty space will actually be pageIndicatorHeight + paddingTB	97453
UNKNOWN	// Horizontal padding for the whole paged view	97454
UNKNOWN	// Layout the Overview Mode	97455
UNKNOWN	// We have enough space. Lets add some margin too.	97456
UNKNOWN	// Set margin of all visible children except the last visible child	97457
UNKNOWN	/** Sets the scale of the view over the normal workspace icon size. */	97458
UNKNOWN	// suppress dead code warning	97459
UNKNOWN	/**     * Create a window containing this view and show it.     *     * @param windowToken obtained from v.getWindowToken() from one of your views     * @param touchX the x coordinate the user touched in DragLayer coordinates     * @param touchY the y coordinate the user touched in DragLayer coordinates     */	97460
UNKNOWN	// Start the pick-up animation	97461
UNKNOWN	// Post the animation to skip other expensive work happening on the first frame	97462
UNKNOWN	/**     * Move the window containing this view.     *     * @param touchX the x coordinate the user touched in DragLayer coordinates     * @param touchY the y coordinate the user touched in DragLayer coordinates     */	97463
UNKNOWN	/**     * Starts a drag.     *     * @param v The view that is being dragged     * @param bmp The bitmap that represents the view being dragged     * @param source An object representing where the drag originated     * @param dragInfo The data associated with the object that is being dragged     * @param dragAction The drag action: either {@link #DRAG_ACTION_MOVE} or     *        {@link #DRAG_ACTION_COPY}     * @param dragRegion Coordinates within the bitmap b for the position of item being dragged.     *          Makes dragging feel more precise, e.g. you can clip out a transparent border     */	97464
UNKNOWN	/**     * Starts a drag.     *     * @param b The bitmap to display as the drag image.  It will be re-scaled to the     *          enlarged size.     * @param dragLayerX The x position in the DragLayer of the left-top of the bitmap.     * @param dragLayerY The y position in the DragLayer of the left-top of the bitmap.     * @param source An object representing where the drag originated     * @param dragInfo The data associated with the object that is being dragged     * @param dragAction The drag action: either {@link #DRAG_ACTION_MOVE} or     *        {@link #DRAG_ACTION_COPY}     * @param dragRegion Coordinates within the bitmap b for the position of item being dragged.     *          Makes dragging feel more precise, e.g. you can clip out a transparent border     */	97465
UNKNOWN	// Hide soft keyboard, if visible	97466
UNKNOWN	/**     * Draw the view into a bitmap.     */	97467
UNKNOWN	// Reset the drawing cache background color to fully transparent	97468
UNKNOWN	// for the duration of this operation	97469
UNKNOWN	// Restore the view	97470
UNKNOWN	/**     * Call this from a drag source view like this:     *     * <pre>     *  @Override     *  public boolean dispatchKeyEvent(KeyEvent event) {     *      return mDragController.dispatchKeyEvent(this, event)     *              || super.dispatchKeyEvent(event);     * </pre>     */	97471
UNKNOWN	/**     * Stop dragging without dropping.     */	97472
UNKNOWN	// Cancel the current drag if we are removing an app that we are dragging	97473
UNKNOWN	// Added null checks to prevent NPE weve seen in the wild	97474
UNKNOWN	// Only end the drag if we are not deferred	97475
UNKNOWN	/**     * This only gets called as a result of drag view cleanup being deferred in endDrag();     */	97476
UNKNOWN	// If we skipped calling onDragEnd() before, do it now	97477
UNKNOWN	/**     * Clamps the position to the drag layer bounds.     */	97478
UNKNOWN	/**     * Call this from a drag source view.     */	97479
UNKNOWN	// suppress dead code warning	97480
UNKNOWN	// Update the velocity tracker	97481
UNKNOWN	// verify the edgeswipe menu	97482
UNKNOWN	// Remember location of down touch	97483
UNKNOWN	// mDragging = false;	97484
UNKNOWN	// ignore menu if dragging	97485
UNKNOWN	// if from the edges and in limits	97486
UNKNOWN	/**     * Sets the view that should handle move events.     */	97487
UNKNOWN	// Drop on someone?	97488
UNKNOWN	// Check if we are hovering over the scroll areas	97489
UNKNOWN	/**     * Call this from a drag source view.     */	97490
UNKNOWN	// Update the velocity tracker	97491
UNKNOWN	// Remember where the motion event started	97492
UNKNOWN	// Ensure that weve processed a move event at the current pointer	97493
UNKNOWN	// location.	97494
UNKNOWN	/**     * Determines whether the user flung the current item to delete it.     *     * @return the vector at which the item was flung, or null if no fling was detected.     */	97495
UNKNOWN	// Do a quick dot product test to ensure that we are flinging upwards	97496
UNKNOWN	// Clean up dragging on the target if its not the current fling delete target otherwise,	97497
UNKNOWN	// start dragging to it.	97498
UNKNOWN	// Drop onto the fling-to-delete target	97499
UNKNOWN	// We must set dragComplete to true _only_ after we enter the fling-to-delete target for	97500
UNKNOWN	// drop	97501
UNKNOWN	/**     * Sets the drag listner which will be notified when a drag starts or ends.     */	97502
UNKNOWN	/**     * Remove a previously installed drag listener.     */	97503
UNKNOWN	/**     * Add a DropTarget to the list of potential places to receive drop events.     */	97504
UNKNOWN	/**     * Dont send drop events to <em>target</em> any more.     */	97505
UNKNOWN	/**     * Sets the current fling-to-delete drop target.     */	97506
UNKNOWN	/**     * Set which view scrolls for touch events near the edge of the screen.     */	97507
UNKNOWN	// Check the scroll again so that we can requeue the scroller if necessary	97508
UNKNOWN	// Check the scroll again so that we can requeue the scroller if necessary	97509
UNKNOWN	/**     * Applies the new bitmap.     * @return true if the view was invalidated.     */	97510
UNKNOWN	// Draw the bitmap into the bounding rect	97511
UNKNOWN	// No op	97512
UNKNOWN	/**     * When enabled, the icon is grayed out and the contrast is increased to give it a ghost     * appearance.     */	97513
UNKNOWN	// For ghost mode, set the color range to [GHOST_MODE_MIN_COLOR_RANGE, 255]	97514
UNKNOWN	// Brightness: C-new = C-old*(1-amount) + amount	97515
UNKNOWN	// Add the amount to RGB components of the matrix, as per the above formula.	97516
UNKNOWN	// Fifth elements in the array correspond to the constant being added to	97517
UNKNOWN	// red, blue, green, and alpha channel respectively.	97518
UNKNOWN	// only used for ViewPropertyAnimators	97519
UNKNOWN	// If the current play time exceeds the duration, or the animated fraction is 1,	97520
UNKNOWN	// the animation will get finished, even if we call setCurrentPlayTime -- therefore	97521
UNKNOWN	// dont adjust the animation in that case	97522
UNKNOWN	// If we havent drawn our first frame, reset the time to t = 0	97523
UNKNOWN	// (give up after MAX_DELAY ms of waiting though - might happen, for example, if we	97524
UNKNOWN	// are no longer in the foreground and no frames are being rendered ever)	97525
UNKNOWN	// The first frame on animations doesnt always trigger an invalidate...	97526
UNKNOWN	// force an invalidate here to make sure the animation continues to advance	97527
UNKNOWN	// For the second frame, if the first frame took more than 16ms,	97528
UNKNOWN	// adjust the start time and pretend it took only 16ms anyway. This	97529
UNKNOWN	// prevents a large jump in the animation due to an expensive first frame	97530
UNKNOWN	// Redraw if it is already showing. This avoids a bug where the height changes by a small	97531
UNKNOWN	// amount on connecting/disconnecting a bluetooth keyboard.	97532
UNKNOWN	// View not yet laid out. Wait until the view is ready to be drawn, so that be can	97533
UNKNOWN	// get the location on screen.	97534
UNKNOWN	/**     * Gets the location of a view relative in the window, off-setting any shift due to     * page view scroll     */	97535
UNKNOWN	// Ill take it from here	97536
UNKNOWN	// ensure that the overlay view stays on top. we cant use drawing order for this	97537
UNKNOWN	// because in API level 16 touch dispatch doesnt respect drawing order.	97538
UNKNOWN	// Skip propagating onRequestSendAccessibilityEvent all for other children	97539
UNKNOWN	// when a folder is open	97540
UNKNOWN	// Only add the folder as a child for accessibility when it is open	97541
UNKNOWN	// If weve received this, weve already done the necessary handling	97542
UNKNOWN	// in onInterceptHoverEvent. Return true to consume the event.	97543
UNKNOWN	/**     * Determine the rect of the descendant in this DragLayers coordinates     *     * @param descendant The descendant whose coordinates we want to find.     * @param r The rect into which to place the results.     * @return The factor by which this descendant is scaled relative to this DragLayer.     */	97544
UNKNOWN	// because in API level 16 touch dispatch doesnt respect drawing order.	97570
UNKNOWN	// between platform versions 17 and 18, behavior for onChildViewRemoved / Added changed.	97571
UNKNOWN	// Pre-18, the child was not added / removed by the time of those callbacks. We need to	97572
UNKNOWN	// force update our representation of things here to avoid crashing on pre-18 devices	97573
UNKNOWN	// in certain instances.	97574
UNKNOWN	// i represents the current draw iteration	97575
UNKNOWN	/**     * Given a coordinate relative to the descendant, find the coordinate in this DragLayers     * coordinates.     *     * @param descendant The descendant to which the passed coordinate is relative.     * @param coord The coordinate that we want mapped.     * @param includeRootScroll Whether or not to account for the scroll of the root descendant:     *          sometimes this is relevant as in a childs coordinates within the root descendant.     * @return The factor by which this descendant is scaled relative to this DragLayer. Caution     *         this scale factor is assumed to be equal in X and Y, and so if at any point this     *         assumption fails, we will need to return a pair of scale factors.     */	97545
UNKNOWN	/**     * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.     */	97546
UNKNOWN	// Since the child hasnt necessarily been laid out, we force the lp to be updated with	97547
UNKNOWN	// the correct coordinates (above) and use these to determine the final location	97548
UNKNOWN	// We need to account for the scale of the child itself, as the above only accounts for	97549
UNKNOWN	// for the scale in parents.	97550
UNKNOWN	// Account for the source scale of the icon (ie. from AllApps to Workspace, in which	97551
UNKNOWN	// the workspace may have smaller icon bounds).	97552
UNKNOWN	// The child may be scaled (always about the center of the view) so to account for it,	97553
UNKNOWN	// we have to offset the position by the scaled size.  Once we do that, we can center	97554
UNKNOWN	// the drag view about the scaled child view.	97555
UNKNOWN	// Account for holographic blur padding on the drag view	97556
UNKNOWN	// Center in the x coordinate about the targets drawable	97557
UNKNOWN	/**     * This method animates a view at the end of a drag and drop animation.     *     * @param view The view to be animated. This view is drawn directly into DragLayer, and so     *        doesnt need to be a child of DragLayer.     * @param from The initial location of the view. Only the left and top parameters are used.     * @param to The final location of the view. Only the left and top parameters are used. This     *        location doesnt account for scaling, and so should be centered about the desired     *        final location (including scaling).     * @param finalAlpha The final alpha of the view, in case we want it to fade as it animates.     * @param finalScale The final scale of the view. The view is scaled about its center.     * @param duration The duration of the animation.     * @param motionInterpolator The interpolator to use for the location of the view.     * @param alphaInterpolator The interpolator to use for the alpha of the view.     * @param onCompleteRunnable Optional runnable to run on animation completion.     * @param fadeOut Whether or not to fade out the view once the animation completes. If true,     *        the runnable will execute after the view is faded out.     * @param anchorView If not null, this represents the view which the animated view stays     *        anchored to in case scrolling is currently taking place. Note: currently this is     *        only used for the X dimension for the case of the workspace.     */	97558
UNKNOWN	// Calculate the duration of the animation based on the objects distance	97559
UNKNOWN	// If duration < 0, this is a cue to compute the duration based on the distance	97560
UNKNOWN	// Fall back to cubic ease out interpolator for the animation if none is specified	97561
UNKNOWN	// Animate the view	97562
UNKNOWN	// Clean up the previous animations	97563
UNKNOWN	// Show the drop view if it was previously hidden	97564
UNKNOWN	// Set the anchor view if the page is scrolling	97565
UNKNOWN	// Create and start the animation	97566
UNKNOWN	// ensure that the overlay view stays on top. we cant use drawing order for this	97567
UNKNOWN	// because in API level 16 touch dispatch doesnt respect drawing order.	97568
UNKNOWN	// ensure that the overlay view stays on top. we cant use drawing order for this	97569
UNKNOWN	// in general we do nothing	97576
UNKNOWN	// if we have a top index, we return it when drawing last item (highest z-order)	97577
UNKNOWN	// for indexes greater than the top index, we fetch one item above to shift for the	97578
UNKNOWN	// displacement of the top index	97579
UNKNOWN	/**     * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.     */	97580
UNKNOWN	// Draw the background gradient below children.	97581
UNKNOWN	// We want to draw the page hints above the workspace, but below the drag view.	97582
UNKNOWN	// List do not scroll horizontally.	97583
UNKNOWN	// Catch the back button on the soft keyboard so that we can just close the activity	97584
UNKNOWN	// if there is no next page	97614
UNKNOWN	// Select the next icon	97653
UNKNOWN	/**     * Private helper to get the parent TabHost in the view hiearchy.     */	97585
UNKNOWN	/**     * Returns the Viewgroup containing page contents for the page at the index specified.     */	97586
UNKNOWN	// There are two layers, a PagedViewCellLayout and PagedViewCellLayoutChildren	97587
UNKNOWN	/**     * Handles key events in a PageViewExtendedLayout containing PagedViewWidgets.     */	97588
UNKNOWN	// Now that we load items in the bg asynchronously, we cant just focus	97589
UNKNOWN	// child siblings willy-nilly	97590
UNKNOWN	// Select the previous widget or the last widget on the previous page	97591
UNKNOWN	// Select the next widget or the first widget on the next page	97592
UNKNOWN	// Select the closest icon in the previous row, otherwise select the tab bar	97593
UNKNOWN	// Select the closest icon in the previous row, otherwise do nothing	97594
UNKNOWN	// Simulate a click on the widget	97595
UNKNOWN	// Select the first item on the previous page, or the first item on this page	97596
UNKNOWN	// if there is no previous page	97597
UNKNOWN	// Select the first item on the next page, or the last item on this page	97598
UNKNOWN	// if there is no next page	97599
UNKNOWN	// Select the first item on this page	97600
UNKNOWN	// Select the last item on this page	97601
UNKNOWN	/**     * Handles key events in a PageViewCellLayout containing PagedViewIcons.     */	97602
UNKNOWN	// Note we have an extra parent because of the	97603
UNKNOWN	// PagedViewCellLayout/PagedViewCellLayoutChildren relationship	97604
UNKNOWN	// Side pages do not always load synchronously, so check before focusing child siblings	97605
UNKNOWN	// willy-nilly	97606
UNKNOWN	// Select the previous icon or the last icon on the previous page	97607
UNKNOWN	// Select the next icon or the first icon on the next page	97608
UNKNOWN	// Select the closest icon in the previous row, otherwise select the tab bar	97609
UNKNOWN	// Select the closest icon in the next row, otherwise do nothing	97610
UNKNOWN	// Select the first icon on the previous page, or the first icon on this page	97611
UNKNOWN	// if there is no previous page	97612
UNKNOWN	// Select the first icon on the next page, or the last icon on this page	97613
UNKNOWN	// Select the first icon on this page	97615
UNKNOWN	// Select the last icon on this page	97616
UNKNOWN	/**     * Handles key events in the tab widget.     */	97617
UNKNOWN	// Select the previous tab	97618
UNKNOWN	// Select the next tab, or if the last tab has a focus right id, select that	97619
UNKNOWN	// Do nothing	97620
UNKNOWN	// Select the content view	97621
UNKNOWN	/**     * Handles key events in the workspace hotseat (bottom of the screen).     */	97622
UNKNOWN	// NOTE: currently we dont special case for the phone UI in different	97623
UNKNOWN	// orientations, even though the hotseat is on the side in landscape mode. This	97624
UNKNOWN	// is to ensure that accessibility consistency is maintained across rotations.	97625
UNKNOWN	// Select the previous button, otherwise do nothing	97626
UNKNOWN	// Select the next button, otherwise do nothing	97627
UNKNOWN	// Select the first bubble text view in the current page of the workspace	97628
UNKNOWN	// Do nothing	97629
UNKNOWN	/**     * Private helper method to get the CellLayoutChildren given a CellLayout index.     */	97630
UNKNOWN	/**     * Private helper method to sort all the CellLayout children in order of their (x,y) spatially     * from top left to bottom right.     */	97631
UNKNOWN	// First we order each the CellLayout children by their x,y coordinates	97632
UNKNOWN	/**     * Private helper method to find the index of the next BubbleTextView or FolderIcon in the      * direction delta.     *      * @param delta either -1 or 1 depending on the direction we want to search     */	97633
UNKNOWN	// Then we find the next BubbleTextView offset by delta from i	97634
UNKNOWN	/**     * Private helper method to find the next closest BubbleTextView or FolderIcon in the direction      * delta on the next line.     *      * @param delta either -1 or 1 depending on the line and direction we want to search     */	97635
UNKNOWN	/**     * Handles key events in a Workspace containing.     */	97636
UNKNOWN	// Select the previous icon or the last icon on the previous page if possible	97637
UNKNOWN	// Snap to the previous page	97638
UNKNOWN	// Select the next icon or the first icon on the next page if possible	97639
UNKNOWN	// Snap to the next page	97640
UNKNOWN	// Select the closest icon in the previous line, otherwise select the tab bar	97641
UNKNOWN	// Select the closest icon in the next line, otherwise select the button bar	97642
UNKNOWN	// Select the first icon on the previous page or the first icon on this page	97643
UNKNOWN	// if there is no previous page	97644
UNKNOWN	// Snap to the previous page	97645
UNKNOWN	// Select the first icon on the next page or the last icon on this page	97646
UNKNOWN	// if there is no previous page	97647
UNKNOWN	// Snap to the next page	97648
UNKNOWN	// Select the first icon on this page	97649
UNKNOWN	// Select the last icon on this page	97650
UNKNOWN	/**     * Handles key events for items in a Folder.     */	97651
UNKNOWN	// Select the previous icon	97652
UNKNOWN	// Select the closest icon in the previous line	97654
UNKNOWN	// Select the closest icon in the next line	97655
UNKNOWN	// Select the first icon on this page	97656
UNKNOWN	// Select the last icon on this page	97657
UNKNOWN	/**     * Add an app or shortcut     *     * @param item     */	97658
UNKNOWN	/**     * Remove an app or shortcut. Does not change the DB.     *     * @param item     */	97659
UNKNOWN	// One time call to generate the pressed/focused state -- must be called after	97660
UNKNOWN	// measure/layout	97661
UNKNOWN	// One time call to generate the pressed/focused state -- must be called after	97662
UNKNOWN	// measure/layout	97663
UNKNOWN	// suppress dead code warning	97664
UNKNOWN	// Offset the preview background to center this view accordingly	97665
UNKNOWN	// Location is expressed in window coordinates	97666
UNKNOWN	// Location is expressed in window coordinates	97667
UNKNOWN	// TODO: we currently dont support spring-loading for PendingAddShortcutInfos even	97668
UNKNOWN	// though widget-style shortcuts can be added to folders. The issue is that we need	97669
UNKNOWN	// to deal with configuration activities which are currently handled in	97670
UNKNOWN	// Workspace#onDropExternal.	97671
UNKNOWN	// Came from all apps -- make a copy.	97672
UNKNOWN	// ShortcutInfo	97673
UNKNOWN	// These correspond two the drawable and view that the icon was dropped _onto_	97674
UNKNOWN	// This will animate the first item from its position as an icon into its	97675
UNKNOWN	// position as the first item in the preview	97676
UNKNOWN	// This will animate the dragView (srcView) into the new folder	97677
UNKNOWN	// This will animate the first item from its position as an icon into its	97678
UNKNOWN	// position as the first item in the preview	97679
UNKNOWN	// Typically, the animateView corresponds to the DragView; however, if this is being done	97680
UNKNOWN	// after a configuration activity (ie. for a Shortcut being dragged from AllApps) we	97681
UNKNOWN	// will not have a view to animate	97682
UNKNOWN	// Set cellLayout and this to its final state to compute final animation locations	97683
UNKNOWN	// Finished computing final animation locations, restore current state	97684
UNKNOWN	// Came from all apps -- make a copy	97685
UNKNOWN	// cos(45) = 0.707  + ~= 0.1) = 0.8f	97686
UNKNOWN	// We want to imagine our coordinates from the bottom left, growing up and to the	97687
UNKNOWN	// right. This is natural for the x-axis, but for the y-axis, we have to invert things.	97688
UNKNOWN	// Update our drawing parameters if necessary	97689
UNKNOWN	// Call the superclass onTouchEvent first, because sometimes it changes the state to	97690
UNKNOWN	// isPressed() on an ACTION_UP	97691
UNKNOWN	// Location is expressed in window coordinates	97692
UNKNOWN	// Location is expressed in window coordinates	97693
UNKNOWN	/**     * Generate the pressed/focused states if necessary.     */	97694
UNKNOWN	//noinspection ZeroLengthArrayAllocation	97695
UNKNOWN	/**     * Invalidates the pressed/focused states.     */	97696
UNKNOWN	/**     * Creates a copy of the original image.     */	97697
UNKNOWN	/**     * Creates a new press state image which is the old image with a blue overlay.     * Responsibility for the bitmap is transferred to the caller.     */	97698
UNKNOWN	/**     * Applies a more expensive and accurate outline to whatever is currently drawn in a specified     * bitmap.     */	97699
UNKNOWN	// We start by removing most of the alpha channel so as to ignore shadows, and	97700
UNKNOWN	// other types of partial transparency when defining the shape of the object	97701
UNKNOWN	// calculate the outer blur first	97702
UNKNOWN	// calculate the inner blur	97703
UNKNOWN	// mask out the inner blur	97704
UNKNOWN	// draw the inner and outer blur	97705
UNKNOWN	// draw the bright outline	97706
UNKNOWN	// cleanup	97707
UNKNOWN	// adjust the clip rect so that we dont include the text label	97708
UNKNOWN	// Draw the View into the bitmap.	97709
UNKNOWN	// The translate of scrollX and scrollY is necessary when drawing TextViews, because	97710
UNKNOWN	// they set scrollX and scrollY to large values to achieve centered text	97711
UNKNOWN	// We use the same intents as Lawnchair.	97712
UNKNOWN	// We find out how tall the text view wants to be (it is set to wrap_content), so that	97713
UNKNOWN	// we can allocate the appropriate amount of space for it.	97714
UNKNOWN	// We disable action mode for now since it messes up the view on phones	97715
UNKNOWN	// Return if global dragging is not enabled	97716
UNKNOWN	// Convert to a string here to ensure that no other state associated with the text field	97717
UNKNOWN	// gets saved.	97718
UNKNOWN	// In order to clear the focus from the text field, we set the focus on ourself. This	97719
UNKNOWN	// ensures that every time the field is clicked, focus is gained, giving reliable behavior.	97720
UNKNOWN	/**     * We need to handle touch events to prevent them from falling through to the workspace below.     */	97721
UNKNOWN	// When the folder gets focus, we dont want to announce the list of items.	97722
UNKNOWN	/**     * @return the FolderInfo object associated with this folder     */	97723
UNKNOWN	// We rearrange the items in case there are any empty gaps	97724
UNKNOWN	// If our folder has too many items we prune them from the list. This is an issue	97725
UNKNOWN	// when upgrading from the old Folders implementation which could contain an unlimited	97726
UNKNOWN	// number of items.	97727
UNKNOWN	// In case any children didnt come across during loading, clean up the folder accordingly	97728
UNKNOWN	/**     * Creates a new UserFolder, inflated from R.layout.user_folder.     *     * @param context The applications context.     *     * @return A new UserFolder.     */	97729
UNKNOWN	/**     * This method is intended to make the UserFolder to be visually identical in size and position     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.     */	97730
UNKNOWN	// in low power mode the animation doesnt play, so set the end value here	97731
UNKNOWN	// in low power mode the animation doesnt play, so set the end value here	97732
UNKNOWN	/* mContent.setAlpha(0f);            Animator iconsAlpha = LauncherAnimUtils.ofFloat(mContent, alpha, 0f, 1f);            iconsAlpha.setDuration(mMaterialExpandDuration);            iconsAlpha.setStartDelay(mMaterialExpandStagger);            iconsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));            mFolderName.setAlpha(0f);            Animator textAlpha = LauncherAnimUtils.ofFloat(mFolderName, alpha, 0f, 1f);            textAlpha.setDuration(mMaterialExpandDuration);            textAlpha.setStartDelay(mMaterialExpandStagger);            textAlpha.setInterpolator(new AccelerateInterpolator(1.5f));*/	97733
UNKNOWN	// in low power mode the animation doesnt play, so set the end value here	97734
UNKNOWN	/* anim.play(iconsAlpha);            anim.play(textAlpha);*/	97735
UNKNOWN	// Make sure the folder picks up the last drag move even if the finger doesnt move.	97736
UNKNOWN	// in low power mode the animation doesnt play, so set the end value here	97737
UNKNOWN	/*final ObjectAnimator oa =                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);*/	97738
UNKNOWN	// power save mode is no fun - skip alpha animation and just set it to 0	97739
UNKNOWN	// otherwise the icons will stay around until the duration of the animation	97740
UNKNOWN	// We need to check here to verify that the given items location isnt already occupied	97741
UNKNOWN	// by another item.	97742
UNKNOWN	// This shouldnt happen, log it.	97743
UNKNOWN	// This is used to compute the visual center of the dragView. The idea is that	97744
UNKNOWN	// the visual center represents the users interpretation of where the item is, and hence	97745
UNKNOWN	// is the appropriate point to use when determining drop location.	97746
UNKNOWN	// These represent the visual top and left of drag view if a dragRect was provided.	97747
UNKNOWN	// If a dragRect was not provided, then they correspond to the actual view left and	97748
UNKNOWN	// top, as the dragRect is in that case taken to be the entire dragView.	97749
UNKNOWN	// R.dimen.dragViewOffsetY.	97750
UNKNOWN	// In order to find the visual center, we shift by half the dragRect	97751
UNKNOWN	// Exiting folder; stop the auto scroller.	97752
UNKNOWN	// We only close the folder if this is a true drag exit, ie. not because	97753
UNKNOWN	// a drop has occurred above the folder.	97754
UNKNOWN	// The drag failed, we need to return the item to the folder	97755
UNKNOWN	// Reordering may have occured, and we need to save the new item locations. We do this once	97756
UNKNOWN	// at the end to prevent unnecessary database operations.	97757
UNKNOWN	// Do nothing	97758
UNKNOWN	// Do nothing	97759
UNKNOWN	// Current grid is too small, expand it	97760
UNKNOWN	// In case the workspace is scrolling, we need to use the final scroll to compute	97761
UNKNOWN	// the folders bounds.	97762
UNKNOWN	// We first fetch the currently visible CellLayoutChildren	97763
UNKNOWN	// We reset the workspaces scroll	97764
UNKNOWN	// We need to bound the folder to the currently visible CellLayoutChildren	97765
UNKNOWN	// Center the folder if it is full (on phones only)	97766
UNKNOWN	// If the folder doesnt fit within the bounds, center it about the desired bounds	97767
UNKNOWN	// Dont cap the height of the content to allow scrolling.	97768
UNKNOWN	// Add the last remaining child to the workspace in place of the folder	97769
UNKNOWN	// Move the item from the folder to the workspace, in the position of the folder	97770
UNKNOWN	// Remove the folder	97771
UNKNOWN	// b/12446428 -- sometimes the cell layout has already gone away?	97772
UNKNOWN	// We add the child after removing the folder to prevent both from existing at	97773
UNKNOWN	// the same time in the CellLayout.  We need to add the new item with addInScreenFromBind()	97774
UNKNOWN	// to ensure that hotseat items are placed correctly.	97775
UNKNOWN	// Move the item from the folder to the workspace, in the position of the folder	97776
UNKNOWN	// Remove the folder	97777
UNKNOWN	// b/12446428 -- sometimes the cell layout has already gone away?	97778
UNKNOWN	// We add the child after removing the folder to prevent both from existing at	97779
UNKNOWN	// the same time in the CellLayout.  We need to add the new item with addInScreenFromBind()	97780
UNKNOWN	// to ensure that hotseat items are placed correctly.	97781
UNKNOWN	// This method keeps track of the last item in the folder for the purposes	97782
UNKNOWN	// of keyboard focus	97783
UNKNOWN	// If we are coming from All Apps space, we defer removing the extra empty screen	97784
UNKNOWN	// until the folder closes	97785
UNKNOWN	// Actually move the item in the database if it was an external drag. Call this	97786
UNKNOWN	// before creating the view, so that ShortcutInfo is updated appropriately.	97787
UNKNOWN	// We only need to update the locations if it doesnt get handled in #onDropCompleted.	97788
UNKNOWN	// Temporarily reset the scale such that the animation target gets calculated correctly.	97789
UNKNOWN	// Temporarily suppress the listener, as we did all the work already here.	97790
UNKNOWN	// Clear the drag info, as it is no longer being dragged.	97791
UNKNOWN	// This is used so the item doesnt immediately appear in the folder when added. In one case	97792
UNKNOWN	// we need to create the illusion that the item isnt added back to the folder yet, to	97793
UNKNOWN	// to correspond to the animation of the icon back into the folder. This is	97794
UNKNOWN	// If the item was dropped onto this open folder, we have done the work associated	97795
UNKNOWN	// with adding the item to the folder, as indicated by mSuppressOnAdd being set	97796
UNKNOWN	// The current layout is full, can we expand it?	97797
UNKNOWN	// If this item is being dragged from this open folder, we have already handled	97798
UNKNOWN	// the work associated with removing the item, so we dont have to do anything here.	97799
UNKNOWN	// Get the hover color	97800
UNKNOWN	// TODO: investigate why this is ever happening. Presently only on one known device.	97801
UNKNOWN	// Remove the text in the Phone UI in landscape	97802
UNKNOWN	// acceptDrop is called just before onDrop. We do the work here, rather than	97803
UNKNOWN	// in onDrop, because it allows us to reject the drop (by returning false)	97804
UNKNOWN	// so that the object being dragged isnt removed from the drag source.	97805
UNKNOWN	// There is no post-drop animation, so clean up the DragView now	97806
UNKNOWN	// Hide this button unless we are dragging something from AllApps	97807
UNKNOWN	// We cant move out horizontally	97878
UNKNOWN	// We cant move out vertically	97879
UNKNOWN	// If an animation is started and then stopped very quickly, we can still	97808
UNKNOWN	// get spurious updates weve cleared the tag. Guard against this.	97809
UNKNOWN	// suppress dead code warning	97810
UNKNOWN	// Try to prevent it from continuing to run	97811
UNKNOWN	// Set whether or not to invert the layout horizontally if the layout is in RTL mode.	97812
UNKNOWN	// When were large, we are either drawn in a hover state (ie when dragging an item to	97813
UNKNOWN	// a neighboring page) or with just a normal background (if backgroundAlpha > 0.0f)	97814
UNKNOWN	// When were small, we are either drawn normally or in the accepts drops state (during	97815
UNKNOWN	// a drag). However, we also drag the mini hover background *over* one of those two	97816
UNKNOWN	// backgrounds	97817
UNKNOWN	// In the mini case, we draw the active_glow bg *over* the active background	97818
UNKNOWN	// The folder outer / inner ring image(s)	97819
UNKNOWN	// Draw outer ring, if it exists	97820
UNKNOWN	// Draw inner ring	97821
UNKNOWN	// Mismatched viewId / viewType preventing restore. Skip restore on production builds.	97822
UNKNOWN	// Cancel long press for all children	97823
UNKNOWN	// Generate an id for each view, this assumes we have at most 256x256 cells	97824
UNKNOWN	// per workspace screen	97825
UNKNOWN	// If the horizontal or vertical span is set to -1, it is taken to	97826
UNKNOWN	// mean that it spans the extent of the CellLayout	97827
UNKNOWN	// First we clear the tag to ensure that on every touch down we start with a fresh slate,	97828
UNKNOWN	// even in the case where we return early. Not clearing here was causing bugs whereby on	97829
UNKNOWN	// long-press wed end up picking up an item from a previous drag operation.	97830
UNKNOWN	/**     * Given a point, return the cell that strictly encloses that point     * @param x X coordinate of the point     * @param y Y coordinate of the point     * @param result Array of 2 ints to hold the x and y coordinate of the cell     */	97831
UNKNOWN	/**     * Given a point, return the cell that most closely encloses that point     * @param x X coordinate of the point     * @param y Y coordinate of the point     * @param result Array of 2 ints to hold the x and y coordinate of the cell     */	97832
UNKNOWN	/**     * Given a cell coordinate, return the point that represents the upper left corner of that cell     *     * @param cellX X coordinate of the cell     * @param cellY Y coordinate of the cell     *     * @param result Array of 2 ints to hold the x and y coordinate of the point     */	97833
UNKNOWN	/**     * Given a cell coordinate, return the point that represents the center of the cell     *     * @param cellX X coordinate of the cell     * @param cellY Y coordinate of the cell     *     * @param result Array of 2 ints to hold the x and y coordinate of the point     */	97834
UNKNOWN	/**     * Given a cell coordinate and span return the point that represents the center of the regio     *     * @param cellX X coordinate of the cell     * @param cellY Y coordinate of the cell     *     * @param result Array of 2 ints to hold the x and y coordinate of the point     */	97835
UNKNOWN	/**     * Given a cell coordinate and span fills out a corresponding pixel rect     *     * @param cellX X coordinate of the cell     * @param cellY Y coordinate of the cell     * @param result Rect in which to write the result     */	97836
UNKNOWN	/** Return a rect that has the cellWidth/cellHeight (left, top), and     * widthGap/heightGap (right, bottom) */	97837
UNKNOWN	// Expand the background drawing bounds by the padding baked into the background drawable	97838
UNKNOWN	// We cancel any existing animations	97839
UNKNOWN	// Exit early if were not actually moving the view	97840
UNKNOWN	// If the animation was cancelled, it means that another animation	97841
UNKNOWN	// has interrupted this one, and we dont want to lock the item into	97842
UNKNOWN	// place just yet.	97843
UNKNOWN	// If the animation was cancelled, it means that another animation	97844
UNKNOWN	// has interrupted this one, and we dont want to lock the item into	97845
UNKNOWN	// place just yet.	97846
UNKNOWN	/**     * Estimate where the top left cell of the dragged item will land if it is dropped.     *     * @param originX The X value of the top left corner of the item     * @param originY The Y value of the top left corner of the item     * @param spanX The number of horizontal cells that the item spans     * @param spanY The number of vertical cells that the item spans     * @param result The estimated drop cell X and Y.     */	97847
UNKNOWN	// pointToCellRounded takes the top left of a cell but will pad that with	97848
UNKNOWN	// cellWidth/2 and cellHeight/2 when finding the matching cell	97849
UNKNOWN	// If the item isnt fully on this screen, snap to the edges	97850
UNKNOWN	// Snap to right	97851
UNKNOWN	// Snap to left	97852
UNKNOWN	// Snap to bottom	97853
UNKNOWN	// Snap to top	97854
UNKNOWN	// Find the top left corner of the rect the object will occupy	97855
UNKNOWN	// When drawing the drag outline, it did not account for margin offsets	97856
UNKNOWN	// added by the views parent.	97857
UNKNOWN	// Offsets due to the size difference between the View and the dragOutline.	97858
UNKNOWN	// There is a size difference to account for the outer blur, which may lie	97859
UNKNOWN	// outside the bounds of the view.	97860
UNKNOWN	// We center about the x axis	97861
UNKNOWN	// Center the drag region *horizontally* in the cell and apply a drag	97862
UNKNOWN	// outline offset	97863
UNKNOWN	// Center the drag outline in the cell	97864
UNKNOWN	// We verify that the current rect is not a sub-rect of any of our previous	97880
UNKNOWN	// candidates. In this case, the current rect is disqualified in favour of the	97881
UNKNOWN	// containing rect.	97882
UNKNOWN	// re-mark space taken by ignoreView as occupied	97883
UNKNOWN	// Return -1, -1 if no suitable location found	97884
UNKNOWN	/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	97865
UNKNOWN	/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param minSpanX The minimum horizontal span required     * @param minSpanY The minimum vertical span required     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	97866
UNKNOWN	/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreOccupied If true, the result can be an occupied cell     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	97867
UNKNOWN	/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param minSpanX The minimum horizontal span required     * @param minSpanY The minimum vertical span required     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreOccupied If true, the result can be an occupied cell     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	97868
UNKNOWN	// mark space take by ignoreView as available (method checks if ignoreView is null)	97869
UNKNOWN	// For items with a spanX / spanY > 1, the passed in point (pixelX, pixelY) corresponds	97870
UNKNOWN	// to the center of the item, but we are searching based on the top-left cell, so	97871
UNKNOWN	// we translate the point over to correspond to the top-left.	97872
UNKNOWN	// Keep track of best-scoring drop area	97873
UNKNOWN	// First, lets see if this thing fits anywhere	97874
UNKNOWN	// We know that the item will fit at _some_ acceptable size, now lets see	97875
UNKNOWN	// how big we can make it. Well alternate between incrementing x and y spans	97876
UNKNOWN	// until we hit a limit.	97877
UNKNOWN	/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location, and will also weigh in a suggested direction vector of the     * desired location. This method computers distance based on unit grid distances,     * not pixel distances.     *     * @param cellX The X cell nearest to which you want to search for a vacant area.     * @param cellY The Y cell nearest which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param direction The favored direction in which the views should move from x, y     * @param exactDirectionOnly If this parameter is true, then only solutions where the direction     *        matches exactly. Otherwise we find the best matching direction.     * @param occoupied The array which represents which cells in the CellLayout are occupied     * @param blockOccupied The array which represents which cells in the specified block (cellX,     *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views.     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	97885
UNKNOWN	// Keep track of best-scoring drop area	97886
UNKNOWN	// First, lets see if this thing fits anywhere	97887
UNKNOWN	// The direction score is just the dot product of the two candidate direction	97888
UNKNOWN	// and that passed in.	97889
UNKNOWN	// Return -1, -1 if no suitable location found	97890
UNKNOWN	// Determine the edge of the cluster that will be leading the push and how far	97891
UNKNOWN	// the cluster must be shifted.	97892
UNKNOWN	// Break early for invalid push distance.	97893
UNKNOWN	// Mark the occupied state as false for the group of views we want to move.	97894
UNKNOWN	// We save the current configuration -- if we fail to find a solution we will revert	97895
UNKNOWN	// to the initial state. The process of finding a solution modifies the configuration	97896
UNKNOWN	// in place, hence the need for revert in the failure case.	97897
UNKNOWN	// The pushing algorithm is simplified by considering the views in the order in which	97898
UNKNOWN	// they would be pushed by the cluster. For example, if the cluster is leading with its	97899
UNKNOWN	// left edge, we consider sort the views by their right edge, from right to left.	97900
UNKNOWN	// For each view that isnt in the cluster, we see if the leading edge of the	97901
UNKNOWN	// cluster is contacting the edge of that view. If so, we add that view to the	97902
UNKNOWN	// cluster.	97903
UNKNOWN	// The push solution includes the all apps button, this is not viable.	97904
UNKNOWN	// Adding view to cluster, mark it as not occupied.	97905
UNKNOWN	// The cluster has been completed, now we move the whole thing over in the appropriate	97906
UNKNOWN	// direction.	97907
UNKNOWN	// Due to the nature of the algorithm, the only check required to verify a valid solution	97908
UNKNOWN	// is to ensure that completed shifted cluster lies completely within the cell layout.	97909
UNKNOWN	// In either case, we set the occupied array as marked for the location of the views	97910
UNKNOWN	// We construct a rect which represents the entire group of views passed in	97911
UNKNOWN	// Mark the occupied state as false for the group of views we want to move.	97912
UNKNOWN	// We mark more precisely which parts of the bounding rect are truly occupied, allowing	97913
UNKNOWN	// for interlocking.	97914
UNKNOWN	// If we successfuly found a location by pushing the block of views, we commit it	97915
UNKNOWN	// In either case, we set the occupied array as marked for the location of the views	97916
UNKNOWN	// This method tries to find a reordering solution which satisfies the push mechanic by trying	97917
UNKNOWN	// to push items in each of the cardinal directions, in an order based on the direction vector	97918
UNKNOWN	// passed.	97919
UNKNOWN	// If the direction vector has two non-zero components, we try pushing	97920
UNKNOWN	// separately in each of the components.	97921
UNKNOWN	// Revert the direction	97922
UNKNOWN	// Now we try pushing in each component of the opposite direction	97923
UNKNOWN	// revert the direction	97924
UNKNOWN	// If the direction vector has a single non-zero component, we push first in the	97925
UNKNOWN	// direction of the vector	97926
UNKNOWN	// Then we try the opposite direction	97927
UNKNOWN	// Switch the direction back	97928
UNKNOWN	// If we have failed to find a push solution with the above, then we try	97929
UNKNOWN	// to find a solution by pushing along the perpendicular axis.	97930
UNKNOWN	// Swap the components	97931
UNKNOWN	// Then we try the opposite direction	97932
UNKNOWN	// Switch the direction back	97933
UNKNOWN	// Swap the components back	97934
UNKNOWN	// Return early if get invalid cell positions	97935
UNKNOWN	// Mark the desired location of the view currently being dragged.	97936
UNKNOWN	// First we try to find a solution which respects the push mechanic. That is,	97937
UNKNOWN	// we try to find a solution such that no displaced item travels through another item	97938
UNKNOWN	// without also displacing that item.	97939
UNKNOWN	// Next we try moving the views as a block, but without requiring the push mechanic.	97940
UNKNOWN	// Ok, they couldnt move as a block, lets move them individually	97941
UNKNOWN	/*     * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between     * the provided point and the provided cell     */	97942
UNKNOWN	// Copy the current state into the solution. This solution will be manipulated as necessary.	97943
UNKNOWN	// Copy the current occupied array into the temporary occupied array. This array will be	97944
UNKNOWN	// manipulated as necessary to find a solution.	97945
UNKNOWN	// We find the nearest cell into which we would place the dragged item, assuming theres	97946
UNKNOWN	// nothing in its way.	97947
UNKNOWN	// First we try the exact nearest position of the item being dragged,	97948
UNKNOWN	// we will then want to try to move this around to other neighbouring positions	97949
UNKNOWN	// We try shrinking the widget down to size in an alternating pattern, shrink 1 in	97950
UNKNOWN	// x, then 1 in y etc.	97951
UNKNOWN	// This method starts or changes the reorder preview animations	97952
UNKNOWN	// We make sure to end only after a full period	97953
UNKNOWN	// We make sure to end only after a full period	97954
UNKNOWN	// We do a null check here because the item info can be null in the case of the	97955
UNKNOWN	// AllApps button in the hotseat.	97956
UNKNOWN	/* This seems like it should be obvious and straight-forward, but when the direction vector    needs to match with the notion of the dragView pushing other views, we have to employ    a slightly more subtle notion of the direction vector. The question is what two points is    the vector between? The center of the dragView and its desired destination? Not quite, as    this doesnt necessarily coincide with the interaction of the dragView and items occupying    those cells. Instead we use some heuristics to often lock the vector to up, down, left    or right, which helps make pushing feel right.    */	97957
UNKNOWN	// No idea what to do, give a random direction.	97958
UNKNOWN	// For a given cell and span, fetch the set of views intersecting the region.	97959
UNKNOWN	// First we determine if things have moved enough to cause a different layout	97960
UNKNOWN	// If were just testing for a possible location (MODE_ACCEPT_DROP), we dont bother	97961
UNKNOWN	// committing anything or animating anything as we just want to determine if a solution	97962
UNKNOWN	// exists	97963
UNKNOWN	// First we determine if things have moved enough to cause a different layout	97964
UNKNOWN	// When we are checking drop validity or actually dropping, we dont recompute the	97965
UNKNOWN	// direction vector, since we want the solution to match the preview, and its possible	97966
UNKNOWN	// that the exact position of the item has changed to result in a new reordering outcome.	97967
UNKNOWN	// We reset this vector after drop	97968
UNKNOWN	// Find a solution involving pushing / displacing any items in the way	97969
UNKNOWN	// We attempt the approach which doesnt shuffle views at all	97970
UNKNOWN	// If the reorder solution requires resizing (shrinking) the item being dropped, we instead	97971
UNKNOWN	// favor a solution in which the item is not resized, but	97972
UNKNOWN	// If were just testing for a possible location (MODE_ACCEPT_DROP), we dont bother	97973
UNKNOWN	// committing anything or animating anything as we just want to determine if a solution	97974
UNKNOWN	// exists	97975
UNKNOWN	// Copy current state into savedMap	97976
UNKNOWN	// Restore current state from savedMap	97977
UNKNOWN	/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreView Considers space occupied by this view as unoccupied     * @param result Previously returned value to possibly recycle.     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	97978
UNKNOWN	// re-mark space taken by ignoreView as occupied	97990
UNKNOWN	/**     * A drag event has begun over this layout.     * It may have begun over this layout (in which case onDragChild is called first),     * or it may have begun on another layout.     */	97991
UNKNOWN	/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param minSpanX The minimum horizontal span required     * @param minSpanY The minimum vertical span required     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreView Considers space occupied by this view as unoccupied     * @param result Previously returned value to possibly recycle.     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	97979
UNKNOWN	/**     * Find a starting cell position that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreView Considers space occupied by this view as unoccupied     * @param result Previously returned value to possibly recycle.     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	97980
UNKNOWN	/**     * Finds the upper-left coordinate of the first rectangle in the grid that can     * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,     * then this method will only return coordinates for rectangles that contain the cell     * (intersectX, intersectY)     *     * @param cellXY The array that will contain the position of a vacant cell if such a cell     *               can be found.     * @param spanX The horizontal span of the cell we want to find.     * @param spanY The vertical span of the cell we want to find.     *     * @return True if a vacant cell of the specified dimension was found, false otherwise.     */	97981
UNKNOWN	/**     * Like above, but ignores any cells occupied by the item ignoreView     *     * @param cellXY The array that will contain the position of a vacant cell if such a cell     *               can be found.     * @param spanX The horizontal span of the cell we want to find.     * @param spanY The vertical span of the cell we want to find.     * @param ignoreView The home screen item we should treat as not occupying any space     * @return     */	97982
UNKNOWN	/**     * Like above, but if intersectX and intersectY are not -1, then this method will try to     * return coordinates for rectangles that contain the cell [intersectX, intersectY]     *     * @param spanX The horizontal span of the cell we want to find.     * @param spanY The vertical span of the cell we want to find.     * @param ignoreView The home screen item we should treat as not occupying any space     * @param intersectX The X coordinate of the cell that we should try to overlap     * @param intersectX The Y coordinate of the cell that we should try to overlap     *     * @return True if a vacant cell of the specified dimension was found, false otherwise.     */	97983
UNKNOWN	/**     * The superset of the above two methods     */	97984
UNKNOWN	// mark space take by ignoreView as available (method checks if ignoreView is null)	97985
UNKNOWN	// small optimization: we can skip to after the column we just found	97986
UNKNOWN	// an occupied cell	97987
UNKNOWN	// if we failed to find anything, try again but without any requirements of	97988
UNKNOWN	// intersecting	97989
UNKNOWN	/**     * Called when drag has left this CellLayout or has been completed (successfully or not)     */	97992
UNKNOWN	// This can actually be called when we arent in a drag, e.g. when adding a new	97993
UNKNOWN	// item to this layout via the customize drawer.	97994
UNKNOWN	// Guard against that case.	97995
UNKNOWN	// Invalidate the drag data	97996
UNKNOWN	/**     * Mark a child as having been dropped.     * At the beginning of the drag operation, the child may have been on another     * screen, but it is re-parented before this method is called.     *     * @param child The child that is being dropped     */	97997
UNKNOWN	/**     * Computes a bounding rectangle for a range of cells     *     * @param cellX X coordinate of upper left corner expressed as a cell position     * @param cellY Y coordinate of upper left corner expressed as a cell position     * @param cellHSpan Width in cells     * @param cellVSpan Height in cells     * @param resultRect Rect into which to put the results     */	97998
UNKNOWN	/**     * Computes the required horizontal and vertical cell spans to always     * fit the given rectangle.     *     * @param width Width in pixels     * @param height Height in pixels     * @param result An array of length 2 in which to store the result (may be null).     */	97999
UNKNOWN	// Always assume were working with the smallest span to make sure we	98000
UNKNOWN	// reserve enough space in both orientations.	98001
UNKNOWN	// Always round up to next largest cell	98002
UNKNOWN	/**     * Calculate the grid spans needed to fit given item     */	98003
UNKNOWN	// Its not a widget, so it must be 1x1	98004
UNKNOWN	/**     * Find the first vacant cell, if there is one.     *     * @param vacant Holds the x and y coordinate of the vacant cell     * @param spanX Horizontal cell span.     * @param spanY Vertical cell span.     *     * @return True if a vacant cell was found     */	98005
UNKNOWN	// We make sure to end only after a full period	98006
UNKNOWN	// We make sure to end only after a full period	98007
UNKNOWN	// Copy current state into savedMap	98008
UNKNOWN	// Restore current state from savedMap	98009
UNKNOWN	// Lazy-create inflater	98010
UNKNOWN	// Use the convert-view where possible	98011
UNKNOWN	// Set the icon	98012
UNKNOWN	// Set the text	98013
UNKNOWN	// Lazy-create inflater	98014
UNKNOWN	// Use the convert-view where possible	98015
UNKNOWN	// Set the icon	98016
UNKNOWN	// Set the text	98017
UNKNOWN	// Make sure its stopped before we modify any values	98018
UNKNOWN	// TODO: We dont really need to do the animation if startValue == toValue, but	98019
UNKNOWN	// somehow that doesnt seem to work, possibly a quirk of the animation framework	98020
UNKNOWN	// Ensure we dont calculate a non-sensical duration	98021
UNKNOWN	/**     * Return true when the animation is not running and it hasnt even been started.     */	98022
UNKNOWN	/**     * This is the equivalent of calling Animator.start(), except that it can be called when     * the animation is running in the opposite direction, in which case we reverse     * direction and animate for a correspondingly shorter duration.     */	98023
UNKNOWN	/**     * This is the roughly the equivalent of calling Animator.reverse(), except that it uses the     * same interpolation curve as animateIn(), rather than mirroring it. Also, like animateIn(),     * if the animation is currently running in the opposite direction, we reverse     * direction and animate for a correspondingly shorter duration.     */	98024
UNKNOWN	/**     * Remove any records for the supplied ComponentName.     */	98025
UNKNOWN	/**     * Remove any records for the supplied package name.     */	98026
UNKNOWN	/**     * Empty out the cache.     */	98027
UNKNOWN	/**     * Empty out the cache that arent of the correct grid size     */	98028
UNKNOWN	/**     * Fill in application with the icon and label for info.     */	98029
UNKNOWN	/**     * Parse the appfilter.xml file from the selected icon pack.     */	98030
UNKNOWN	/**     * Check if an icon is available in the current icon pack.     */	98031
UNKNOWN	// null info means not installed, but if we have a component from the intent then	98032
UNKNOWN	// we should still look in the cache for restored app icons.	98033
UNKNOWN	/**     * Fill in shortcutInfo with the icon and label for info.     */	98034
UNKNOWN	// null info means not installed, but if we have a component from the intent then	98035
UNKNOWN	// we should still look in the cache for restored app icons.	98036
UNKNOWN	/**     * Retrieves the entry from the cache. If the entry is not present, it creates a new entry.     * This method is not thread safe, it must be called from a synchronized method.     */	98037
UNKNOWN	/**     * Adds a default package entry in the cache. This entry is not persisted and will be removed     * when the cache is flushed.     */	98038
UNKNOWN	/**     * Gets an entry for the package, which can be used as a fallback entry for various components.     * This method is not thread safe, it must be called from a synchronized method.     */	98039
UNKNOWN	/**     * Pre-load an icon into the persistent cache.     *     * <P>Queries for a component that does not exist in the package manager     * will be answered by the persistent cache.     *     * @param context application context     * @param componentName the icon should be returned for this component     * @param icon the icon to be persisted     * @param dpi the native density of the icon     */	98040
UNKNOWN	// TODO rescale to the correct native DPI	98041
UNKNOWN	// component is present on the system already, do nothing	98042
UNKNOWN	// pass	98043
UNKNOWN	/**     * Read a pre-loaded icon from the persistent icon cache.     *     * @param componentName the component that should own the icon     * @returns a bitmap if one is cached, or null.     */	98044
UNKNOWN	// We dont keep icons for other profiles in persistent cache.	98045
UNKNOWN	/**     * Remove a pre-loaded icon from the persistent icon cache.     *     * @param componentName the component that should own the icon     */	98046
UNKNOWN	// We dont keep icons for other profiles in persistent cache.	98047
UNKNOWN	/**     * Write the fields of this item to the DB     *      * @param context A context object to use for getting UserManagerCompat     * @param values     */	98048
UNKNOWN	// We should never persist an item on the extra empty screen.	98049
UNKNOWN	// Try go guesstimate how much space the icon will take when serialized	98050
UNKNOWN	// to avoid unnecessary allocations/copies during the write.	98051
UNKNOWN	/**     * It is very important that sub-classes implement this if they contain any references     * to the activity (anything in the view hierarchy etc.). If not, leaks can result since     * ItemInfo objects persist across rotation and can hence leak by holding stale references     * to the old view hierarchy / activity.     */	98052
UNKNOWN	// Helper method. Assumes a draw is pending, and that if the animations duration is 0	98053
UNKNOWN	// it should be cancelled	98054
UNKNOWN	// Use this as a signal that the animation was cancelled	98055
UNKNOWN	// Use this as a signal that the animation was cancelled	98056
UNKNOWN	// Were willing to let this slide. The exception is being caused by the list of	98057
UNKNOWN	// RemoteViews which is being passed back. The startListening relationship will	98058
UNKNOWN	// have been established by this point, and we will end up populating the	98059
UNKNOWN	// widgets upon bind anyway. See issue 14255011 for more context.	98060
UNKNOWN	// Once we get the message that widget packages are updated, we need to rebind items	98061
UNKNOWN	// in AppsCustomize accordingly.	98062
UNKNOWN	/**     * Returns true if the intent is a valid launch intent for a launcher activity of an app.     * This is used to identify shortcuts which are different from the ones exposed by the     * applications manifest file.     *     * @param launchIntent The intent that will be launched when the shortcut is clicked.     */	98063
UNKNOWN	// An app target can either have no extra or have ItemInfo.EXTRA_PROFILE.	98064
UNKNOWN	// This name is only used for comparisons and notifications, so fall back to activity name	98065
UNKNOWN	// if not supplied	98066
UNKNOWN	// Queue the item up for adding if launcher has not loaded properly yet	98067
UNKNOWN	// Since its a custom shortcut, verify that it is safe to launch.	98068
UNKNOWN	// Target cannot be launched, or requires some special permission to launch	98069
UNKNOWN	//final Intent data = pendingInfo.data;	98070
UNKNOWN	//final boolean allowDuplicate = data.getBooleanExtra(Launcher.EXTRA_SHORTCUT_DUPLICATE, true);	98071
UNKNOWN	// If the intent specifies a package, make sure the package exists	98072
UNKNOWN	// Generate a shortcut info to add into the model	98073
UNKNOWN	// Notify the user once if we werent able to place any duplicates	98074
UNKNOWN	// Add the new apps to the model and bind them	98075
UNKNOWN	/**     * Returns true if the intent is a valid launch intent for a shortcut.     * This is used to identify shortcuts which are different from the ones exposed by the     * applications manifest file.     *     * When DISABLE_ALL_APPS is true, shortcuts exposed via the apps manifest should never be     * duplicated or removed(unless the app is un-installed).     *     * @param launchIntent The intent that will be launched when the shortcut is clicked.     */	98076
UNKNOWN	/**     * Ensures that we have a valid, non-null name.  If the provided name is null, we will return     * the application name instead.     */	98077
UNKNOWN	// Need a version that doesnt require an instance of LauncherAppState for the wallpaper picker	98082
UNKNOWN	// Returns false on non-dogfood builds.	98083
UNKNOWN	/**     * Call from Application.onTerminate(), which is not guaranteed to ever be called.     */	98078
UNKNOWN	// If the database has ever changed, then we really need to force a reload of the	98079
UNKNOWN	// workspace on the next load	98080
UNKNOWN	// Update the icon size	98081
UNKNOWN	/**     * Updates the icons and label of all icons for the provided package name.     */	98084
UNKNOWN	/**     * When we bind the widget, we should notify the widget that the size has changed if we have not     * done so already (only really for default workspace widgets).     */	98085
UNKNOWN	/**     * Trigger an update callback to the widget to notify it that its size has changed.     */	98086
UNKNOWN	// Store the orientation in which the widget was inflated	98087
UNKNOWN	// Re-inflate is required if the orientation has changed since last inflated.	98088
UNKNOWN	// Just in case the previous long press hasnt been cleared, we make sure to start fresh	98089
UNKNOWN	// on touch down.	98090
UNKNOWN	// Consume any touch events for ourselves after longpress is triggered	98091
UNKNOWN	// Watch for longpress events at this level to make sure	98092
UNKNOWN	// users can always pick up this widget	98093
UNKNOWN	// Otherwise continue letting touch events fall through to children	98094
UNKNOWN	// If the widget does not handle touch, then cancel	98095
UNKNOWN	// long press when we release the touch	98096
UNKNOWN	// If a long press has been performed, we dont want to clear the record of that since	98097
UNKNOWN	// we still may be receiving a touch up which we want to intercept	98098
UNKNOWN	/**     * Notify the backup manager that out database is dirty.     *     * <P>This does not force an immediate backup.     *     * @param context application context     */	98099
UNKNOWN	// There is only one process accessing this preference file, but the restore	98100
UNKNOWN	// modifies the file outside the normal codepaths, so it looks like another	98101
UNKNOWN	// process.  This forces a reload of the file, in case this process persists.	98102
UNKNOWN	// No restore for old devices.	98103
UNKNOWN	// Clear dB before restore	98104
UNKNOWN	// If no favorite was migrated, clear the data and start fresh.	98105
UNKNOWN	// If the restore fails, we should do a fresh start.	98106
UNKNOWN	// Disable the migration cling	98107
UNKNOWN	// Copy the shortcuts from the old database	98108
UNKNOWN	// Set the flag to skip the folder cling	98109
UNKNOWN	// Disable the migration cling	98110
UNKNOWN	/**     * Shows the migration cling.     *     * This flow is mutually exclusive with showFirstRunCling, and only runs if this Launcher     * package was not preinstalled and there exists a db to migrate from.     */	98111
UNKNOWN	// Show the longpress cling next	98112
UNKNOWN	// Show the longpress cling next	98113
UNKNOWN	// Show the longpress cling next	98114
UNKNOWN	// This is the first cling being shown. No need to animate.	98115
UNKNOWN	// Animate	98116
UNKNOWN	/** Hides the specified Cling */	98117
UNKNOWN	// To catch cases where siblings of top-level views are made invisible, just check whether	98118
UNKNOWN	// the cling is directly set to GONE before dismissing it.	98119
UNKNOWN	/** Returns whether the clings are enabled or should be shown */	98120
UNKNOWN	// disable clings when running in a test harness	98121
UNKNOWN	// Disable clings for accessibility when explore by touch is enabled	98122
UNKNOWN	// Restricted secondary users (child mode) will potentially have very few apps	98123
UNKNOWN	// seeded when they start up for the first time. Clings wont work well with that	98124
UNKNOWN	// Dont backup apps in other profiles for now.	98146
UNKNOWN	/**     * Back up launcher data so we can restore the users state on a new device.     *     * <P>The journal is a timestamp and a list of keys that were saved as of that time.     *     * <P>Keys may come back in any order, so each key/value is one complete row of the database.     *     * @param oldState notes from the last backup     * @param data incremental key/value pairs to persist off-device     * @param newState notes for the next backup     * @throws IOException     */	98125
UNKNOWN	/**     * Restore launcher configuration from the restored data stream.     *     * <P>Keys may arrive in any order.     *     * @param data the key/value pair from the server     */	98126
UNKNOWN	//noinspection UnusedAssignment	98127
UNKNOWN	/**     * Record the restore state for the next backup.     *     * @param newState notes about the backup state after restore.     */	98128
UNKNOWN	// clear the output journal time, to force a full backup to	98129
UNKNOWN	// will catch any changes the restore process might have made	98130
UNKNOWN	/**     * Write all modified favorites to the data stream.     *     *     * @param in notes from last backup     * @param data output stream for key/value pairs     * @param out notes about this backup     * @param keys keys to mark as clean in the notes for next backup     * @throws IOException     */	98131
UNKNOWN	// read the old ID set	98132
UNKNOWN	// persist things that have changed since the last backup	98133
UNKNOWN	// Dont backup apps in other profiles for now.	98134
UNKNOWN	// these IDs must have been deleted	98135
UNKNOWN	/**     * Read a favorite from the stream.     *     * <P>Keys arrive in any order, so screens and containers may not exist yet.     *     * @param key identifier for the row     * @param buffer the serialized proto from the stream, may be larger than dataSize     * @param dataSize the size of the proto from the stream     * @param keys keys to mark as clean in the notes for next backup     */	98136
UNKNOWN	/**     * Write all modified screens to the data stream.     *     *     * @param in notes from last backup     * @param data output stream for key/value pairs     * @param out notes about this backup     * @param keys keys to mark as clean in the notes for next backup     * @throws IOException     */	98137
UNKNOWN	// read the old ID set	98138
UNKNOWN	// persist things that have changed since the last backup	98139
UNKNOWN	// these IDs must have been deleted	98140
UNKNOWN	/**     * Read a screen from the stream.     *     * <P>Keys arrive in any order, so children of this screen may already exist.     *     * @param key identifier for the row     * @param buffer the serialized proto from the stream, may be larger than dataSize     * @param dataSize the size of the proto from the stream     * @param keys keys to mark as clean in the notes for next backup     */	98141
UNKNOWN	/**     * Write all the static icon resources we need to render placeholders     * for a package that is not installed.     *     * @param in notes from last backup     * @param data output stream for key/value pairs     * @param out notes about this backup     * @param keys keys to mark as clean in the notes for next backup     * @throws IOException     */	98142
UNKNOWN	// persist icons that havent been persisted yet	98143
UNKNOWN	// try again later	98144
UNKNOWN	// read the old ID set	98145
UNKNOWN	// remember that we already backed this up previously	98147
UNKNOWN	// too many icons for this pass, request another.	98148
UNKNOWN	// these IDs must have been deleted	98149
UNKNOWN	/**     * Read an icon from the stream.     *     * <P>Keys arrive in any order, so shortcuts that use this icon may already exist.     *     * @param key identifier for the row     * @param buffer the serialized proto from the stream, may be larger than dataSize     * @param dataSize the size of the proto from the stream     * @param keys keys to mark as clean in the notes for next backup     */	98150
UNKNOWN	/**     * Write all the static widget resources we need to render placeholders     * for a package that is not installed.     *     * @param in notes from last backup     * @param data output stream for key/value pairs     * @param out notes about this backup     * @param keys keys to mark as clean in the notes for next backup     * @throws IOException     */	98151
UNKNOWN	// persist static widget info that hasnt been persisted yet	98152
UNKNOWN	// read the old ID set	98153
UNKNOWN	// remember that we already backed this up previously	98154
UNKNOWN	// too many widgets for this pass, request another.	98155
UNKNOWN	// these IDs must have been deleted	98156
UNKNOWN	/**     * Read a widget from the stream.     *     * <P>Keys arrive in any order, so widgets that use this data may already exist.     *     * @param key identifier for the row     * @param buffer the serialized proto from the stream, may be larger than dataSize     * @param dataSize the size of the proto from the stream     * @param keys keys to mark as clean in the notes for next backup     */	98157
UNKNOWN	//else {	98158
UNKNOWN	// future site of widget table mutation	98159
UNKNOWN	//}	98160
UNKNOWN	/** create a new key, with an integer ID.     *     * <P> Keys contain their own checksum instead of using     * the heavy-weight CheckedMessage wrapper.     */	98161
UNKNOWN	/** create a new key for a named object.     *     * <P> Keys contain their own checksum instead of using     * the heavy-weight CheckedMessage wrapper.     */	98162
UNKNOWN	/** keys need to be strings, serialize and encode. */	98163
UNKNOWN	/** keys need to be strings, decode and parse. */	98164
UNKNOWN	/** Compute the checksum over the important bits of a key. */	98165
UNKNOWN	/** Serialize a Favorite for persistence, including a checksum wrapper. */	98166
UNKNOWN	/** Deserialize a Favorite from persistence, after verifying checksum wrapper. */	98167
UNKNOWN	// Let LauncherModel know weve been here.	98168
UNKNOWN	/** Serialize a Screen for persistence, including a checksum wrapper. */	98169
UNKNOWN	/** Deserialize a Screen from persistence, after verifying checksum wrapper. */	98170
UNKNOWN	/** Serialize an icon Resource for persistence, including a checksum wrapper. */	98171
UNKNOWN	/** Deserialize an icon resource from persistence, after verifying checksum wrapper. */	98172
UNKNOWN	/** Serialize a widget for persistence, including a checksum wrapper. */	98173
UNKNOWN	/** Deserialize a widget from persistence, after verifying checksum wrapper. */	98174
UNKNOWN	/**     * Read the old journal from the input file.     *     * In the event of any error, just pretend we didnt have a journal,     * in that case, do a full backup.     *     * @param oldState the read-0only file descriptor pointing to the old journal     * @return a Journal protocol buffer     */	98175
UNKNOWN	// OMG what are you doing? This is crazy inefficient!	98176
UNKNOWN	// If we read a byte that is not ours, we will cause trouble: b/12491813	98177
UNKNOWN	// However, we dont know how many bytes to expect (oops).	98178
UNKNOWN	// So we have to step through *slowly*, watching for the end.	98179
UNKNOWN	// stop reading and see what there is to parse	98180
UNKNOWN	// check the buffer to see if we have a valid journal	98181
UNKNOWN	// if we are here, then we have read a valid, checksum-verified journal	98182
UNKNOWN	// if we dont have the whole journal yet, mergeFrom will throw. keep going.	98183
UNKNOWN	/**     * Write the new journal to the output file.     *     * In the event of any error, just pretend we didnt have a journal,     * in that case, do a full backup.     * @param newState the write-only file descriptor pointing to the new journal     * @param journal a Journal protocol buffer     */	98184
UNKNOWN	/** Wrap a proto in a CheckedMessage and compute the checksum. */	98185
UNKNOWN	/** Unwrap a proto message from a CheckedMessage, verifying the checksum. */	98186
UNKNOWN	// check if the launcher is in a state to support backup	98187
UNKNOWN	// launcher data has been wiped, do nothing	98188
UNKNOWN	// launcher services are unavailable, try again later	98189
UNKNOWN	// Pin to mMinY <= mCurrY <= mMaxY	98206
UNKNOWN	/**     * The amount of friction applied to flings. The default value     * is {@link ViewConfiguration#getScrollFriction}.     *     * @param friction A scalar dimension-less value representing the coefficient of     *         friction.     */	98190
UNKNOWN	// g (m/s^2)	98191
UNKNOWN	// inch/meter	98192
UNKNOWN	// pixels per inch	98193
UNKNOWN	/**     *     * Returns whether the scroller has finished scrolling.     *     * @return True if the scroller has finished scrolling, false otherwise.     */	98194
UNKNOWN	/**     * Force the finished field to a particular value.     *     * @param finished The new finished value.     */	98195
UNKNOWN	/**     * Returns how long the scroll event will take, in milliseconds.     *     * @return The duration of the scroll in milliseconds.     */	98196
UNKNOWN	/**     * Returns the current X offset in the scroll.     *     * @return The new X offset as an absolute distance from the origin.     */	98197
UNKNOWN	/**     * Returns the current Y offset in the scroll.     *     * @return The new Y offset as an absolute distance from the origin.     */	98198
UNKNOWN	/**     * Returns the current velocity.     *     * @return The original velocity less the deceleration. Result may be     * negative.     */	98199
UNKNOWN	/**     * Returns the start X offset in the scroll.     *     * @return The start X offset as an absolute distance from the origin.     */	98200
UNKNOWN	/**     * Returns the start Y offset in the scroll.     *     * @return The start Y offset as an absolute distance from the origin.     */	98201
UNKNOWN	/**     * Returns where the scroll will end. Valid only for fling scrolls.     *     * @return The final X offset as an absolute distance from the origin.     */	98202
UNKNOWN	/**     * Returns where the scroll will end. Valid only for fling scrolls.     *     * @return The final Y offset as an absolute distance from the origin.     */	98203
UNKNOWN	/**     * Call this when you want to know the new location.  If it returns true,     * the animation is not yet finished.     */	98204
UNKNOWN	// Pin to mMinX <= mCurrX <= mMaxX	98205
UNKNOWN	/**     * Start scrolling by providing a starting point and the distance to travel.     * The scroll will use the default value of 250 milliseconds for the     * duration.     *     * @param startX Starting horizontal scroll offset in pixels. Positive     *        numbers will scroll the content to the left.     * @param startY Starting vertical scroll offset in pixels. Positive numbers     *        will scroll the content up.     * @param dx Horizontal distance to travel. Positive numbers will scroll the     *        content to the left.     * @param dy Vertical distance to travel. Positive numbers will scroll the     *        content up.     */	98207
UNKNOWN	/**     * Start scrolling by providing a starting point, the distance to travel,     * and the duration of the scroll.     *     * @param startX Starting horizontal scroll offset in pixels. Positive     *        numbers will scroll the content to the left.     * @param startY Starting vertical scroll offset in pixels. Positive numbers     *        will scroll the content up.     * @param dx Horizontal distance to travel. Positive numbers will scroll the     *        content to the left.     * @param dy Vertical distance to travel. Positive numbers will scroll the     *        content up.     * @param duration Duration of the scroll in milliseconds.     */	98208
UNKNOWN	/**     * Start scrolling based on a fling gesture. The distance travelled will     * depend on the initial velocity of the fling.     *     * @param startX Starting point of the scroll (X)     * @param startY Starting point of the scroll (Y)     * @param velocityX Initial velocity of the fling (X) measured in pixels per     *        second.     * @param velocityY Initial velocity of the fling (Y) measured in pixels per     *        second     * @param minX Minimum X value. The scroller will not scroll past this     *        point.     * @param maxX Maximum X value. The scroller will not scroll past this     *        point.     * @param minY Minimum Y value. The scroller will not scroll past this     *        point.     * @param maxY Maximum Y value. The scroller will not scroll past this     *        point.     */	98209
UNKNOWN	// Continue a scroll or fling in progress	98210
UNKNOWN	// Pin to mMinX <= mFinalX <= mMaxX	98211
UNKNOWN	// Pin to mMinY <= mFinalY <= mMaxY	98212
UNKNOWN	// 1/e == exp(-1)	98213
UNKNOWN	/**     * Stops the animation. Contrary to {@link #forceFinished(boolean)},     * aborting the animating cause the scroller to move to the final x and y     * position     *     * @see #forceFinished(boolean)     */	98214
UNKNOWN	/**     * Extend the scroll animation. This allows a running animation to scroll     * further and longer, when used with {@link #setFinalX(int)} or {@link #setFinalY(int)}.     *     * @param extend Additional time to scroll in milliseconds.     * @see #setFinalX(int)     * @see #setFinalY(int)     */	98215
UNKNOWN	/**     * Returns the time elapsed since the beginning of the scrolling.     *     * @return The elapsed time in milliseconds.     */	98216
UNKNOWN	/**     * Sets the final position (X) for this scroller.     *     * @param newX The new X offset as an absolute distance from the origin.     * @see #extendDuration(int)     * @see #setFinalY(int)     */	98217
UNKNOWN	/**     * Sets the final position (Y) for this scroller.     *     * @param newY The new Y offset as an absolute distance from the origin.     * @see #extendDuration(int)     * @see #setFinalX(int)     */	98218
UNKNOWN	/**     * @hide     */	98219
UNKNOWN	/**         * The content:// style URL for a given row, identified by its id.         *         * @param id The row id.         * @param notify True to send a notification is the content changes.         *         * @return The unique content URL for the specified row.         */	98220
UNKNOWN	/**         * The content:// style URL for a given row, identified by its id.         *         * @param id The row id.         * @param notify True to send a notification is the content changes.         *         * @return The unique content URL for the specified row.         */	98221
UNKNOWN	// This is the first time we get a handle to the internal ValueAnimator	98222
UNKNOWN	// used by the ViewPropertyAnimator.	98223
UNKNOWN	// FirstFrameAnimatorHelper hooks itself up to the updates on the animator,	98224
UNKNOWN	// and then adjusts the play time to keep the first two frames jank-free	98225
UNKNOWN	/**     * Not supported and throws an exception when used.     */	98226
UNKNOWN	/**     * Not supported and throws an exception when used.     */	98227
UNKNOWN	/**     * Not supported and throws an exception when used.     */	98228
UNKNOWN	// 256K	98229
UNKNOWN	// ugh, whatever	98230
UNKNOWN	// will block	98231
UNKNOWN	// Log.v(TAG, update: pid  + pid +  pss= + info.currentPss +  uss= + info.currentUss);	98232
UNKNOWN	// catch up in case we crashed but other processes are still running	98233
UNKNOWN	// they sent us a bad intent	98234
UNKNOWN	// in rare cases the receiver races with the application to set up LauncherAppState	98235
UNKNOWN	// If the current icon pack was deleted, we reload the icons.	98236
UNKNOWN	//  DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)	98257
UNKNOWN	// In very limited cases, we support system|signature permission apps to add to the db	98237
UNKNOWN	// always notify the backup agent	98238
UNKNOWN	// This is only required one time while loading the workspace during the	98239
UNKNOWN	// upgrade path, and should never be called from anywhere else.	98240
UNKNOWN	/**     * Should we load the old db for upgrade? first run only.     */	98241
UNKNOWN	/**     * Clears all the data for a fresh start.     */	98242
UNKNOWN	/**     * Loads the default workspace based on the following priority scheme:     *   1) From a package provided by play store     *   2) From a partner configuration APK, already in the system image     *   3) The default configuration for the particular device     */	98243
UNKNOWN	// Populate favorites table with initial favorites	98244
UNKNOWN	// We dont import the old databse for tablets, as the grid size has changed.	98245
UNKNOWN	// Are you sure? (y/n)	98246
UNKNOWN	/**         * Send notification that weve deleted the {@link AppWidgetHost},         * probably as part of the initial database creation. The receiver may         * want to re-call {@link AppWidgetHost#startListening()} to ensure         * callbacks are correctly set.         */	98247
UNKNOWN	// Database was just created, so wipe any previous widgets	98248
UNKNOWN	// Try converting the old database	98249
UNKNOWN	// Try and upgrade from the Launcher2 db	98250
UNKNOWN	// If we fail, then set a flag to load the default workspace	98251
UNKNOWN	// Right now, in non-default workspace cases, we want to run the final	98252
UNKNOWN	// upgrade code (ie. to fix workspace screen indices -> ids, etc.), so	98253
UNKNOWN	// set that flag too.	98254
UNKNOWN	// Fresh and clean launcher DB.	98255
UNKNOWN	// Delete items directly on the workspace whos screen id doesnt exist	98256
UNKNOWN	//   AND container = -100	98258
UNKNOWN	// Delete items contained in folders which no longer exist (after above statement)	98259
UNKNOWN	//  DELETE FROM favorites  WHERE container <> -100 AND container <> -101 AND container	98260
UNKNOWN	//   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)	98261
UNKNOWN	// We rearrange the screens from the old launcher	98262
UNKNOWN	// 12345 -> 34512	98263
UNKNOWN	// Ignore	98264
UNKNOWN	// We already have a favorites database in the old provider	98265
UNKNOWN	// Convert widgets from this import into widgets	98266
UNKNOWN	// Update max item id	98267
UNKNOWN	// upgrade 1,2 -> 3 added appWidgetId column	98268
UNKNOWN	// Insert new column for holding appWidgetIds	98269
UNKNOWN	// Old version remains, which means we wipe old data	98270
UNKNOWN	// Convert existing widgets only if table upgrade was successful	98271
UNKNOWN	// Wheres version 5?	98272
UNKNOWN	// - Donut and sholes on 2.0 shipped with version 4 of launcher1.	98273
UNKNOWN	// - Passion shipped on 2.1 with version 6 of launcher3	98274
UNKNOWN	// - Sholes shipped on 2.1r1 (aka Mr. 3) with version 5 of launcher 1	98275
UNKNOWN	//   but version 5 on there was the updateContactsShortcuts change	98276
UNKNOWN	//   which was version 6 in launcher 2 (first shipped on passion 2.1r1).	98277
UNKNOWN	// The updateContactsShortcuts change is idempotent, so running it twice	98278
UNKNOWN	// is okay so well do that when upgrading the devices that shipped with it.	98279
UNKNOWN	// We went from 3 to 5 screens. Move everything 1 to the right	98280
UNKNOWN	// Old version remains, which means we wipe old data	98281
UNKNOWN	// We added the fast track.	98282
UNKNOWN	// Version 7 gets rid of the special search widget.	98283
UNKNOWN	// Version 8 (froyo) has the icons all normalized.  This should	98284
UNKNOWN	// already be the case in practice, but we now rely on it and dont	98285
UNKNOWN	// resample the images each time.	98286
UNKNOWN	// The max id is not yet set at this point (onUpgrade is triggered in the ctor	98287
UNKNOWN	// before it gets a change to get set, so we need to read it here when we use it)	98288
UNKNOWN	// Add default hotseat icons	98289
UNKNOWN	// We bumped the version three time during JB, once to update the launch flags, once to	98290
UNKNOWN	// update the override for the default launch animation and once to set the mimetype	98291
UNKNOWN	// to improve startup performance	98292
UNKNOWN	// Contact shortcuts need a different set of flags to be launched now	98293
UNKNOWN	// The updateContactsShortcuts change is idempotent, so we can keep using it like	98294
UNKNOWN	// back in the Donut days	98295
UNKNOWN	// With the new shrink-wrapped and re-orderable workspaces, it makes sense	98296
UNKNOWN	// to persist workspace screens and their relative order.	98297
UNKNOWN	// This will never happen in the wild, but when we switch to using workspace	98298
UNKNOWN	// screen ids, redo the import from old launcher.	98299
UNKNOWN	// Insert new column for holding widget provider name	98300
UNKNOWN	// Old version remains, which means we wipe old data	98301
UNKNOWN	// Insert new column for holding update timestamp	98302
UNKNOWN	// Old version remains, which means we wipe old data	98303
UNKNOWN	// Insert new column for holding restore status	98304
UNKNOWN	// Old version remains, which means we wipe old data	98305
UNKNOWN	// We use the db version upgrade here to identify users who may not have seen	98306
UNKNOWN	// clings yet (because they werent available), but for whom the clings are now	98307
UNKNOWN	// available (tablet users). Because one of the possible cling flows (migration)	98308
UNKNOWN	// is very destructive (wipes out workspaces), we want to prevent this from showing	98309
UNKNOWN	// until clear data. We do so by marking that the clings have been shown.	98310
UNKNOWN	// No-op	98311
UNKNOWN	// Due to a data loss bug, some users may have items associated with screen ids	98312
UNKNOWN	// which no longer exist. Since this can cause other problems, and since the user	98313
UNKNOWN	// will never see these items anyway, we use database upgrade as an opportunity to	98314
UNKNOWN	// clean things up.	98315
UNKNOWN	// Add userId column	98316
UNKNOWN	// else old version remains, which means we wipe old data	98317
UNKNOWN	// This shouldnt happen -- throw our hands up in the air and start over.	98318
UNKNOWN	/**         * Clears all the data for a fresh start.         */	98319
UNKNOWN	// Default to the serial number of this user, for older	98320
UNKNOWN	// shortcuts.	98321
UNKNOWN	// Insert new column for holding user serial number	98322
UNKNOWN	// Old version remains, which means we wipe old data	98323
UNKNOWN	// Select and iterate through each matching widget	98324
UNKNOWN	// When starting from the launcher, start in a new, cleared task	98325
UNKNOWN	// CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we	98326
UNKNOWN	// clear the whole thing preemptively here since	98327
UNKNOWN	// QuickContactActivity will finish itself when launching other	98328
UNKNOWN	// detail activities.	98329
UNKNOWN	// Determine the type and also put that in the shortcut	98330
UNKNOWN	// (that can speed up launch a bit)	98331
UNKNOWN	// Generates a new ID to use for an object in your database. This method should be only	98332
UNKNOWN	// called from the main UI thread. As an exception, we do call it when we call the	98333
UNKNOWN	// constructor from the worker thread; however, this doesnt extend until after the	98334
UNKNOWN	// constructor is called, and we only pass a reference to LauncherProvider to LauncherApp	98335
UNKNOWN	// after that point	98336
UNKNOWN	// get the result	98337
UNKNOWN	// Generates a new ID to use for an workspace screen in your database. This method	98338
UNKNOWN	// should be only called from the main UI thread. As an exception, we do call it when we	98339
UNKNOWN	// call the constructor from the worker thread; however, this doesnt extend until after the	98340
UNKNOWN	// constructor is called, and we only pass a reference to LauncherProvider to LauncherApp	98341
UNKNOWN	// after that point	98342
UNKNOWN	// Log to disk	98343
UNKNOWN	// Log to disk	98344
UNKNOWN	// get the result	98345
UNKNOWN	// Log to disk	98346
UNKNOWN	/**         * Upgrade existing clock and photo frame widgets into their new widget         * equivalents.         */	98347
UNKNOWN	// Select and iterate through each matching widget	98348
UNKNOWN	// Allocate and update database with new appWidgetId	98349
UNKNOWN	// Original widgets might not have valid spans when upgrading	98350
UNKNOWN	// TODO: check return value	98351
UNKNOWN	// TODO: check return value	98352
UNKNOWN	// TODO: check return value	98353
UNKNOWN	// Update max item id	98354
UNKNOWN	// 1. Ensure that externally added items have a valid item id	98355
UNKNOWN	// 2. In the case of an app widget, and if no app widget id is specified, we	98356
UNKNOWN	// attempt allocate and bind the widget.	98357
UNKNOWN	// Add screen id if not present	98358
UNKNOWN	// Returns true of screen id exists, or if successfully added	98359
UNKNOWN	// get the result	98360
UNKNOWN	//noinspection StatementWithEmptyBody	98361
UNKNOWN	// TODO: Use multiple loaders with fall-back and transaction.	98362
UNKNOWN	// Add the screens specified by the items above	98363
UNKNOWN	// Ensure that the max ids are initialized	98364
UNKNOWN	/**         * Loads the default set of favorite packages from an xml file.         *         * @param db The database to write the values into         * @param res The resources         * @param workspaceResourceId The specific container id of items to load         * @param screenIds The set of screenIds which are used by the favorites         */	98365
UNKNOWN	// recursively load some more favorites, why not?	98366
UNKNOWN	// Assuming its a <favorite> at this point	98367
UNKNOWN	// This looks through the contained favorites (or meta-favorites) and	98368
UNKNOWN	// attempts to add them as shortcuts in the fallback groups location	98369
UNKNOWN	// until one is added successfully.	98370
UNKNOWN	// Folder contents are nested in this XML file	98371
UNKNOWN	// Folder contents come from an external XML resource	98372
UNKNOWN	// Keep track of the set of screens which need to be added to the db.	98373
UNKNOWN	/**         * Parse folder items starting at {@link XmlPullParser} location. Allow recursive         * includes of items.         */	98374
UNKNOWN	/**         * Parse folder starting at current {@link XmlPullParser} location.         */	98375
UNKNOWN	// We can only have folders with >= 2 items, so we need to remove the	98376
UNKNOWN	// folder and clean up if less than 2 items were included, or some	98377
UNKNOWN	// failed to add, and less than 2 were actually added	98378
UNKNOWN	// Delete the folder	98379
UNKNOWN	// If we have a single item, promote it to where the folder	98380
UNKNOWN	// would have been.	98381
UNKNOWN	// A meta shortcut attempts to resolve an intent specified as a URI in the XML, if a	98382
UNKNOWN	// logical choice for what shortcut should be used for that intent exists, then it is	98383
UNKNOWN	// added. Otherwise add nothing.	98384
UNKNOWN	// Verify that the result is an app and not just the resolver dialog asking which	98385
UNKNOWN	// app to use.	98386
UNKNOWN	// If only one of the results is a system app then choose that as the default.	98387
UNKNOWN	// There is no logical choice for this meta-favorite, so rather than making	98388
UNKNOWN	// a bad choice just add nothing.	98389
UNKNOWN	// If the list contains the above resolved activity, then it cant be	98390
UNKNOWN	// ResolverActivity itself.	98391
UNKNOWN	// If no component specified try to find a shortcut to add from the URI.	98392
UNKNOWN	/**         * Gets an appwidget provider from the given package. If the package contains more than         * one appwidget provider, an arbitrary one is returned.         */	98393
UNKNOWN	// Read the extras	98394
UNKNOWN	// TODO: need to check return value	98395
UNKNOWN	// Send a broadcast to configure the widget	98396
UNKNOWN	// Oh well	98397
UNKNOWN	// Ignore	98398
UNKNOWN	// We already have a favorites database in the old provider	98399
UNKNOWN	// Default to the serial number of this user, for older	98400
UNKNOWN	// shortcuts.	98401
UNKNOWN	// bogus intent?	98402
UNKNOWN	// no intent? no icon	98403
UNKNOWN	// component no longer exists.	98404
UNKNOWN	// Dedupe icons directly on the workspace	98405
UNKNOWN	// Canonicalize	98406
UNKNOWN	// the Play Store sets the package parameter, but Launcher	98407
UNKNOWN	// does not, so we clear that out to keep them the same.	98408
UNKNOWN	// Also ignore intent flags for the purposes of deduping.	98409
UNKNOWN	// In a folder, preserve position	98410
UNKNOWN	// For items contained directly on one of the workspace screen,	98411
UNKNOWN	// well determine their location (screen, x, y) in a second pass.	98412
UNKNOWN	// Folders first	98413
UNKNOWN	// Then shortcuts	98414
UNKNOWN	// Layout all the folders	98415
UNKNOWN	// Hotseat items and folder items have already had their	98416
UNKNOWN	// location information set. Nothing to be done here.	98417
UNKNOWN	// Leave the last row of icons blank on every screen	98418
UNKNOWN	// ensure that new screens are created to hold these icons	98419
UNKNOWN	// Update max IDs; very important since we just grabbed IDs from another database	98420
UNKNOWN	/**     * Build a query string that will match any row where the column matches     * anything in the values list.     */	98421
UNKNOWN	/**     * Return attribute value, attempting launcher-specific namespace first     * before falling back to anonymous attribute.     */	98422
UNKNOWN	/**     * Return attribute resource value, attempting launcher-specific namespace     * first before falling back to anonymous attribute.     */	98423
UNKNOWN	// (that can speed up launch a bit)	98508
UNKNOWN	// Determine the type and also put that in the shortcut	98507
UNKNOWN	// The max id is not yet set at this point (onUpgrade is triggered in the ctor	98464
UNKNOWN	/**         * Send notification that weve deleted the {@link AppWidgetHost},         * probably as part of the initial database creation. The receiver may         * want to re-call {@link AppWidgetHost#startListening()} to ensure         * callbacks are correctly set.         */	98424
UNKNOWN	// Database was just created, so wipe any previous widgets	98425
UNKNOWN	// Try converting the old database	98426
UNKNOWN	// Try and upgrade from the Launcher2 db	98427
UNKNOWN	// If we fail, then set a flag to load the default workspace	98428
UNKNOWN	// Right now, in non-default workspace cases, we want to run the final	98429
UNKNOWN	// upgrade code (ie. to fix workspace screen indices -> ids, etc.), so	98430
UNKNOWN	// set that flag too.	98431
UNKNOWN	// Fresh and clean launcher DB.	98432
UNKNOWN	// Delete items directly on the workspace whos screen id doesnt exist	98433
UNKNOWN	//  DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)	98434
UNKNOWN	//   AND container = -100	98435
UNKNOWN	// Delete items contained in folders which no longer exist (after above statement)	98436
UNKNOWN	//  DELETE FROM favorites  WHERE container <> -100 AND container <> -101 AND container	98437
UNKNOWN	//   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)	98438
UNKNOWN	// We rearrange the screens from the old launcher	98439
UNKNOWN	// 12345 -> 34512	98440
UNKNOWN	// Ignore	98441
UNKNOWN	// We already have a favorites database in the old provider	98442
UNKNOWN	// Convert widgets from this import into widgets	98443
UNKNOWN	// Update max item id	98444
UNKNOWN	// upgrade 1,2 -> 3 added appWidgetId column	98445
UNKNOWN	// Insert new column for holding appWidgetIds	98446
UNKNOWN	// Old version remains, which means we wipe old data	98447
UNKNOWN	// Convert existing widgets only if table upgrade was successful	98448
UNKNOWN	// Wheres version 5?	98449
UNKNOWN	// - Donut and sholes on 2.0 shipped with version 4 of launcher1.	98450
UNKNOWN	// - Passion shipped on 2.1 with version 6 of launcher3	98451
UNKNOWN	// - Sholes shipped on 2.1r1 (aka Mr. 3) with version 5 of launcher 1	98452
UNKNOWN	//   but version 5 on there was the updateContactsShortcuts change	98453
UNKNOWN	//   which was version 6 in launcher 2 (first shipped on passion 2.1r1).	98454
UNKNOWN	// The updateContactsShortcuts change is idempotent, so running it twice	98455
UNKNOWN	// is okay so well do that when upgrading the devices that shipped with it.	98456
UNKNOWN	// We went from 3 to 5 screens. Move everything 1 to the right	98457
UNKNOWN	// Old version remains, which means we wipe old data	98458
UNKNOWN	// We added the fast track.	98459
UNKNOWN	// Version 7 gets rid of the special search widget.	98460
UNKNOWN	// Version 8 (froyo) has the icons all normalized.  This should	98461
UNKNOWN	// already be the case in practice, but we now rely on it and dont	98462
UNKNOWN	// resample the images each time.	98463
UNKNOWN	// before it gets a change to get set, so we need to read it here when we use it)	98465
UNKNOWN	// Add default hotseat icons	98466
UNKNOWN	// We bumped the version three time during JB, once to update the launch flags, once to	98467
UNKNOWN	// update the override for the default launch animation and once to set the mimetype	98468
UNKNOWN	// to improve startup performance	98469
UNKNOWN	// Contact shortcuts need a different set of flags to be launched now	98470
UNKNOWN	// The updateContactsShortcuts change is idempotent, so we can keep using it like	98471
UNKNOWN	// back in the Donut days	98472
UNKNOWN	// With the new shrink-wrapped and re-orderable workspaces, it makes sense	98473
UNKNOWN	// to persist workspace screens and their relative order.	98474
UNKNOWN	// This will never happen in the wild, but when we switch to using workspace	98475
UNKNOWN	// screen ids, redo the import from old launcher.	98476
UNKNOWN	// Insert new column for holding widget provider name	98477
UNKNOWN	// Old version remains, which means we wipe old data	98478
UNKNOWN	// Insert new column for holding update timestamp	98479
UNKNOWN	// Old version remains, which means we wipe old data	98480
UNKNOWN	// Insert new column for holding restore status	98481
UNKNOWN	// Old version remains, which means we wipe old data	98482
UNKNOWN	// We use the db version upgrade here to identify users who may not have seen	98483
UNKNOWN	// clings yet (because they werent available), but for whom the clings are now	98484
UNKNOWN	// available (tablet users). Because one of the possible cling flows (migration)	98485
UNKNOWN	// is very destructive (wipes out workspaces), we want to prevent this from showing	98486
UNKNOWN	// until clear data. We do so by marking that the clings have been shown.	98487
UNKNOWN	// No-op	98488
UNKNOWN	// Due to a data loss bug, some users may have items associated with screen ids	98489
UNKNOWN	// which no longer exist. Since this can cause other problems, and since the user	98490
UNKNOWN	// will never see these items anyway, we use database upgrade as an opportunity to	98491
UNKNOWN	// clean things up.	98492
UNKNOWN	// Add userId column	98493
UNKNOWN	// else old version remains, which means we wipe old data	98494
UNKNOWN	// This shouldnt happen -- throw our hands up in the air and start over.	98495
UNKNOWN	/**         * Clears all the data for a fresh start.         */	98496
UNKNOWN	// Default to the serial number of this user, for older	98497
UNKNOWN	// shortcuts.	98498
UNKNOWN	// Insert new column for holding user serial number	98499
UNKNOWN	// Old version remains, which means we wipe old data	98500
UNKNOWN	// Select and iterate through each matching widget	98501
UNKNOWN	// When starting from the launcher, start in a new, cleared task	98502
UNKNOWN	// CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we	98503
UNKNOWN	// clear the whole thing preemptively here since	98504
UNKNOWN	// QuickContactActivity will finish itself when launching other	98505
UNKNOWN	// detail activities.	98506
UNKNOWN	// Generates a new ID to use for an object in your database. This method should be only	98509
UNKNOWN	// called from the main UI thread. As an exception, we do call it when we call the	98510
UNKNOWN	// constructor from the worker thread; however, this doesnt extend until after the	98511
UNKNOWN	// constructor is called, and we only pass a reference to LauncherProvider to LauncherApp	98512
UNKNOWN	// after that point	98513
UNKNOWN	// get the result	98514
UNKNOWN	// Generates a new ID to use for an workspace screen in your database. This method	98515
UNKNOWN	// should be only called from the main UI thread. As an exception, we do call it when we	98516
UNKNOWN	// call the constructor from the worker thread; however, this doesnt extend until after the	98517
UNKNOWN	// constructor is called, and we only pass a reference to LauncherProvider to LauncherApp	98518
UNKNOWN	// after that point	98519
UNKNOWN	// Log to disk	98520
UNKNOWN	// Log to disk	98521
UNKNOWN	// get the result	98522
UNKNOWN	// Log to disk	98523
UNKNOWN	/**         * Upgrade existing clock and photo frame widgets into their new widget         * equivalents.         */	98524
UNKNOWN	// Select and iterate through each matching widget	98525
UNKNOWN	// Allocate and update database with new appWidgetId	98526
UNKNOWN	// Original widgets might not have valid spans when upgrading	98527
UNKNOWN	// TODO: check return value	98528
UNKNOWN	// TODO: check return value	98529
UNKNOWN	// TODO: check return value	98530
UNKNOWN	// Update max item id	98531
UNKNOWN	// 1. Ensure that externally added items have a valid item id	98532
UNKNOWN	// 2. In the case of an app widget, and if no app widget id is specified, we	98533
UNKNOWN	// attempt allocate and bind the widget.	98534
UNKNOWN	// Add screen id if not present	98535
UNKNOWN	// Returns true of screen id exists, or if successfully added	98536
UNKNOWN	// get the result	98537
UNKNOWN	//noinspection StatementWithEmptyBody	98538
UNKNOWN	// TODO: Use multiple loaders with fall-back and transaction.	98539
UNKNOWN	// Add the screens specified by the items above	98540
UNKNOWN	// Ensure that the max ids are initialized	98541
UNKNOWN	/**         * Loads the default set of favorite packages from an xml file.         *         * @param db The database to write the values into         * @param res The resources         * @param workspaceResourceId The specific container id of items to load         * @param screenIds The set of screenIds which are used by the favorites         */	98542
UNKNOWN	// recursively load some more favorites, why not?	98543
UNKNOWN	// Assuming its a <favorite> at this point	98544
UNKNOWN	// This looks through the contained favorites (or meta-favorites) and	98545
UNKNOWN	// attempts to add them as shortcuts in the fallback groups location	98546
UNKNOWN	// until one is added successfully.	98547
UNKNOWN	// Folder contents are nested in this XML file	98548
UNKNOWN	// Folder contents come from an external XML resource	98549
UNKNOWN	// Keep track of the set of screens which need to be added to the db.	98550
UNKNOWN	/**         * Parse folder items starting at {@link XmlPullParser} location. Allow recursive         * includes of items.         */	98551
UNKNOWN	/**         * Parse folder starting at current {@link XmlPullParser} location.         */	98552
UNKNOWN	// We can only have folders with >= 2 items, so we need to remove the	98553
UNKNOWN	// folder and clean up if less than 2 items were included, or some	98554
UNKNOWN	// failed to add, and less than 2 were actually added	98555
UNKNOWN	// Delete the folder	98556
UNKNOWN	// If we have a single item, promote it to where the folder	98557
UNKNOWN	// would have been.	98558
UNKNOWN	// A meta shortcut attempts to resolve an intent specified as a URI in the XML, if a	98559
UNKNOWN	// logical choice for what shortcut should be used for that intent exists, then it is	98560
UNKNOWN	// added. Otherwise add nothing.	98561
UNKNOWN	// Verify that the result is an app and not just the resolver dialog asking which	98562
UNKNOWN	// app to use.	98563
UNKNOWN	// If only one of the results is a system app then choose that as the default.	98564
UNKNOWN	// There is no logical choice for this meta-favorite, so rather than making	98565
UNKNOWN	// a bad choice just add nothing.	98566
UNKNOWN	// If the list contains the above resolved activity, then it cant be	98567
UNKNOWN	// ResolverActivity itself.	98568
UNKNOWN	// If no component specified try to find a shortcut to add from the URI.	98569
UNKNOWN	/**         * Gets an appwidget provider from the given package. If the package contains more than         * one appwidget provider, an arbitrary one is returned.         */	98570
UNKNOWN	// Read the extras	98571
UNKNOWN	// TODO: need to check return value	98572
UNKNOWN	// Send a broadcast to configure the widget	98573
UNKNOWN	// Oh well	98574
UNKNOWN	// Ignore	98575
UNKNOWN	// We already have a favorites database in the old provider	98576
UNKNOWN	// Default to the serial number of this user, for older	98577
UNKNOWN	// shortcuts.	98578
UNKNOWN	// bogus intent?	98579
UNKNOWN	// no intent? no icon	98580
UNKNOWN	// component no longer exists.	98581
UNKNOWN	// Dedupe icons directly on the workspace	98582
UNKNOWN	// Canonicalize	98583
UNKNOWN	// the Play Store sets the package parameter, but Launcher	98584
UNKNOWN	// does not, so we clear that out to keep them the same.	98585
UNKNOWN	// Also ignore intent flags for the purposes of deduping.	98586
UNKNOWN	// In a folder, preserve position	98587
UNKNOWN	// For items contained directly on one of the workspace screen,	98588
UNKNOWN	// well determine their location (screen, x, y) in a second pass.	98589
UNKNOWN	// Folders first	98590
UNKNOWN	// Then shortcuts	98591
UNKNOWN	// Layout all the folders	98592
UNKNOWN	// Hotseat items and folder items have already had their	98593
UNKNOWN	// location information set. Nothing to be done here.	98594
UNKNOWN	// Leave the last row of icons blank on every screen	98595
UNKNOWN	// ensure that new screens are created to hold these icons	98596
UNKNOWN	// Update max IDs; very important since we just grabbed IDs from another database	98597
UNKNOWN	// Remove all the previous children that are no longer in the window	98598
UNKNOWN	// Add all the new children that belong in the window	98599
UNKNOWN	// Update the markers alpha	98600
UNKNOWN	// Center the active marker	98601
UNKNOWN	// Cancel long press for all children	98602
UNKNOWN	// Generate an id for each view, this assumes we have at most 256x256 cells	98603
UNKNOWN	// per workspace screen	98604
UNKNOWN	// If the horizontal or vertical span is set to -1, it is taken to	98605
UNKNOWN	// mean that it spans the extent of the CellLayout	98606
UNKNOWN	/**     * Clears all the key listeners for the individual icons.     */	98607
UNKNOWN	// Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY	98608
UNKNOWN	// We only intercept the touch if we are tapping in empty space after the final row	98609
UNKNOWN	// Add a little bit of buffer if there is room for another row	98610
UNKNOWN	// Always assume were working with the smallest span to make sure we	98611
UNKNOWN	// reserve enough space in both orientations	98612
UNKNOWN	// Always round up to next largest cell	98613
UNKNOWN	/**     * Start dragging the specified child     *     * @param child The child that is being dragged     */	98614
UNKNOWN	/**     * Estimates the number of cells that the specified width would take up.     */	98615
UNKNOWN	// We dont show the next/previous pages any more, so we use the full width, minus the	98616
UNKNOWN	// padding	98617
UNKNOWN	// We know that we have to fit N cells with N-1 width gaps, so we just juggle to solve for N	98618
UNKNOWN	// We dont do anything fancy to determine if we squeeze another row in.	98619
UNKNOWN	/**     * Estimates the number of cells that the specified height would take up.     */	98620
UNKNOWN	// The space for a page is the height - top padding (current page) - bottom padding (current	98621
UNKNOWN	// page)	98622
UNKNOWN	// We know that we have to fit N cells with N-1 height gaps, so we juggle to solve for N	98623
UNKNOWN	// We dont do anything fancy to determine if we squeeze another row in.	98624
UNKNOWN	/** Returns an estimated center position of the cell at the specified index */	98625
UNKNOWN	/**     * Estimates the width that the number of hSpan cells will take up.     */	98626
UNKNOWN	// TODO: we need to take widthGap into effect	98627
UNKNOWN	/**     * Estimates the height that the number of vSpan cells will take up.     */	98628
UNKNOWN	// TODO: we need to take heightGap into effect	98629
UNKNOWN	// Update the drawing caches	98632
UNKNOWN	// Cancel long press for all children	98630
UNKNOWN	// determine the max width of all the rows and center accordingly	98631
UNKNOWN	/**     * Clears all the key listeners for the individual widgets.     */	98633
UNKNOWN	// We only intercept the touch if we are tapping in empty space after the final row	98634
UNKNOWN	// Ensure we are using the right text size	98635
UNKNOWN	// center horizontally	98636
UNKNOWN	/**     * Remove the longpress detection timer.     */	98637
UNKNOWN	// We eat up the touch events here, since the PagedView (which uses the same swiping	98638
UNKNOWN	// touch code as Workspace previously) uses onInterceptTouchEvent() to determine when	98639
UNKNOWN	// the user is scrolling between pages.  This means that if the pages themselves dont	98640
UNKNOWN	// handle touch events, it gets forwarded up to PagedView itself, and its own	98641
UNKNOWN	// onTouchEvent() handling will prevent further intercept touch events from being called	98642
UNKNOWN	// (its the same view in that case).  This is not ideal, but to prevent more changes,	98643
UNKNOWN	// we just always mark the touch event as handled.	98644
UNKNOWN	// wait no longer than 1sec at a time	98788
UNKNOWN	// Ignore	98789
UNKNOWN	// Fail if we dont have any apps	98921
UNKNOWN	// Sort the applications by name	98922
UNKNOWN	// Create the ApplicationInfos	98923
UNKNOWN	// This builds the icon bitmaps.	98924
UNKNOWN	// Check if any workspace icons overlap with each other	98826
UNKNOWN	/** Clears all the sBg data structures */	98827
UNKNOWN	/** Runs the specified runnable immediately if called from the main thread, otherwise it is     * posted on the main thread handler. */	98645
UNKNOWN	// If we are on the worker thread, post onto the main handler	98646
UNKNOWN	/** Runs the specified runnable immediately if called from the worker thread, otherwise it is     * posted on the worker thread handler. */	98647
UNKNOWN	// If we are not on the worker thread, then post to the worker handler	98648
UNKNOWN	// Lock on the app so that we dont try and get the items while apps are being added	98649
UNKNOWN	// Flush the LauncherModel worker thread, so that if we just did another	98650
UNKNOWN	// processInstallShortcut, we give it time for its shortcut to get added to the	98651
UNKNOWN	// database (getItemsInLocalCoordinates reads the database)	98652
UNKNOWN	// Try adding to the workspace screens incrementally, starting at the default or center	98653
UNKNOWN	// screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))	98654
UNKNOWN	// Update the Launcher db	98655
UNKNOWN	// Process the updated package state	98656
UNKNOWN	// Process the updated package badge	98657
UNKNOWN	// Process the newly added applications and add them to the database first	98658
UNKNOWN	// Process the newly added applications and add them to the database first	98659
UNKNOWN	// Get the list of workspace screens.  We need to append to this list and	98660
UNKNOWN	// can not use sBgWorkspaceScreens because loadWorkspace() may not have been	98661
UNKNOWN	// called.	98662
UNKNOWN	// Short-circuit this logic if the icon exists somewhere on the workspace	98663
UNKNOWN	// Only InstallShortcutReceiver sends us shortcutInfos, ignore them	98664
UNKNOWN	// Add this icon to the db, creating a new page if necessary.  If there	98665
UNKNOWN	// is only the empty page then we just add items to the first page.	98666
UNKNOWN	// Otherwise, we add them to the next pages.	98667
UNKNOWN	// If we cant find a valid position, then just add a new screen.	98668
UNKNOWN	// This takes time so we need to re-queue the add until the new	98669
UNKNOWN	// page is added.  Create as many screens as necessary to satisfy	98670
UNKNOWN	// the startSearchPageIndex.	98671
UNKNOWN	// Save the screen id for binding in the workspace	98672
UNKNOWN	// Find the coordinate again	98673
UNKNOWN	// Add the shortcut to the db	98674
UNKNOWN	// Save the ShortcutInfo for binding in the workspace	98675
UNKNOWN	// Update the workspace screens	98676
UNKNOWN	// Get the list of workspace screens.  We need to append to this list and	98677
UNKNOWN	// can not use sBgWorkspaceScreens because loadWorkspace() may not have been	98678
UNKNOWN	// called.	98679
UNKNOWN	// Short-circuit this logic if the icon exists somewhere on the workspace	98680
UNKNOWN	// Only InstallShortcutReceiver sends us shortcutInfos, ignore them	98681
UNKNOWN	// Add this icon to the db, creating a new page if necessary.  If there	98682
UNKNOWN	// is only the empty page then we just add items to the first page.	98683
UNKNOWN	// Otherwise, we add them to the next pages.	98684
UNKNOWN	// If we cant find a valid position, then just add a new screen.	98685
UNKNOWN	// This takes time so we need to re-queue the add until the new	98686
UNKNOWN	// page is added.  Create as many screens as necessary to satisfy	98687
UNKNOWN	// the startSearchPageIndex.	98688
UNKNOWN	// Save the screen id for binding in the workspace	98689
UNKNOWN	// Find the coordinate again	98690
UNKNOWN	// Add the shortcut to the db	98691
UNKNOWN	// Save the ShortcutInfo for binding in the workspace	98692
UNKNOWN	// Update the workspace screens	98693
UNKNOWN	// Clear any deferred bind runnables	98694
UNKNOWN	// Remove any queued bind runnables	98695
UNKNOWN	// Unbind all the workspace items	98696
UNKNOWN	/** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */	98697
UNKNOWN	// Ensure that we dont use the same workspace items data structure on the main thread	98698
UNKNOWN	// by making a copy of workspace items first.	98699
UNKNOWN	/**     * Adds an item to the DB if it was not created previously, or move it to a new     * <container, screen, cellX, cellY>     */	98700
UNKNOWN	// From all apps	98701
UNKNOWN	// From somewhere else	98702
UNKNOWN	// check all the data is consistent	98703
UNKNOWN	// For all intents and purposes, this is the same object	98704
UNKNOWN	// the modelItem needs to match up perfectly with item if our model is	98705
UNKNOWN	// to be consistent with the database-- for now, just require	98706
UNKNOWN	// modelItem == item or the equality check above	98707
UNKNOWN	// Lock on mBgLock *after* the db operation	98708
UNKNOWN	// Item is in a folder, make sure this folder exists	98709
UNKNOWN	// An items container is being set to a that of an item which is not in	98710
UNKNOWN	// the list of Folders.	98711
UNKNOWN	// Query for the set of apps	98920
UNKNOWN	// Items are added/removed from the corresponding FolderInfo elsewhere, such	98712
UNKNOWN	// as in Workspace.onDrop. Here, we just add/remove them from the list of items	98713
UNKNOWN	// that are on the desktop, as appropriate	98714
UNKNOWN	/**     * Move an item in the DB to a new <container, screen, cellX, cellY>     */	98715
UNKNOWN	/**     * Move items in the DB to a new <container, screen, cellX, cellY>. We assume that the     * cellX, cellY have already been updated on the ItemInfos.     */	98716
UNKNOWN	/**     * Move and/or resize item in the DB to a new <container, screen, cellX, cellY, spanX, spanY>     */	98717
UNKNOWN	/**     * Update an item to the database in a specified container.     */	98718
UNKNOWN	/**     * Returns true if the shortcuts already exists in the database.     * we identify a shortcut by its title and intent.     */	98719
UNKNOWN	// If component is not null, an intent with null package will produce	98720
UNKNOWN	// the same result and should also be a match.	98721
UNKNOWN	/**     * Returns true if the promise shortcuts with the same package name exists on the workspace.     */	98722
UNKNOWN	/**     * Returns an ItemInfo array containing all the items in the LauncherModel.     * The ItemInfo.id is not set through this function.     */	98723
UNKNOWN	// Skip if user has been deleted.	98724
UNKNOWN	/**     * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.     */	98725
UNKNOWN	/**     * Add an item to the database in a specified container. Sets the container, screen, cellX and     * cellY fields of the item. Also assigns an ID to the item.     */	98726
UNKNOWN	// Lock on mBgLock *after* the db operation	98727
UNKNOWN	// Fall through	98728
UNKNOWN	// Adding an item to a folder that doesnt exist.	98729
UNKNOWN	// Lock on mBgLock *after* the db operation	98730
UNKNOWN	// Fall through	98731
UNKNOWN	// Adding an item to a folder that doesnt exist.	98732
UNKNOWN	/**     * Creates a new unique child id, for a given cell span across all layouts.     */	98733
UNKNOWN	/**     * Removes all the items from the database corresponding to the specified package.     */	98734
UNKNOWN	/**     * Removes the specified item from the database     * @param context     * @param item     */	98735
UNKNOWN	/**     * Removes the specified items from the database     * @param context     * @param item     */	98736
UNKNOWN	// Lock on mBgLock *after* the db operation	98737
UNKNOWN	// We are deleting a folder which still contains items that	98738
UNKNOWN	// think they are contained by that folder.	98739
UNKNOWN	// Lock on mBgLock *after* the db operation	98740
UNKNOWN	// We are deleting a folder which still contains items that	98741
UNKNOWN	// think they are contained by that folder.	98742
UNKNOWN	/**     * Update the order of the workspace screens in the database. The array list contains     * a list of screen ids in the order that they should appear.     */	98743
UNKNOWN	// Log to disk	98744
UNKNOWN	// Remove any negative screen ids -- these arent persisted	98745
UNKNOWN	// Clear the table	98746
UNKNOWN	// Clear the table	98747
UNKNOWN	/**     * Remove the contents of the specified folder from the database     */	98748
UNKNOWN	// Lock on mBgLock *after* the db operation	98749
UNKNOWN	// Lock on mBgLock *after* the db operation	98750
UNKNOWN	// Lock on mBgLock *after* the db operation	98751
UNKNOWN	// Lock on mBgLock *after* the db operation	98752
UNKNOWN	/**     * Set this as the current Launcher activity object for the loader.     */	98753
UNKNOWN	// Only rebind if we support removable storage. It catches the	98754
UNKNOWN	// case where	98755
UNKNOWN	// apps on the external sd card need to be reloaded	98756
UNKNOWN	// If we are replacing then just update the packages in the list	98757
UNKNOWN	/**     * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and     * ACTION_PACKAGE_CHANGED.     */	98758
UNKNOWN	// If we have changed locale we need to clear out the labels in all apps/workspace.	98759
UNKNOWN	// Check if configuration change was an mcc/mnc change which would affect app resources	98760
UNKNOWN	// and we would need to clear out the labels in all apps/workspace. Same handling as	98761
UNKNOWN	// above for ACTION_LOCALE_CHANGED	98762
UNKNOWN	// Update previousConfig	98763
UNKNOWN	// Do this here because if the launcher activity is running it will be restarted.	98764
UNKNOWN	// If its not running startLoaderFromBackground will merely tell it that it needs	98765
UNKNOWN	// to reload.	98766
UNKNOWN	// Stop any existing loaders first, so they dont set mAllAppsLoaded or	98767
UNKNOWN	// mWorkspaceLoaded to true later	98768
UNKNOWN	/**     * When the launcher is in the background, its possible for it to miss paired     * configuration changes.  So whenever we trigger the loader from the background     * tell the launcher that it needs to re-run the loader when it comes back instead     * of doing it now.     */	98769
UNKNOWN	// Only actually run the loader if theyre not paused.	98770
UNKNOWN	// If there is already a loader task running, tell it to stop.	98771
UNKNOWN	// returns true if isLaunching() was true on the old task	98772
UNKNOWN	// Clear any deferred bind-runnables from the synchronized load process	98773
UNKNOWN	// We must do this before any loading/binding is scheduled below.	98774
UNKNOWN	// Dont bother to start the thread if we know its not going to do anything	98775
UNKNOWN	// If there is already one running, tell it to stop.	98776
UNKNOWN	// also, dont downgrade isLaunching if were already running	98777
UNKNOWN	// Post the remaining side pages to be loaded	98778
UNKNOWN	/** Loads the workspace screens db into a map of Rank -> ScreenId */	98779
UNKNOWN	// Log to disk	98780
UNKNOWN	/** Returns whether this is an upgrade path */	98781
UNKNOWN	// Load the workspace	98782
UNKNOWN	// Bind the workspace	98783
UNKNOWN	// Wait until the either were stopped or the other threads are done.	98784
UNKNOWN	// This way we dont start loading all apps until the workspace has settled	98785
UNKNOWN	// down.	98786
UNKNOWN	// Just in case mFlushingWorkerThread changes but we arent woken up,	98787
UNKNOWN	// Ensure that we have a valid page index to load synchronously	98790
UNKNOWN	// Ensure that we dont try and bind a specified page when the pages have not been	98791
UNKNOWN	// loaded already (we should load everything asynchronously in that case)	98792
UNKNOWN	// Ensure that we are never running the background loading at this point since	98793
UNKNOWN	// we also touch the background collections	98794
UNKNOWN	// XXX: Throw an exception if we are already loading (since we touch the worker thread	98795
UNKNOWN	//      data structures, we cant allow any other thread to touch that data, but because	98796
UNKNOWN	//      this call is synchronous, we can get away with not locking).	98797
UNKNOWN	// The LauncherModel is static in the LauncherAppState and mHandler may have queued	98798
UNKNOWN	// operations from the previous activity.  We need to ensure that all queued operations	98799
UNKNOWN	// are executed before any synchronous binding work is done.	98800
UNKNOWN	// Divide the set of loaded items into those that we are binding synchronously, and	98801
UNKNOWN	// everything else that is to be bound normally (asynchronously).	98802
UNKNOWN	// XXX: For now, continue posting the binding of AllApps as there are other issues that	98803
UNKNOWN	//      arise from that.	98804
UNKNOWN	// Optimize for end-user experience: if the Launcher is up and // running with the	98805
UNKNOWN	// All Apps interface in the foreground, load All Apps first. Otherwise, load the	98806
UNKNOWN	// workspace first (default).	98807
UNKNOWN	// Elevate priority when Home launches for the first time to avoid	98808
UNKNOWN	// starving at boot time. Staring at a blank home is not cool.	98809
UNKNOWN	// Whew! Hard work done.  Slow us down, and wait until the UI thread has	98810
UNKNOWN	// settled down.	98811
UNKNOWN	// second step	98812
UNKNOWN	// Restore the default thread priority after we are done loading items	98813
UNKNOWN	// Update the saved icons if necessary	98814
UNKNOWN	// Ensure that all the applications that are in the system are	98815
UNKNOWN	// represented on the home screen.	98816
UNKNOWN	// Clear out this reference, otherwise we end up holding it until all of the	98817
UNKNOWN	// callback runnables are done.	98818
UNKNOWN	// If we are still the last one to be scheduled, remove ourselves.	98819
UNKNOWN	/**         * Gets the callbacks object.  If weve been stopped, or if the launcher object         * has somehow been garbage collected, return null instead.  Pass in the Callbacks         * object that was around when the deferred message was scheduled, and if theres         * a new Callbacks object around then also return null.  This will save us from         * calling onto it with data that will be ignored.         */	98820
UNKNOWN	// Cross reference all the applications in our apps list with items in the workspace	98821
UNKNOWN	// We are missing an application icon, so add this to the workspace	98822
UNKNOWN	// This is a rare event, so lets log it	98823
UNKNOWN	// check & update map of whats occupied; used to discard overlapping/invalid items	98824
UNKNOWN	// Skip further checking if it is not the hotseat or workspace container	98825
UNKNOWN	/** Returns whether this is an upgrade path */	98828
UNKNOWN	// Log to disk	98829
UNKNOWN	// append the users Launcher2 shortcuts	98830
UNKNOWN	// Make sure the default workspace is loaded	98831
UNKNOWN	// This code path is for our old migration code and should no longer be exercised	98832
UNKNOWN	// Log to disk	98833
UNKNOWN	// +1 for the hotseat (it can be larger than the workspace)	98834
UNKNOWN	// Load workspace in reverse order to ensure that latest items are loaded first (and	98835
UNKNOWN	// before any earlier duplicates)	98836
UNKNOWN	//final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);	98837
UNKNOWN	//final int displayModeIndex = c.getColumnIndexOrThrow(	98838
UNKNOWN	//        LauncherSettings.Favorites.DISPLAY_MODE);	98839
UNKNOWN	// User has been deleted remove the item.	98840
UNKNOWN	// no special handling necessary for this item	98841
UNKNOWN	// We allow auto install apps to have their intent	98842
UNKNOWN	// updated after an install.	98843
UNKNOWN	// The app is installed but the component is no	98844
UNKNOWN	// longer available.	98845
UNKNOWN	// no special handling necessary for this item	98846
UNKNOWN	// Package is not yet available but might be	98847
UNKNOWN	// installed later.	98848
UNKNOWN	// Restore has started once.	98849
UNKNOWN	// App restore has started. Update the flag	98850
UNKNOWN	// Do not wait for external media load anymore.	98851
UNKNOWN	// Log the invalid package, and remove it	98852
UNKNOWN	// SdCard is not ready yet. Package might get available,	98853
UNKNOWN	// once it is ready.	98854
UNKNOWN	// Add the icon on the workspace anyway.	98855
UNKNOWN	// For shortcuts with no component, keep them as they are	98856
UNKNOWN	// Dont restore items for other profiles.	98857
UNKNOWN	// App shortcuts that used to be automatically added to Launcher	98858
UNKNOWN	// didnt always have the correct intent flags set, so do that	98859
UNKNOWN	// here	98860
UNKNOWN	// check & update map of whats occupied	98861
UNKNOWN	// Item is in a user folder	98862
UNKNOWN	// now that weve loaded everthing re-save it with the	98863
UNKNOWN	// icon in case it disappears somehow.	98864
UNKNOWN	// check & update map of whats occupied	98865
UNKNOWN	// no special handling required for restored folders	98866
UNKNOWN	// Read all Launcher-specific widget details	98867
UNKNOWN	// If provider was not previously ready, update the	98868
UNKNOWN	// status and UI flag.	98869
UNKNOWN	// Id would be valid only if the widget restore broadcast was received.	98870
UNKNOWN	// Restore has started once.	98871
UNKNOWN	// App restore has started. Update the flag	98872
UNKNOWN	// check & update map of whats occupied	98873
UNKNOWN	// Break early if weve stopped loading	98874
UNKNOWN	// Remove dead items	98875
UNKNOWN	// Dont notify content observers	98876
UNKNOWN	// Update restored items that no longer require special handling	98877
UNKNOWN	// If were importing we use the old screen order.	98878
UNKNOWN	// Log to disk	98879
UNKNOWN	// Update the max item id after we load an old db	98880
UNKNOWN	// If were importing we use the old screen order.	98881
UNKNOWN	// Log to disk	98882
UNKNOWN	// Remove any empty screens	98883
UNKNOWN	// If there are any empty screens remove them, and update.	98884
UNKNOWN	// Log to disk	98885
UNKNOWN	/** Filters the set of items who are directly or indirectly (via another container) on the         * specified screen. */	98886
UNKNOWN	// Purge any null ItemInfos	98887
UNKNOWN	// Order the set of items by their containers first, this allows use to walk through the	98888
UNKNOWN	// list sequentially, build up a list of containers that are in the specified screen,	98889
UNKNOWN	// as well as all items in those containers.	98890
UNKNOWN	/** Filters the set of widgets which are on the specified screen. */	98891
UNKNOWN	/** Filters the set of folders which are on the specified screen. */	98892
UNKNOWN	/** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to         * right) */	98893
UNKNOWN	// XXX: review this	98894
UNKNOWN	// +1 hotseat	98895
UNKNOWN	// +1 hotseat	98896
UNKNOWN	// Bind the workspace items	98897
UNKNOWN	// Bind the folders	98898
UNKNOWN	// Bind the widgets, one at a time	98899
UNKNOWN	/**         * Binds all loaded data to actual views on the main thread.         */	98900
UNKNOWN	// Dont use these two variables in any of the callback runnables.	98901
UNKNOWN	// Otherwise we hold a reference to them.	98902
UNKNOWN	// This launcher has exited and nobody bothered to tell us.  Just bail.	98903
UNKNOWN	// Save a copy of all the bg-thread collections	98904
UNKNOWN	// There may be no workspace screens (just hotseat items and an empty page).	98905
UNKNOWN	// Load all the items that are on the current page first (and in the process, unbind	98906
UNKNOWN	// all the existing workspace items before we call startBinding() below.	98907
UNKNOWN	// Separate the items that are on the current screen, and all the other remaining items	98908
UNKNOWN	// Tell the workspace that were about to start binding items	98909
UNKNOWN	// Load items on the current page	98910
UNKNOWN	// Load all the remaining pages (if we are loading synchronously, we want to defer this	98911
UNKNOWN	// work until after the first render)	98912
UNKNOWN	// Tell the workspace that were done binding items	98913
UNKNOWN	// If were profiling, ensure this is the last thing in the queue.	98914
UNKNOWN	// If were profiling, ensure this is the last thing in the queue.	98915
UNKNOWN	// This launcher has exited and nobody bothered to tell us.  Just bail.	98916
UNKNOWN	// shallow copy	98917
UNKNOWN	// This launcher has exited and nobody bothered to tell us.  Just bail.	98918
UNKNOWN	// Clear the list of apps	98919
UNKNOWN	// Huh? Shouldnt this be inside the Runnable below?	98925
UNKNOWN	// Post callback on main thread	98926
UNKNOWN	/**     * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD     * runnable was missed by the launcher.     */	98927
UNKNOWN	// Ensure that we add all the workspace applications to the db	98928
UNKNOWN	// Update the launcher db to reflect the changes	98929
UNKNOWN	// Mark all packages in the broadcast to be removed	98930
UNKNOWN	// Mark disabled packages in the broadcast to be removed	98931
UNKNOWN	// Remove all the components associated with this package	98932
UNKNOWN	// Remove all the specific components	98933
UNKNOWN	// Remove any queued items from the install queue	98934
UNKNOWN	// Call the components-removed callback	98935
UNKNOWN	// Write all the logs to disk	98936
UNKNOWN	// update the new data	98937
UNKNOWN	// Returns a list of ResolveInfos/AppWindowInfos in sorted order	98938
UNKNOWN	/**     * Make an ShortcutInfo object for a restored application or shortcut item that points     * to a package that is not yet installed on the system.     */	98939
UNKNOWN	/**     * Make an Intent object for a restored application or shortcut item that points     * to the market page for the item.     */	98940
UNKNOWN	/**     * This is called from the code that adds shortcuts from the intent receiver.  This     * doesnt have a Cursor, but     */	98941
UNKNOWN	/**     * Make an ShortcutInfo object for a shortcut that is an application.     *     * If c is not null, then it will be used to fill in missing data like the title and icon.     */	98942
UNKNOWN	// the resource -- This may implicitly give us back the fallback icon,	98943
UNKNOWN	// but dont worry about that.  All were doing with usingFallbackIcon is	98944
UNKNOWN	// to avoid saving lots of copies of that in the database, and most apps	98945
UNKNOWN	// have icons anyway.	98946
UNKNOWN	// the db	98947
UNKNOWN	// the fallback icon	98948
UNKNOWN	// From the cache.	98949
UNKNOWN	// from the resource	98950
UNKNOWN	// from the db	98951
UNKNOWN	// fall back to the class name of the activity	98952
UNKNOWN	// We need to check for ACTION_MAIN otherwise getComponent() might	98953
UNKNOWN	// return null for some shortcuts (for instance, for shortcuts to	98954
UNKNOWN	// web pages.)	98955
UNKNOWN	// placeholder shortcuts get special treatment, let them through too.	98956
UNKNOWN	/**     * Make an ShortcutInfo object for a shortcut that isnt an application.     */	98957
UNKNOWN	// Non-app shortcuts are only supported for current user.	98958
UNKNOWN	// TODO: If theres an explicit component and we cant install that, delete it.	98959
UNKNOWN	// the resource	98960
UNKNOWN	// drop this.  we have other places to look for icons	98961
UNKNOWN	// the db	98962
UNKNOWN	// the fallback icon	98963
UNKNOWN	// suppress dead code warning	98964
UNKNOWN	/**     * Attempts to find an AppWidgetProviderInfo that matches the given component.     */	98965
UNKNOWN	// If the intent is null, we cant construct a valid ShortcutInfo, so we return null	98966
UNKNOWN	// Only support intents for current user for now. Intents sent from other	98967
UNKNOWN	// users wouldnt get here without intent forwarding anyway.	98968
UNKNOWN	// If apps cant be on SD, dont even bother.	98969
UNKNOWN	// If this icon doesnt have a custom icon, check to see	98970
UNKNOWN	// whats stored in the DB, and if it doesnt match what	98971
UNKNOWN	// were going to show, store what we are going to show back	98972
UNKNOWN	// into the DB.  We do this so when were loading, if the	98973
UNKNOWN	// package manager cant find an icon (for example because	98974
UNKNOWN	// the app is on SD) then we can use that instead.	98975
UNKNOWN	// This is slower than is ideal, but this only happens once	98976
UNKNOWN	// or when the app is updated with a new icon.	98977
UNKNOWN	/**     * Return an existing FolderInfo object if we have encountered this ID previously,     * or make a new one.     */	98978
UNKNOWN	// See if a placeholder was created for us already	98979
UNKNOWN	// No placeholder -- create a new instance	98980
UNKNOWN	// TODO Need to figure out rules for sorting	98981
UNKNOWN	// profiles, this puts work second.	98982
UNKNOWN	// TODO Need to figure out rules for sorting	98983
UNKNOWN	// profiles, this puts work second.	98984
UNKNOWN	/** Returns whether this is an upgrade path */	98985
UNKNOWN	// Load the workspace	98986
UNKNOWN	// Bind the workspace	98987
UNKNOWN	// Wait until the either were stopped or the other threads are done.	98988
UNKNOWN	// This way we dont start loading all apps until the workspace has settled	98989
UNKNOWN	// down.	98990
UNKNOWN	// Just in case mFlushingWorkerThread changes but we arent woken up,	98991
UNKNOWN	// wait no longer than 1sec at a time	98992
UNKNOWN	// Ignore	98993
UNKNOWN	// Ensure that we have a valid page index to load synchronously	98994
UNKNOWN	// Ensure that we dont try and bind a specified page when the pages have not been	98995
UNKNOWN	// loaded already (we should load everything asynchronously in that case)	98996
UNKNOWN	// Ensure that we are never running the background loading at this point since	98997
UNKNOWN	// we also touch the background collections	98998
UNKNOWN	// XXX: Throw an exception if we are already loading (since we touch the worker thread	98999
UNKNOWN	//      data structures, we cant allow any other thread to touch that data, but because	99000
UNKNOWN	//      this call is synchronous, we can get away with not locking).	99001
UNKNOWN	// The LauncherModel is static in the LauncherAppState and mHandler may have queued	99002
UNKNOWN	// operations from the previous activity.  We need to ensure that all queued operations	99003
UNKNOWN	// are executed before any synchronous binding work is done.	99004
UNKNOWN	// Divide the set of loaded items into those that we are binding synchronously, and	99005
UNKNOWN	// everything else that is to be bound normally (asynchronously).	99006
UNKNOWN	// XXX: For now, continue posting the binding of AllApps as there are other issues that	99007
UNKNOWN	//      arise from that.	99008
UNKNOWN	// Optimize for end-user experience: if the Launcher is up and // running with the	99009
UNKNOWN	// All Apps interface in the foreground, load All Apps first. Otherwise, load the	99010
UNKNOWN	// workspace first (default).	99011
UNKNOWN	// Elevate priority when Home launches for the first time to avoid	99012
UNKNOWN	// starving at boot time. Staring at a blank home is not cool.	99013
UNKNOWN	// Whew! Hard work done.  Slow us down, and wait until the UI thread has	99014
UNKNOWN	// settled down.	99015
UNKNOWN	// second step	99016
UNKNOWN	// Restore the default thread priority after we are done loading items	99017
UNKNOWN	// Update the saved icons if necessary	99018
UNKNOWN	// Ensure that all the applications that are in the system are	99019
UNKNOWN	// represented on the home screen.	99020
UNKNOWN	// Clear out this reference, otherwise we end up holding it until all of the	99021
UNKNOWN	// callback runnables are done.	99022
UNKNOWN	// If we are still the last one to be scheduled, remove ourselves.	99023
UNKNOWN	/**         * Gets the callbacks object.  If weve been stopped, or if the launcher object         * has somehow been garbage collected, return null instead.  Pass in the Callbacks         * object that was around when the deferred message was scheduled, and if theres         * a new Callbacks object around then also return null.  This will save us from         * calling onto it with data that will be ignored.         */	99024
UNKNOWN	// Cross reference all the applications in our apps list with items in the workspace	99025
UNKNOWN	// We are missing an application icon, so add this to the workspace	99026
UNKNOWN	// This is a rare event, so lets log it	99027
UNKNOWN	// check & update map of whats occupied; used to discard overlapping/invalid items	99028
UNKNOWN	// Skip further checking if it is not the hotseat or workspace container	99029
UNKNOWN	// Check if any workspace icons overlap with each other	99030
UNKNOWN	/** Clears all the sBg data structures */	99031
UNKNOWN	/** Returns whether this is an upgrade path */	99032
UNKNOWN	// Log to disk	99033
UNKNOWN	// append the users Launcher2 shortcuts	99034
UNKNOWN	// Make sure the default workspace is loaded	99035
UNKNOWN	// This code path is for our old migration code and should no longer be exercised	99036
UNKNOWN	// Log to disk	99037
UNKNOWN	// +1 for the hotseat (it can be larger than the workspace)	99038
UNKNOWN	// Load workspace in reverse order to ensure that latest items are loaded first (and	99039
UNKNOWN	// before any earlier duplicates)	99040
UNKNOWN	//final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);	99041
UNKNOWN	//final int displayModeIndex = c.getColumnIndexOrThrow(	99042
UNKNOWN	//        LauncherSettings.Favorites.DISPLAY_MODE);	99043
UNKNOWN	// User has been deleted remove the item.	99044
UNKNOWN	// no special handling necessary for this item	99045
UNKNOWN	// We allow auto install apps to have their intent	99046
UNKNOWN	// updated after an install.	99047
UNKNOWN	// The app is installed but the component is no	99048
UNKNOWN	// longer available.	99049
UNKNOWN	// no special handling necessary for this item	99050
UNKNOWN	// Package is not yet available but might be	99051
UNKNOWN	// installed later.	99052
UNKNOWN	// Restore has started once.	99053
UNKNOWN	// App restore has started. Update the flag	99054
UNKNOWN	// Do not wait for external media load anymore.	99055
UNKNOWN	// Log the invalid package, and remove it	99056
UNKNOWN	// SdCard is not ready yet. Package might get available,	99057
UNKNOWN	// once it is ready.	99058
UNKNOWN	// Add the icon on the workspace anyway.	99059
UNKNOWN	// For shortcuts with no component, keep them as they are	99060
UNKNOWN	// Dont restore items for other profiles.	99061
UNKNOWN	// App shortcuts that used to be automatically added to Launcher	99062
UNKNOWN	// didnt always have the correct intent flags set, so do that	99063
UNKNOWN	// here	99064
UNKNOWN	// check & update map of whats occupied	99065
UNKNOWN	// Item is in a user folder	99066
UNKNOWN	// now that weve loaded everthing re-save it with the	99067
UNKNOWN	// icon in case it disappears somehow.	99068
UNKNOWN	// check & update map of whats occupied	99069
UNKNOWN	// no special handling required for restored folders	99070
UNKNOWN	// Read all Launcher-specific widget details	99071
UNKNOWN	// If provider was not previously ready, update the	99072
UNKNOWN	// status and UI flag.	99073
UNKNOWN	// Id would be valid only if the widget restore broadcast was received.	99074
UNKNOWN	// Restore has started once.	99075
UNKNOWN	// App restore has started. Update the flag	99076
UNKNOWN	// check & update map of whats occupied	99077
UNKNOWN	// Break early if weve stopped loading	99078
UNKNOWN	// Remove dead items	99079
UNKNOWN	// Dont notify content observers	99080
UNKNOWN	// Update restored items that no longer require special handling	99081
UNKNOWN	// If were importing we use the old screen order.	99082
UNKNOWN	// Log to disk	99083
UNKNOWN	// Update the max item id after we load an old db	99084
UNKNOWN	// If were importing we use the old screen order.	99085
UNKNOWN	// Log to disk	99086
UNKNOWN	// Remove any empty screens	99087
UNKNOWN	// If there are any empty screens remove them, and update.	99088
UNKNOWN	// Log to disk	99089
UNKNOWN	/** Filters the set of items who are directly or indirectly (via another container) on the         * specified screen. */	99090
UNKNOWN	// Purge any null ItemInfos	99091
UNKNOWN	// Order the set of items by their containers first, this allows use to walk through the	99092
UNKNOWN	// list sequentially, build up a list of containers that are in the specified screen,	99093
UNKNOWN	// as well as all items in those containers.	99094
UNKNOWN	/** Filters the set of widgets which are on the specified screen. */	99095
UNKNOWN	/** Filters the set of folders which are on the specified screen. */	99096
UNKNOWN	/** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to         * right) */	99097
UNKNOWN	// XXX: review this	99098
UNKNOWN	// +1 hotseat	99099
UNKNOWN	// +1 hotseat	99100
UNKNOWN	// Bind the workspace items	99101
UNKNOWN	// Bind the folders	99102
UNKNOWN	// Bind the widgets, one at a time	99103
UNKNOWN	/**         * Binds all loaded data to actual views on the main thread.         */	99104
UNKNOWN	// Dont use these two variables in any of the callback runnables.	99105
UNKNOWN	// Otherwise we hold a reference to them.	99106
UNKNOWN	// This launcher has exited and nobody bothered to tell us.  Just bail.	99107
UNKNOWN	// Save a copy of all the bg-thread collections	99108
UNKNOWN	// There may be no workspace screens (just hotseat items and an empty page).	99109
UNKNOWN	// Load all the items that are on the current page first (and in the process, unbind	99110
UNKNOWN	// all the existing workspace items before we call startBinding() below.	99111
UNKNOWN	// Separate the items that are on the current screen, and all the other remaining items	99112
UNKNOWN	// Tell the workspace that were about to start binding items	99113
UNKNOWN	// Load items on the current page	99114
UNKNOWN	// Load all the remaining pages (if we are loading synchronously, we want to defer this	99115
UNKNOWN	// work until after the first render)	99116
UNKNOWN	// Tell the workspace that were done binding items	99117
UNKNOWN	// If were profiling, ensure this is the last thing in the queue.	99118
UNKNOWN	// If were profiling, ensure this is the last thing in the queue.	99119
UNKNOWN	// This launcher has exited and nobody bothered to tell us.  Just bail.	99120
UNKNOWN	// shallow copy	99121
UNKNOWN	// This launcher has exited and nobody bothered to tell us.  Just bail.	99122
UNKNOWN	// Clear the list of apps	99123
UNKNOWN	// Query for the set of apps	99124
UNKNOWN	// Fail if we dont have any apps	99125
UNKNOWN	// Sort the applications by name	99126
UNKNOWN	// Create the ApplicationInfos	99127
UNKNOWN	// This builds the icon bitmaps.	99128
UNKNOWN	// Huh? Shouldnt this be inside the Runnable below?	99129
UNKNOWN	// Post callback on main thread	99130
UNKNOWN	// Write all the logs to disk	99139
UNKNOWN	// update the new data	99140
UNKNOWN	// Ensure that we add all the workspace applications to the db	99131
UNKNOWN	// Update the launcher db to reflect the changes	99132
UNKNOWN	// Mark all packages in the broadcast to be removed	99133
UNKNOWN	// Mark disabled packages in the broadcast to be removed	99134
UNKNOWN	// Remove all the components associated with this package	99135
UNKNOWN	// Remove all the specific components	99136
UNKNOWN	// Remove any queued items from the install queue	99137
UNKNOWN	// Call the components-removed callback	99138
UNKNOWN	// Return early if this is not initiated from a touch	99141
UNKNOWN	// Return early if we are still animating the pages	99142
UNKNOWN	// When we have exited all apps or are in transition, disregard long clicks	99143
UNKNOWN	// Return if global dragging is not enabled	99144
UNKNOWN	/*     * Determines if we should change the touch state to start scrolling after the     * user moves their touch point too far.     */	99145
UNKNOWN	/*     * Determines if we should change the touch state to start dragging after the     * user moves their touch point far enough.     */	99146
UNKNOWN	/*         * Locally do absolute value. mLastMotionX is set to the y value         * of the down event.         */	99147
UNKNOWN	// Drag if the user moved far enough along the Y axis	99148
UNKNOWN	// Cancel any pending long press	99149
UNKNOWN	// Try canceling the long press. It could also have been scheduled	99150
UNKNOWN	// by a distant descendant, so use the mAllowLongPress flag to block	99151
UNKNOWN	// everything	99152
UNKNOWN	/**     * Find and return partner details, or {@code null} if none exists.     */	99153
UNKNOWN	// We initialize customizable fields to be invalid	99154
UNKNOWN	// Get the hover color	99155
UNKNOWN	// Remove the text in the Phone UI in landscape	99156
UNKNOWN	// acceptDrop is called just before onDrop. We do the work here, rather than	99157
UNKNOWN	// in onDrop, because it allows us to reject the drop (by returning false)	99158
UNKNOWN	// so that the object being dragged isnt removed from the drag source.	99159
UNKNOWN	// There is no post-drop animation, so clean up the DragView now	99160
UNKNOWN	// Hide this button unless we are dragging something from AllApps	99161
UNKNOWN	// empty and a re-bind occurred	99215
UNKNOWN	// Restore the previous launcher state	99217
UNKNOWN	// Check for special shortcuts	99362
UNKNOWN	// Check for abandoned promise	99363
UNKNOWN	// Start activities	99364
UNKNOWN	// or .detectAll() for all detectable problems	99162
UNKNOWN	// Determine the dynamic grid properties	99163
UNKNOWN	// Lazy-initialize the dynamic grid	99164
UNKNOWN	// the LauncherApplication should call this, but in case of Instrumentation it might not be present yet	99165
UNKNOWN	// If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,	99166
UNKNOWN	// this also ensures that any synchronous binding below doesnt re-trigger another	99167
UNKNOWN	// LauncherModel load.	99168
UNKNOWN	// If the user leaves launcher, then we should just load items asynchronously when	99169
UNKNOWN	// they return.	99170
UNKNOWN	// We only load the page synchronously if the user rotates (or triggers a	99171
UNKNOWN	// configuration change) while launcher is in the foreground	99172
UNKNOWN	// For handling default keys	99173
UNKNOWN	// On large interfaces, we want the screen to auto-rotate based on the current orientation	99174
UNKNOWN	/** To be overriden by subclasses to hint to Launcher that we have custom content */	99175
UNKNOWN	/**     * To be overridden by subclasses to populate the custom content container and call     * {@link #addToCustomContentPage}. This will only be invoked if     * {@link #hasCustomContentToLeft()} is {@code true}.     */	99176
UNKNOWN	// The animated view may be null in the case of a rotation during widget configuration	99216
UNKNOWN	/**     * Invoked by subclasses to signal a change to the {@link #addCustomContentToLeft} value to     * ensure the custom content page is added or removed if necessary.     */	99177
UNKNOWN	// Not bound yet, wait for bindScreens to be called.	99178
UNKNOWN	// Create the custom content page and call the subclass to populate it.	99179
UNKNOWN	// recursive, but now with a locale configuration	99180
UNKNOWN	// recursive, but now with a locale configuration	99181
UNKNOWN	// Ignore	99182
UNKNOWN	// Ignore	99183
UNKNOWN	// Ignore	99184
UNKNOWN	// Ignore	99185
UNKNOWN	//noinspection ResultOfMethodCallIgnored	99186
UNKNOWN	// Ignore	99187
UNKNOWN	// We prevent dragging when we are loading the workspace as it is possible to pick up a view	99188
UNKNOWN	// that is subsequently removed from the workspace in startBinding().	99189
UNKNOWN	// View.generateViewId() is not available. The following fallback logic is a copy	99190
UNKNOWN	// of its implementation.	99191
UNKNOWN	// aapt-generated IDs have the high byte nonzero; clamp to the range under that.	99192
UNKNOWN	// Roll over to 1, not 0.	99193
UNKNOWN	// This cast is safe given the > 2B range for int.	99194
UNKNOWN	/**     * Returns whether we should delay spring loaded mode -- for shortcuts and widgets that have     * a configuration step, this allows the proper animations to run after other transitions.     */	99195
UNKNOWN	// When the screen id represents an actual screen (as opposed to a rank) we make sure	99196
UNKNOWN	// that the drop page actually exists.	99197
UNKNOWN	// Before adding this resetAddInfo(), after a shortcut was added to a workspace screen,	99198
UNKNOWN	// if you turned the screen off and then back while in All Apps, Launcher would not	99199
UNKNOWN	// return to the workspace. Clearing mAddInfo.container here fixes this issue	99200
UNKNOWN	// Reset the startActivity waiting flag	99201
UNKNOWN	// We have special handling for widgets	99202
UNKNOWN	// No need to remove the empty screen if were mid-binding, as the	99203
UNKNOWN	// the bind will not add the empty screen.	99204
UNKNOWN	// When the screen id represents an actual screen (as opposed to a rank)	99205
UNKNOWN	// we make sure that the drop page actually exists.	99206
UNKNOWN	// Update the widget view.	99207
UNKNOWN	// Leave the widget in the pending state if the user canceled the configure.	99208
UNKNOWN	// The pattern used here is that a user PICKs a specific application,	99209
UNKNOWN	// which, depending on the target, might need to CREATE the actual target.	99210
UNKNOWN	// For example, the user would PICK_SHORTCUT for Music playlist, and we	99211
UNKNOWN	// launch over to the Music app to actually CREATE_SHORTCUT.	99212
UNKNOWN	/**     * Check to see if a given screen id exists. If not, create it at the end, return the new id.     *     * @param screenId the screen id to check     * @return the new screen, or screenId if it exists     */	99213
UNKNOWN	// its possible that the add screen was removed because it was	99214
UNKNOWN	// Background was set to gradient in onPause(), restore to black if in all apps.	99218
UNKNOWN	// We might have postponed some bind calls until onResume (see waitUntilResume) --	99219
UNKNOWN	// execute them here	99220
UNKNOWN	// Reset the pressed state of icons that were locked in the press state while activities	99221
UNKNOWN	// were launching	99222
UNKNOWN	// Resets the previous workspace icon press state	99223
UNKNOWN	// It is possible that widgets can receive updates while launcher is not in the foreground.	99224
UNKNOWN	// Consequently, the widgets will be inflated in the orientation of the foreground activity	99225
UNKNOWN	// (framework issue). On resuming, we ensure that any widgets are inflated for the current	99226
UNKNOWN	// orientation.	99227
UNKNOWN	// Process any items that were added while Launcher was away.	99228
UNKNOWN	//Intent idleScreenIntent = new Intent(AppInterface.CAT_IDLE_SCREEN_ACTION);	99229
UNKNOWN	//idleScreenIntent.putExtra(SCREEN_IDLE, true);	99230
UNKNOWN	//og.d(TAG,Broadcasting Home Idle Screen Intent ...);	99231
UNKNOWN	//sendBroadcast(idleScreenIntent);	99232
UNKNOWN	// If we are resuming and the custom content is the current page, we call onShow().	99233
UNKNOWN	// It is also possible that onShow will instead be called slightly after first layout	99234
UNKNOWN	// if PagedView#setRestorePage was set to the custom content page in onCreate().	99235
UNKNOWN	// show OOBE	99236
UNKNOWN	// Ensure that items added to Launcher are queued until Launcher returns	99237
UNKNOWN	// We call onHide() aggressively. The custom content callbacks should be able to	99238
UNKNOWN	// debounce excess onHide calls.	99239
UNKNOWN	// Change to false to hide all apps on the overview pane	99240
UNKNOWN	// The custom content needs to offset its content to account for the QSB	99241
UNKNOWN	// Flag the loader to stop early before switching	99242
UNKNOWN	// We cant hide the IME if it was forced open.  So dont bother	99243
UNKNOWN	// something usable has been typed - start a search	99244
UNKNOWN	// the typed text will be retrieved and cleared by	99245
UNKNOWN	// showSearchDialog()	99246
UNKNOWN	// If there are multiple keystrokes before the search dialog takes focus,	99247
UNKNOWN	// onSearchRequested() will be called for every keystroke,	99248
UNKNOWN	// but it is idempotent, so its fine.	99249
UNKNOWN	// Eat the long press event so the keyboard doesnt come up.	99250
UNKNOWN	/**     * Given the integer (ordinal) value of a State enum instance, convert it to a variable of type     * State     */	99251
UNKNOWN	/**     * Restores the previous state, if it exists.     *     * @param savedState The previous state.     */	99252
UNKNOWN	// Restore the AppsCustomize tab	99253
UNKNOWN	/**     * Finds all the views we need and configure them properly.     */	99254
UNKNOWN	// Setup the drag layer	99255
UNKNOWN	// Setup the workspace	99256
UNKNOWN	// Get the search/delete bar	99257
UNKNOWN	// Setup AppsCustomize	99258
UNKNOWN	// Setup the drag controller (drop targets have to be added in reverse order in priority)	99259
UNKNOWN	/**     * Creates a view representing a shortcut.     *     * @param info The data structure describing the shortcut.     *     * @return A View inflated from R.layout.application.     */	99260
UNKNOWN	/**     * Creates a view representing a shortcut inflated from the specified resource.     *     * @param layoutResId The id of the XML layout used to create the shortcut.     * @param parent The group the shortcut belongs to.     * @param info The data structure describing the shortcut.     *     * @return A View inflated from layoutResId.     */	99261
UNKNOWN	/**     * Add a shortcut to the workspace.     *     * @param data The intent describing the shortcut.     * @param cellInfo The position on screen where to create the shortcut.     */	99262
UNKNOWN	// The app is trying to add a shortcut without sufficient permissions	99263
UNKNOWN	// First we check if we already know the exact location where we want to add this item.	99264
UNKNOWN	// If appropriate, either create a folder or add to an existing folder	99265
UNKNOWN	// when dragging and dropping, just find the closest free spot	99266
UNKNOWN	// We want to account for the extra amount of padding that we are adding to the widget	99267
UNKNOWN	// to ensure that it gets the full amount of space that it has requested	99268
UNKNOWN	/**     * Add a widget to the workspace.     *     * @param appWidgetId The app widget id     * @param cellInfo The position on screen where to create the widget.     */	99269
UNKNOWN	// Calculate the grid spans needed to fit this widget	99270
UNKNOWN	// Try finding open space on Launcher screen	99271
UNKNOWN	// We have saved the position to which the widget was dragged-- this really only matters	99272
UNKNOWN	// if we are placing widgets on a spring-loaded screen	99273
UNKNOWN	// when dragging and dropping, just find the closest free spot	99274
UNKNOWN	// Deleting an app widget ID is a void call but writes to disk before returning	99275
UNKNOWN	// to the caller...	99276
UNKNOWN	// Build Launcher-specific widget info and save to database	99277
UNKNOWN	// Perform actual inflation because were live	99278
UNKNOWN	// The AppWidgetHostView has already been inflated and instantiated	99279
UNKNOWN	// Reset AllApps to its initial state only if we are not in the middle of	99280
UNKNOWN	// processing a multi-step drop	99281
UNKNOWN	// Listen for broadcasts related to user-presence	99282
UNKNOWN	// For handling managed profiles	99283
UNKNOWN	/**     * Sets up transparent navigation and status bars in LMP.     * This method is a no-op for other platform versions.     */	99284
UNKNOWN	// TODO(sansid): use the APIs directly when compiling against L sdk.	99285
UNKNOWN	// Currently we use reflection to access the flags and the API to set the transparency	99286
UNKNOWN	// on the System bars.	99287
UNKNOWN	// The following code used to be in onResume, but it turns out onResume is called when	99288
UNKNOWN	// youre in All Apps and click home to go to the workspace. onWindowVisibilityChanged	99289
UNKNOWN	// is a more appropriate event to handle	99290
UNKNOWN	// We want to let Launcher draw itself at least once before we force it to build	99291
UNKNOWN	// layers on all the workspace pages, so that transitioning to Launcher from other	99292
UNKNOWN	// apps is nice and speedy.	99293
UNKNOWN	// We delay the layer building a bit in order to give	99294
UNKNOWN	// other message processing a time to run.  In particular	99295
UNKNOWN	// this avoids a delay in hiding the IME if it was	99296
UNKNOWN	// currently shown, because doing that may involve	99297
UNKNOWN	// some communication back with the app.	99298
UNKNOWN	// We delay the layer building a bit in order to give	99299
UNKNOWN	// other message processing a time to run.  In particular	99300
UNKNOWN	// this avoids a delay in hiding the IME if it was	99301
UNKNOWN	// currently shown, because doing that may involve	99302
UNKNOWN	// some communication back with the app.	99303
UNKNOWN	// Remove messages sent using postDelayed()	99304
UNKNOWN	// Whatever we were doing is hereby canceled.	99305
UNKNOWN	// Close the menu	99306
UNKNOWN	// also will cancel mWaitingForResult.	99307
UNKNOWN	// Can be cases where mWorkspace is null, this prevents a NPE	99308
UNKNOWN	// In all these cases, only animate if were already on home	99309
UNKNOWN	// If we are already on home, then just animate back to the workspace,	99310
UNKNOWN	// otherwise, just wait until onResume to set the state back to Workspace	99311
UNKNOWN	// Reset the apps customize page	99312
UNKNOWN	/**     * Override point for subclasses to prevent movement to the default screen when the home     * button is pressed. Used (for example) in GEL, to prevent movement during a search.     */	99313
UNKNOWN	/**     * Override point for subclasses to provide custom behaviour for when a home intent is fired.     */	99314
UNKNOWN	// We close any open folder since it will not be re-opened, and we need to make sure	99315
UNKNOWN	// this state is reflected.	99316
UNKNOWN	// Save the current AppsCustomize tab	99317
UNKNOWN	// Remove all pending runnables	99318
UNKNOWN	// Stop callbacks from LauncherModel	99319
UNKNOWN	// Its possible to receive onDestroy after a new Launcher activity has	99320
UNKNOWN	// been created. In this case, dont interfere with the new Launcher.	99321
UNKNOWN	// Disconnect any of the callbacks and drawables associated with ItemInfos on the workspace	99322
UNKNOWN	// to prevent leaking Launcher activities on orientation change.	99323
UNKNOWN	/**     * Indicates that we want global search for this activity by setting the globalSearch     * argument for {@link #startSearch} to true.     */	99324
UNKNOWN	// Use any text typed in the launcher as the initial query	99325
UNKNOWN	/**     * Start a text search.     *     * @return {@code true} if the search will start immediately, so any further keypresses     * will be handled directly by the search UI. {@code false} if {@link Launcher} should continue     * to buffer keypresses.     */	99326
UNKNOWN	/**     * Starts the global search activity. This code is a copied from SearchManager     */	99327
UNKNOWN	// Make sure that we have a Bundle to put source in	99328
UNKNOWN	// Set source to package name of app that starts global search, if not set already.	99329
UNKNOWN	// Close any open folders	99330
UNKNOWN	// Stop resizing any widgets	99331
UNKNOWN	// Show the overview mode	99332
UNKNOWN	// Use a custom animation for launching search	99333
UNKNOWN	// Launch over to configure widget, if needed	99334
UNKNOWN	// Otherwise just add it	99335
UNKNOWN	// Exit spring loaded mode if necessary after adding the widget	99336
UNKNOWN	// Exit spring loaded mode if necessary after adding the widget	99337
UNKNOWN	// Close any folders that may be open.	99338
UNKNOWN	/**     * Process a shortcut drop.     *     * @param componentName The name of the component     * @param screenId The ID of the screen where it should be added     * @param cell The cell it should be added to, optional     * @param position The location on the screen where it was dropped, optional     */	99339
UNKNOWN	/**     * Process a widget drop.     *     * @param info The PendingAppWidgetInfo of the widget being added.     * @param screenId The ID of the screen where it should be added     * @param cell The cell it should be added to, optional     * @param position The location on the screen where it was dropped, optional     */	99340
UNKNOWN	// In this case, we either need to start an activity to get permission to bind	99341
UNKNOWN	// the widget, or we need to start an activity to configure the widget, or both.	99342
UNKNOWN	// TODO: we need to make sure that this accounts for the options bundle.	99343
UNKNOWN	// intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);	99344
UNKNOWN	// Update the model	99345
UNKNOWN	// Create the view	99346
UNKNOWN	// Force measure the new folder icon	99347
UNKNOWN	/**     * Registers various content observers. The current implementation registers     * only a favorites observer to keep track of the favorites applications.     */	99348
UNKNOWN	// Back button is a no-op here, but give at least some feedback for the button press	99349
UNKNOWN	/**     * Re-listen when widgets are reset.     */	99350
UNKNOWN	/**     * Launches the intent referred by the clicked shortcut.     *     * @param v The view representing the clicked shortcut.     */	99351
UNKNOWN	// Make sure that rogue clicks dont get through while allapps is launching, or after the	99352
UNKNOWN	// view has detached (its possible for this to happen if the view is removed mid touch).	99353
UNKNOWN	/**     * Event handler for the app widget view which has not fully restored.     */	99354
UNKNOWN	// The install has not been queued	99355
UNKNOWN	// Download has started.	99356
UNKNOWN	/**     * Event handler for the search button     *     * @param v The view that was clicked.     */	99357
UNKNOWN	/**     * Event handler for the voice button     *     * @param v The view that was clicked.     */	99358
UNKNOWN	/**     * Event handler for the grid button that appears on the home screen, which     * enters all apps mode.     *     * @param v The view that was clicked.     */	99359
UNKNOWN	/**     * Event handler for an app shortcut click.     *     * @param v The view that was clicked. Must be a tagged with a {@link ShortcutInfo}.     */	99360
UNKNOWN	// Open shortcut	99361
UNKNOWN	/**     * Event handler for a folder icon click.     *     * @param v The view that was clicked. Must be an instance of {@link FolderIcon}.     */	99365
UNKNOWN	// If the folder info reports that the associated folder is open, then verify that	99366
UNKNOWN	// it is actually opened. There have been a few instances where this gets out of sync.	99367
UNKNOWN	// Close any open folder	99368
UNKNOWN	// Open the requested folder	99369
UNKNOWN	// Find the open folder...	99370
UNKNOWN	// .. and close it	99371
UNKNOWN	// Close any folder open on the current screen	99372
UNKNOWN	// Pull the folder onto this screen	99373
UNKNOWN	/**     * Event handler for the (Add) Widgets button that appears after a long press     * on the home screen.     */	99374
UNKNOWN	/**     * Event handler for the wallpaper picker button that appears after a long press     * on the home screen.     */	99375
UNKNOWN	/**     * Event handler for a click on the settings button that appears after a long press     * on the home screen.     */	99376
UNKNOWN	// Provide the same haptic feedback that the system offers for virtual keys.	99377
UNKNOWN	// Provide the same haptic feedback that the system offers for virtual keys.	99378
UNKNOWN	/**     * Called when the user stops interacting with the launcher.     * This implies that the user is now on the homescreen and is not doing housekeeping.     */	99379
UNKNOWN	/**     * Called when the user starts interacting with the launcher.     * The possible interactions are:     *  - open all apps     *  - reorder an app shortcut, or a widget     *  - open the overview mode.     * This is a good time to stop doing things that only make sense     * when the user is on the homescreen and not doing housekeeping.     */	99380
UNKNOWN	// returns true if the activity was started	99381
UNKNOWN	// System applications cannot be installed. For now, show a toast explaining that.	99382
UNKNOWN	// We may give them the option of disabling apps this way.	99383
UNKNOWN	// Only launch using the new animation if the shortcut has not opted out (this is a	99384
UNKNOWN	// private contract between launcher and may be ignored in the future).	99385
UNKNOWN	// Could be launching some bookkeeping activity	99386
UNKNOWN	// TODO Component can be null when shortcuts are supported for secondary user	99387
UNKNOWN	/**     * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView     * in the DragLayer in the exact absolute location of the original FolderIcon.     */	99388
UNKNOWN	// Lazy load ImageView, Bitmap and Canvas	99389
UNKNOWN	// The layout from which the folder is being opened may be scaled, adjust the starting	99390
UNKNOWN	// view size by this scale factor.	99391
UNKNOWN	// Just in case this image view is still in the drag layer from a previous animation,	99392
UNKNOWN	// we remove it and re-add it.	99393
UNKNOWN	// Push an ImageView copy of the FolderIcon into the DragLayer and hide the original	99394
UNKNOWN	// We remove and re-draw the FolderIcon in-case it has changed	99395
UNKNOWN	// Remove the ImageView copy of the FolderIcon and make the original visible.	99396
UNKNOWN	// Remove the ImageView copy of the FolderIcon and make the original visible.	99397
UNKNOWN	/**     * Opens the user folder described by the specified tag. The opening of the folder     * is animated relative to the specified View. If the View is null, no animation     * is played.     *     * @param folderInfo The FolderInfo describing the folder to open.     */	99398
UNKNOWN	// Just verify that the folder hasnt already been added to the DragLayer.	99399
UNKNOWN	// There was a one-off crash where the folder had a parent already.	99400
UNKNOWN	// Notify the accessibility manager that this folder window has appeared and occluded	99401
UNKNOWN	// the workspace items	99402
UNKNOWN	// Notify the accessibility manager that this folder window has disappeard and no	99403
UNKNOWN	// longer occludeds the workspace items	99404
UNKNOWN	// User long pressed on empty space	99405
UNKNOWN	// User long pressed on an item	99406
UNKNOWN	/**     * Returns the CellLayout of the specified container at the specified screen.     */	99407
UNKNOWN	// Update the workspace transition step as well	99408
UNKNOWN	// Update the workspace transition step as well	99409
UNKNOWN	/**     * Things to test when changing the following seven functions.     *   - Home from workspace     *          - from center screen     *          - from other screens     *   - Home from all apps     *          - from center screen     *          - from other screens     *   - Back from all apps     *          - from center screen     *          - from other screens     *   - Launch app from workspace and quit     *          - with back     *          - with home     *   - Launch app from all apps and quit     *          - with back     *          - with home     *   - Go to a screen thats not the default, then all     *     apps, and launch and app, and go back     *          - with back     *          -with home     *   - On workspace, long press power and go back     *          - with back     *          - with home     *   - On all apps, long press power and go back     *          - with back     *          - with home     *   - On workspace, power off     *   - On all apps, power off     *   - Launch an app and turn off the screen while in that app     *          - Go back with home key     *          - Go back with back key  TODO: make this not go to workspace     *          - From all apps     *          - From workspace     *   - Enter and exit car mode (becuase it causes an extra configuration changed)     *          - From all apps     *          - From the center workspace     *          - From another workspace     */	99410
UNKNOWN	/**     * Zoom the camera out from the workspace to reveal toView.     * Assumes that the view to show is anchored at either the very top or very bottom     * of the screen.     */	99411
UNKNOWN	// Set the content type for the all apps/widgets space	99412
UNKNOWN	// If for some reason our views arent initialized, dont animate	99413
UNKNOWN	// Hide the real page background, and swap in the fake one	99414
UNKNOWN	// We need to hide this view as the animation start will be posted.	99415
UNKNOWN	// Get the y delta between the center of the page and the center of the all apps button	99416
UNKNOWN	// Check that mStateAnimation hasnt changed while	99417
UNKNOWN	// we waited for a layout/draw pass	99418
UNKNOWN	// Check that mStateAnimation hasnt changed while	99419
UNKNOWN	// we waited for a layout/draw pass	99420
UNKNOWN	/**     * Zoom the camera back into the workspace, hiding fromView.     * This is the opposite of showAppsCustomizeHelper.     * @param animated If true, the transition will be animated.     */	99421
UNKNOWN	// If for some reason our views arent initialized, dont animate	99422
UNKNOWN	// We need to hide side pages of the Apps / Widget tray to avoid some ugly edge cases	99423
UNKNOWN	// hideAppsCustomizeHelper is called in some cases when it is already hidden	99424
UNKNOWN	// dont perform all these no-op animations. In particularly, this was causing	99425
UNKNOWN	// the all-apps button to pop in and out.	99426
UNKNOWN	// Hide the real page background, and swap in the fake one	99427
UNKNOWN	// The vertical motion of the apps panel should be delayed by one frame	99428
UNKNOWN	// from the conceal animation in order to give the right feel. We correspondingly	99429
UNKNOWN	// shorten the duration so that the slide and conceal end at the same time.	99430
UNKNOWN	// Unhide side pages	99431
UNKNOWN	// Reset page transforms	99432
UNKNOWN	// Check that mStateAnimation hasnt changed while	99433
UNKNOWN	// we waited for a layout/draw pass	99434
UNKNOWN	// Unhide side pages	99435
UNKNOWN	// Reset page transforms	99436
UNKNOWN	// Check that mStateAnimation hasnt changed while	99437
UNKNOWN	// we waited for a layout/draw pass	99438
UNKNOWN	// Set focus to the AppsCustomize button	99439
UNKNOWN	// Change the state *after* weve called all the transition code	99440
UNKNOWN	// Resume the auto-advance of widgets	99441
UNKNOWN	// Send an accessibility event to announce the context change	99442
UNKNOWN	// We post this in-case the all apps view isnt yet constructed.	99443
UNKNOWN	// Change the state *after* weve called all the transition code	99444
UNKNOWN	// Pause the auto-advance of widgets until we are out of AllApps	99445
UNKNOWN	// Send an accessibility event to announce the context change	99446
UNKNOWN	// We post this in-case the all apps view isnt yet constructed.	99447
UNKNOWN	// Before we show workspace, hide all apps again because	99448
UNKNOWN	// exitSpringLoadedDragMode made it visible. This is a bit hacky; we should	99449
UNKNOWN	// clean up our state transition functions	99450
UNKNOWN	// Before we show workspace, hide all apps again because	99451
UNKNOWN	// exitSpringLoadedDragMode made it visible. This is a bit hacky; we should	99452
UNKNOWN	// clean up our state transition functions	99453
UNKNOWN	// Otherwise, we are not in spring loaded mode, so dont do anything.	99454
UNKNOWN	// TODO	99455
UNKNOWN	// TODO	99456
UNKNOWN	/**     * Add an item from all apps or customize onto the given workspace screen.     * If layout is null, add to the current screen.     */	99457
UNKNOWN	/** Maps the current orientation to an index for referencing orientation correct global icons */	99458
UNKNOWN	// default - 0, landscape - 1	99459
UNKNOWN	// Look for the toolbar icon specified in the activity meta-data	99460
UNKNOWN	// This can happen if the activity defines an invalid drawable	99461
UNKNOWN	// This can happen if the activity defines an invalid drawable	99462
UNKNOWN	// if successful in getting icon, return it; otherwise, set button to use default drawable	99463
UNKNOWN	// If we were unable to find the icon via the meta-data, use a generic one	99464
UNKNOWN	// if successful in getting icon, return it; otherwise, set button to use default drawable	99465
UNKNOWN	// If we were unable to find the icon via the meta-data, use a	99466
UNKNOWN	// generic one	99467
UNKNOWN	// Populate event with a fake title based on the current state.	99468
UNKNOWN	/**     * If the activity is currently paused, signal that we need to run the passed Runnable     * in onResume.     *     * This needs to be called from incoming places where resources might have been loaded     * while we are paused.  That is becaues the Configuration might be wrong     * when were not running, and if it comes back to what it was when we     * were paused, we are not restarted.     *     * Implementation of the method from LauncherModel.Callbacks.     *     * @return true if we are currently paused.  The caller might be able to     * skip some work in that case since we will come back again.     */	99469
UNKNOWN	//noinspection StatementWithEmptyBody	99470
UNKNOWN	/**     * If the activity is currently paused, signal that we need to re-run the loader     * in onResume.     *     * This needs to be called from incoming places where resources might have been loaded     * while we are paused.  That is becaues the Configuration might be wrong     * when were not running, and if it comes back to what it was when we     * were paused, we are not restarted.     *     * Implementation of the method from LauncherModel.Callbacks.     *     * @return true if we are currently paused.  The caller might be able to     * skip some work in that case since we will come back again.     */	99471
UNKNOWN	/**     * Implementation of the method from LauncherModel.Callbacks.     */	99472
UNKNOWN	/**     * Refreshes the shortcuts shown on the workspace.     *     * Implementation of the method from LauncherModel.Callbacks.     */	99473
UNKNOWN	// If were starting binding all over again, clear any bind calls wed postponed in	99474
UNKNOWN	// the past (see waitUntilResume) -- we dont need them since were starting binding	99475
UNKNOWN	// from scratch again	99476
UNKNOWN	// Clear the workspace because its going to be rebound	99477
UNKNOWN	// If there are no screens, we need to have an empty screen	99478
UNKNOWN	// Create the custom content page (this call updates mDefaultScreen which calls	99479
UNKNOWN	// setCurrentPage() so ensure that all pages are added before calling this).	99480
UNKNOWN	// Log to disk	99481
UNKNOWN	// Add the new screens	99482
UNKNOWN	// We add the items without animation on non-visible pages, and with	99483
UNKNOWN	// animations on the new page (which we will try and snap to).	99484
UNKNOWN	// Remove the extra empty screen	99485
UNKNOWN	/**     * Bind the items start-end from the list.     *     * Implementation of the method from LauncherModel.Callbacks.     */	99486
UNKNOWN	// Get the list of added shortcuts and intersect them with the set of shortcuts here	99487
UNKNOWN	/*                     * TODO: FIX collision case                     */	99488
UNKNOWN	// Animate all the applications up now	99489
UNKNOWN	// Animate to the correct page	99490
UNKNOWN	// We post the animation slightly delayed to prevent slowdowns	99491
UNKNOWN	// when we are loading right after we return to launcher.	99492
UNKNOWN	/**     * Implementation of the method from LauncherModel.Callbacks.     */	99493
UNKNOWN	/**     * Add the views for a widget to the workspace.     *     * Implementation of the method from LauncherModel.Callbacks.     */	99494
UNKNOWN	// Note: This assumes that the id remap broadcast is received before this step.	99495
UNKNOWN	// If that is not the case, the id remap will be ignored and user may see the	99496
UNKNOWN	// click to setup view.	99497
UNKNOWN	// TODO consider showing a permission dialog when the widget is clicked.	99498
UNKNOWN	// If the widget has a configure activity, it is still needs to set it up, otherwise	99499
UNKNOWN	// the widget is ready to go.	99500
UNKNOWN	/**     * Restores a pending widget.     *     * @param appWidgetId The app widget id     * @param cellInfo The position on screen where to create the widget.     */	99501
UNKNOWN	/**     * Callback saying that there arent any more items to bind.     *     * Implementation of the method from LauncherModel.Callbacks.     */	99502
UNKNOWN	// If we received the result of any pending adds while the loader was running (e.g. the	99503
UNKNOWN	// widget configuration forced an orientation change), process them now.	99504
UNKNOWN	// TODO: this moves the user to the page where the pending item was added. Ideally,	99505
UNKNOWN	// the screen would be guaranteed to exist after bind, and the page would be set through	99506
UNKNOWN	// the workspace restore process.	99507
UNKNOWN	/**     * Add the icons for all apps.     *     * Implementation of the method from LauncherModel.Callbacks.     */	99508
UNKNOWN	/**     * A package was updated.     *     * Implementation of the method from LauncherModel.Callbacks.     */	99509
UNKNOWN	/**     * Packages were restored     */	99510
UNKNOWN	/**     * Update the state of a package, typically related to install state.     *     * Implementation of the method from LauncherModel.Callbacks.     */	99511
UNKNOWN	/**     * Update the label and icon of all the icons in a package     *     * Implementation of the method from LauncherModel.Callbacks.     */	99512
UNKNOWN	/**     * A package was uninstalled.  We take both the super set of packageNames     * in addition to specific applications to remove, the reason being that     * this can be called when a package is updated as well.  In that scenario,     * we only remove specific components from the workspace, where as     * package-removal should clear all items by package name.     *     * Implementation of the method from LauncherModel.Callbacks.     */	99513
UNKNOWN	// Notify the drag controller	99514
UNKNOWN	// Update AllApps	99515
UNKNOWN	// Update the widgets pane	99516
UNKNOWN	// We are currently in the same basic orientation as the natural orientation	99517
UNKNOWN	// We are currently in the other basic orientation to the natural orientation	99518
UNKNOWN	// Since the map starts at portrait, we need to offset if this devices natural orientation	99519
UNKNOWN	// is landscape.	99520
UNKNOWN	/**     * Called when the SearchBar hint should be changed.     *     * @param hint the hint to be displayed in the search bar.     */	99521
UNKNOWN	/**     * This method indicates whether or not we should suggest default wallpaper dimensions     * when our wallpaper cropper was not yet used to set a wallpaper.     */	99522
UNKNOWN	/**     * To be overridden by subclasses to indicate that there is an activity to launch     * before showing the standard launcher experience.     */	99523
UNKNOWN	/**     * To be overridden by subclasses to launch any first run activity     */	99524
UNKNOWN	/**     * To be overridden by subclasses to indicate that there is an in-activity full-screen intro     * screen that must be displayed and dismissed.     */	99525
UNKNOWN	/**     * Full screen intro screen to be shown and dismissed before the launcher can be used.     */	99526
UNKNOWN	/**     * To be overriden by subclasses to indicate whether the in-activity intro screen has been     * dismissed. This method is ignored if #hasDismissableIntroScreen returns false.     */	99527
UNKNOWN	// We delay hiding the intro view until the first run activity is showing. This	99528
UNKNOWN	// avoids a blip.	99529
UNKNOWN	// The two first run cling paths are mutually exclusive, if the launcher is preinstalled	99530
UNKNOWN	// on the device, then we always show the first run cling experience (or if there is no	99531
UNKNOWN	// launcher2). Otherwise, we prompt the user upon started for migration	99532
UNKNOWN	//launcherClings.showLongPressCling(true);	99533
UNKNOWN	// Called from search suggestion, not supported in other profiles.	99534
UNKNOWN	// Called from search suggestion, not supported in other profiles.	99535
UNKNOWN	/**     * Prints out out state for debugging.     */	99536
UNKNOWN	/**     * Show OOBE tutorial on first use of Edge Swipe, Edit Favorites, etc...     *     * @param oobeToShow     *            Activity identifier: SHOW_OOBE_EDIT_FAVORITES or     *            SHOW_OOBE_EDGE_SWIPE_MENU     * @param oobeTutorial     *            Tutorial to show: OOBEActivity.OOBE_EDIT_FAVORITES_TUTORIAL,     *            OOBEActivity.OOBE_EDGE_SWIPE_TUTORIAL,     *            OOBEActivity.OOBE_FULL_TUTORIAL     */	99537
UNKNOWN	//if (true || mSharedPrefs.getBoolean(oobeToShow, true)) { //Uncomment to loop the animation	99538
UNKNOWN	/**     * Starts the OOBEActivity in the selected tutorial     *     * @param oobeTutorial     *            Tutorial to show: OOBEActivity.OOBE_EDIT_FAVORITES_TUTORIAL,     *            OOBEActivity.OOBE_EDGE_SWIPE_TUTORIAL,     *            OOBEActivity.OOBE_FULL_TUTORIAL     */	99539
UNKNOWN	// Enable the hw layers before the animation starts (will be disabled in the onAnimationEnd	99540
UNKNOWN	// callback below)	99541
UNKNOWN	// Get the individual components	99542
UNKNOWN	// Create the various fade animations	99543
UNKNOWN	/*     * Gets various transition durations.     */	99544
UNKNOWN	/*     * DragController.DragListener implementation     */	99545
UNKNOWN	// Animate out the QSB search bar, and animate in the drop target bar	99546
UNKNOWN	// Restore the QSB search bar, and animate out the drop target bar	99547
UNKNOWN	// The text fits in a single line. No need to draw the setup icon.	99555
UNKNOWN	// Update left and top to indicate the position where the text will be drawn.	99556
UNKNOWN	// No-op	99548
UNKNOWN	// Re inflate is required any time the widget restore status changes	99549
UNKNOWN	// The view displays two modes, one with a setup icon and another with a preload icon	99550
UNKNOWN	// in the center.	99551
UNKNOWN	// AppWidgetHostView blocks all click events on the root view. Instead handle click events	99552
UNKNOWN	// on the content and pass it along.	99553
UNKNOWN	// Recreate the setup text.	99554
UNKNOWN	// The text cant be drawn in a single line. Draw a setup icon instead.	99557
UNKNOWN	// Load the preferences from an XML resource	99558
UNKNOWN	/**     * The size of the indicator is same as the content region of the {@link #mBgDrawable} minus     * half the stroke size to accommodate the indicator.     */	99559
UNKNOWN	// Amount by which padding has to be scaled	99560
UNKNOWN	// The draw region has been clipped.	99561
UNKNOWN	// Stop Animation	99562
UNKNOWN	// Set the paint color only when the level changes, so that the dominant color	99563
UNKNOWN	// is only calculated when needed.	99564
UNKNOWN	/**     * Runs the finish animation if it is has not been run after last level change.     */	99565
UNKNOWN	// Make sure that the dominant color has enough saturation to be visible properly.	99566
UNKNOWN	// Set a new alarm to expire for the screen that we are hovering over now	99567
UNKNOWN	// this is called when our timer runs out	99568
UNKNOWN	// Snap to the screen that we are hovering over now	99569
UNKNOWN	// suppress dead code warning	99570
UNKNOWN	// Debug drawing for hit space	99571
UNKNOWN	// Set whether or not to invert the layout horizontally if the layout is in RTL mode.	99572
UNKNOWN	// Widgets have their own padding, so skip	99573
UNKNOWN	// Otherwise, center the icon	99574
UNKNOWN	// Cancel long press for all children	99575
UNKNOWN	// Update the drawing caches	99576
UNKNOWN	/**     * Initializes various states for this workspace.     */	99577
UNKNOWN	// if (!mScroller.isFinished()) return;	99578
UNKNOWN	// Keep generating points as long as were more than 1px away from the target	99579
UNKNOWN	// TODO: initial wallpaper now that wallpapers are owned by another app	99580
UNKNOWN	// TODO: make removeShortcut internally threadsafe	99581
UNKNOWN	// Ignore	99582
UNKNOWN	// TODO: delayed writes	99583
UNKNOWN	// not a problem	99584
UNKNOWN	// more of a problem	99585
UNKNOWN	//Log.v(WeightWatcher.ProcessWatcher,	99586
UNKNOWN	//        MSG_UPDATE pss= + mMemInfo.currentPss);	99587
UNKNOWN	// app	99588
UNKNOWN	// service	99589
UNKNOWN	//Log.v(WeightWatcher.ProcessWatcher,	99590
UNKNOWN	//        MSG_UPDATE pss= + mMemInfo.currentPss);	99591
UNKNOWN	// app	99592
UNKNOWN	// service	99593
UNKNOWN	// draw a big box for the icon for debugging	99605
UNKNOWN	// suppress dead code warning	99604
UNKNOWN	/**     * Returns a FastBitmapDrawable with the icon, accurately sized.     */	99594
UNKNOWN	/**     * Resizes an icon drawable to the correct icon size.     */	99595
UNKNOWN	/**     * Indicates if the device is running LMP or higher.     */	99596
UNKNOWN	/**     * Returns a bitmap which is of the appropriate size to be displayed as an icon     */	99597
UNKNOWN	// we share the statics :-(	99598
UNKNOWN	/**     * Returns a bitmap suitable for the all apps view.     */	99599
UNKNOWN	// we share the statics :-(	99600
UNKNOWN	// Ensure the bitmap has a density.	99601
UNKNOWN	// Scale the icon proportionally to the icon dimensions	99602
UNKNOWN	// no intrinsic size --> use default size	99603
UNKNOWN	/**     * Given a coordinate relative to the descendant, find the coordinate in a parent views     * coordinates.     *     * @param descendant The descendant to which the passed coordinate is relative.     * @param root The root view to make the coordinates relative to.     * @param coord The coordinate that we want mapped.     * @param includeRootScroll Whether or not to account for the scroll of the descendant:     *          sometimes this is relevant as in a childs coordinates within the descendant.     * @return The factor by which this descendant is scaled relative to this DragLayer. Caution     *         this scale factor is assumed to be equal in X and Y, and so if at any point this     *         assumption fails, we will need to return a pair of scale factors.     */	99606
UNKNOWN	// For TextViews, scroll has a meaning which relates to the text position	99607
UNKNOWN	// which is very strange... ignore the scroll.	99608
UNKNOWN	/**     * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.     */	99609
UNKNOWN	/**     * Utility method to determine whether the given point, in local coordinates,     * is inside the view, where the area of the view is expanded by the slop factor.     * This method is called while processing touch-move events to determine if the event     * is still within the view.     */	99610
UNKNOWN	/**     * This picks a dominant color, looking for high-saturation, high-value, repeated hues.     * @param bitmap The bitmap to scan     * @param samples The approximate max number of samples to use.     */	99611
UNKNOWN	// This is an out-param, for getting the hsv values for an rgb	99612
UNKNOWN	// First get the best hue, by creating a histogram over 360 hue buckets,	99613
UNKNOWN	// where each pixel contributes a score weighted by saturation, value, and alpha.	99614
UNKNOWN	// Drop mostly-transparent pixels.	99615
UNKNOWN	// Remove the alpha channel.	99616
UNKNOWN	// Bucket colors by the 360 integer hues.	99617
UNKNOWN	// Defensively avoid array bounds violations.	99618
UNKNOWN	// Go back over the RGB colors that match the winning hue,	99619
UNKNOWN	// creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.	99620
UNKNOWN	// The highest-scoring RGB color wins.	99621
UNKNOWN	// Score by cumulative saturation * value.	99622
UNKNOWN	// All the colors in the winning bucket are very similar. Last in wins.	99623
UNKNOWN	/*     * Finds a system apk which had a broadcast receiver listening to a particular action.     * @param action intent action used to find the apk     * @return a pair of apk package name and the resources.     */	99624
UNKNOWN	// launching the application	99625
UNKNOWN	// Most Used	99626
UNKNOWN	// set the all apps	99627
UNKNOWN	// to determine the full scroll width	99818
UNKNOWN	/**     * Initializes various states for this workspace.     */	99628
UNKNOWN	// Scale the fling-to-delete threshold by the density	99629
UNKNOWN	// Hook up the page indicator	99630
UNKNOWN	// Unhook the page indicator	99631
UNKNOWN	// Convenience methods to map points from self to parent and vice versa	99632
UNKNOWN	// Convenience methods to get the actual width/height of the PagedView (since it is measured	99633
UNKNOWN	// to be larger to account for the minimum possible scale)	99634
UNKNOWN	// Convenience methods to get the offset ASSUMING that we are centering the pages in the	99635
UNKNOWN	// PagedView both horizontally and vertically	99636
UNKNOWN	/**     * Add a page change listener which will be called when a page is _finished_ listening.     *     */	99637
UNKNOWN	/**     * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.     */	99638
UNKNOWN	/**     * Called by subclasses to mark that data is ready, and that we can begin loading and laying     * out pages.     */	99639
UNKNOWN	/**     * Returns the index of the currently displayed page.     *     * @return The index of the currently displayed page.     */	99640
UNKNOWN	/**     * Updates the scroll of the current page immediately to its final scroll position.  We use this     * in CustomizePagedView to allow tabs to share the same PagedView while resetting the scroll of     * the previous tab page.     */	99641
UNKNOWN	// If the current page is invalid, just reset the scroll position to zero	99642
UNKNOWN	/**     * Called during AllApps/Home transitions to avoid unnecessary work. When that other animation     * {@link #updateCurrentPageScroll()} should be called, to correctly set the final state and     * re-enable scrolling.     */	99643
UNKNOWN	// We need to clean up the next page here to avoid computeScrollHelper from	99644
UNKNOWN	// updating current page on the pass.	99645
UNKNOWN	// We need to clean up the next page here to avoid computeScrollHelper from	99646
UNKNOWN	// updating current page on the pass.	99647
UNKNOWN	// When in free scroll mode, we need to clamp to the free scroll page range.	99648
UNKNOWN	// Ensure that it is clamped by the actual set of children in all cases	99649
UNKNOWN	/**     * Sets the current page.     */	99650
UNKNOWN	// dont introduce any checks like mCurrentPage == currentPage here-- if we change the	99651
UNKNOWN	// the default	99652
UNKNOWN	/**     * The restore page will be set in place of the current page at the next (likely first)     * layout.     */	99653
UNKNOWN	/**     * Should be called whenever the page changes. In the case of a scroll, we wait until the page     * has settled.     */	99654
UNKNOWN	// Update the page indicator (when we arent reordering)	99655
UNKNOWN	// a method that subclasses can override to add behavior	99656
UNKNOWN	// a method that subclasses can override to add behavior	99657
UNKNOWN	/**     * Registers the specified listener on each page contained in this workspace.     *     * @param l The listener used to respond to long clicks.     */	99658
UNKNOWN	// In free scroll mode, we clamp the scrollX	99659
UNKNOWN	// Update the last motion events when scrolling	99660
UNKNOWN	// we moved this functionality to a helper function so SmoothPagedView can reuse it	99661
UNKNOWN	// Dont bother scrolling if the page does not need to be moved	99662
UNKNOWN	// Load the associated pages if necessary	99663
UNKNOWN	// We dont want to trigger a page end moving unless the page has settled	99664
UNKNOWN	// and the user has stopped scrolling	99665
UNKNOWN	// Notify the user when the page changes	99666
UNKNOWN	// We measure the dimensions of the PagedView to be larger than the pages so that when we	99667
UNKNOWN	// zoom out (and scale down), the view is still contained in the parent	99668
UNKNOWN	// NOTE: We multiply by 2f to account for the fact that depending on the offset of the	99669
UNKNOWN	// viewport, we can be at most one and a half screens offset once we scale down	99670
UNKNOWN	// Return early if we arent given a proper dimension	99671
UNKNOWN	/* Allow the height to be set as WRAP_CONTENT. This allows the particular case         * of the All apps view on XLarge displays to not take up more space then it needs. Width         * is still not allowed to be set as WRAP_CONTENT since many parts of the code expect         * each page to have the same width.         */	99672
UNKNOWN	// The children are given the same width and height as the workspace	99673
UNKNOWN	// unless they were set to WRAP_CONTENT	99674
UNKNOWN	// disallowing padding in paged view (just pass 0)	99675
UNKNOWN	/**     * This method should be called once before first layout / measure pass.     */	99676
UNKNOWN	// Update the viewport offsets	99677
UNKNOWN	// Prevent full screen pages from showing in the viewport	99678
UNKNOWN	// when they are not the current page.	99679
UNKNOWN	// Update the page indicator, we dont update the page indicator as we	99680
UNKNOWN	// add/remove pages	99681
UNKNOWN	// This ensures that when children are added, they get the correct transforms / alphas	99682
UNKNOWN	// in accordance with any scroll effects.	99683
UNKNOWN	// Update the page indicator, we dont update the page indicator as we	99684
UNKNOWN	// add/remove pages	99685
UNKNOWN	// XXX: We should find a better way to hook into this before the view	99686
UNKNOWN	// gets removed form its parent...	99687
UNKNOWN	// XXX: We should find a better way to hook into this before the view	99688
UNKNOWN	// gets removed form its parent...	99689
UNKNOWN	// XXX: We should find a better way to hook into this before the view	99690
UNKNOWN	// gets removed form its parent...	99691
UNKNOWN	// Update the page indicator, we dont update the page indicator as we	99692
UNKNOWN	// add/remove pages	99693
UNKNOWN	// Find out which screens are visible; as an optimization we only call draw on them	99694
UNKNOWN	// mOverScrollX is equal to getScrollX() when were within the normal scroll range.	99695
UNKNOWN	// Otherwise it is equal to the scaled overscroll position.	99696
UNKNOWN	// set mForceScreenScrolled before calling screenScrolled so that screenScrolled can	99697
UNKNOWN	// set it for the next frame	99698
UNKNOWN	// Clip to the bounds	99699
UNKNOWN	// Draw all the children, leaving the drag view for last	99700
UNKNOWN	// Draw the drag view on top (if there is one)	99701
UNKNOWN	// XXX-RTL: This will be fixed in a future CL	99702
UNKNOWN	// XXX-RTL: This will be fixed in a future CL	99703
UNKNOWN	/**     * If one of our descendant views decides that it could be focused now, only     * pass that along if its on the current page.     *     * This happens when live folders requery, and if theyre off page, they     * end up calling requestFocus, which pulls it on page.     */	99704
UNKNOWN	/**     * {@inheritDoc}     */	99705
UNKNOWN	// We need to make sure to cancel our long press if	99706
UNKNOWN	// a scrollable widget takes over touch events	99707
UNKNOWN	/**     * Return true if a tap at (x, y) should trigger a flip to the previous page.     */	99708
UNKNOWN	/**     * Return true if a tap at (x, y) should trigger a flip to the next page.     */	99709
UNKNOWN	/** Returns whether x and y originated within the buffered viewport */	99710
UNKNOWN	/*         * This method JUST determines whether we want to intercept the motion.         * If we return true, onTouchEvent will be called and we do the actual         * scrolling there.         */	99711
UNKNOWN	// Skip touch handling if there are no pages to swipe	99712
UNKNOWN	/*         * Shortcut the most recurring case: the user is in the dragging         * state and he is moving his finger.  We want to intercept this         * motion.         */	99713
UNKNOWN	/*                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check                 * whether the user has moved far enough from his original down touch.                 */	99714
UNKNOWN	// if mActivePointerId is INVALID_POINTER, then we must have missed an ACTION_DOWN	99715
UNKNOWN	// event. in that case, treat the first occurence of a move event as a ACTION_DOWN	99716
UNKNOWN	// i.e. fall through to the next case (dont break)	99717
UNKNOWN	// (We sometimes miss ACTION_DOWN events in Workspace because it ignores all events	99718
UNKNOWN	// while its small- this was causing a crash before we checked for INVALID_POINTER)	99719
UNKNOWN	// Remember location of down touch	99720
UNKNOWN	/*                 * If being flinged and user touches the screen, initiate drag;                 * otherwise dont.  mScroller.isFinished should be false when                 * being flinged.                 */	99721
UNKNOWN	// check if this can be the beginning of a tap on the side of the pages	99722
UNKNOWN	// to scroll the current page	99723
UNKNOWN	/*         * The only time we want to intercept motion events is if we are in the         * drag mode.         */	99724
UNKNOWN	/*     * Determines if we should change the touch state to start scrolling after the     * user moves their touch point too far.     */	99725
UNKNOWN	// Disallow scrolling if we dont have a valid pointer index	99726
UNKNOWN	// Disallow scrolling if we started the gesture from outside the viewport	99727
UNKNOWN	// Scroll if the user moved far enough along the X axis	99728
UNKNOWN	//mAllowLongPress = false;	99729
UNKNOWN	// Try canceling the long press. It could also have been scheduled	99730
UNKNOWN	// by a distant descendant, so use the mAllowLongPress flag to block	99731
UNKNOWN	// everything	99732
UNKNOWN	// While layout transitions are occurring, a childs position may stray from its baseline	99733
UNKNOWN	// position. This method returns the magnitude of this stray at any given time.	99734
UNKNOWN	// This curve determines how the effect of scrolling over the limits of the page dimishes	99735
UNKNOWN	// as the user pulls further and further from the bounds	99736
UNKNOWN	// We want to reach the max over scroll effect when the user has	99737
UNKNOWN	// over scrolled half the size of the screen	99738
UNKNOWN	// Clamp this factor, f, to -1 < f < 1	99739
UNKNOWN	// Clamp this factor, f, to -1 < f < 1	99740
UNKNOWN	// Using the formula in overScroll, assuming that f = 1.0 (which it should generally not	99741
UNKNOWN	// exceed). Used to find out how much extra wallpaper we need for the over scroll effect	99742
UNKNOWN	// Skip touch handling if there are no pages to swipe	99743
UNKNOWN	/*             * If being flinged and user touches, stop the fling. isFinished             * will be false if being flinged.             */	99744
UNKNOWN	// Remember where the motion event started	99745
UNKNOWN	// Scroll to follow the motion event	99746
UNKNOWN	// Only scroll and update mLastMotionX if we have moved some discrete amount.  We	99747
UNKNOWN	// keep the remainder because we are actually testing if weve moved from the last	99748
UNKNOWN	// scrolled position (which is discrete).	99749
UNKNOWN	// Update the last motion position	99750
UNKNOWN	// Update the parent down so that our zoom animations take this new movement into	99751
UNKNOWN	// account	99752
UNKNOWN	// Find the closest page to the touch point	99753
UNKNOWN	// Change the drag view if we are hovering over the drop target	99754
UNKNOWN	// Setup the scroll to the correct page before we swap the views	99755
UNKNOWN	// For each of the pages between the paged view and the drag view,	99756
UNKNOWN	// animate them from the previous position to the new position in	99757
UNKNOWN	// the layout (as a result of the drag view moving in the layout)	99758
UNKNOWN	// dragViewIndex < pageUnderPointIndex, so after we remove the	99759
UNKNOWN	// drag view all subsequent views to pageUnderPointIndex will	99760
UNKNOWN	// shift down.	99761
UNKNOWN	// Animate the view translation from its old position to its new	99762
UNKNOWN	// position	99763
UNKNOWN	// In the case that the page is moved far to one direction and then is flung	99764
UNKNOWN	// in the opposite direction, we use a threshold to determine whether we should	99765
UNKNOWN	// just return to the starting page, or if we should skip one further.	99766
UNKNOWN	// We give flings precedence over large moves, which is why we short-circuit our	99767
UNKNOWN	// test for a large move if a fling has been registered. That is, a large	99768
UNKNOWN	// move to the left and fling to the right will register as a fling to the right.	99769
UNKNOWN	// at this point we have not moved beyond the touch slop	99770
UNKNOWN	// (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so	99771
UNKNOWN	// we can just page	99772
UNKNOWN	// at this point we have not moved beyond the touch slop	99773
UNKNOWN	// (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so	99774
UNKNOWN	// we can just page	99775
UNKNOWN	// Update the last motion position	99776
UNKNOWN	// Update the parent down so that our zoom animations take this new movement into	99777
UNKNOWN	// account	99778
UNKNOWN	// Check the velocity and see if we are flinging-to-delete	99779
UNKNOWN	// Remove the callback to wait for the side page hover timeout	99780
UNKNOWN	// End any intermediate reordering states	99781
UNKNOWN	// Setup the scroll to the correct page before we swap the views	99782
UNKNOWN	// For each of the pages between the paged view and the drag view,	99783
UNKNOWN	// animate them from the previous position to the new position in	99784
UNKNOWN	// the layout (as a result of the drag view moving in the layout)	99785
UNKNOWN	// dragViewIndex < pageUnderPointIndex, so after we remove the	99786
UNKNOWN	// drag view all subsequent views to pageUnderPointIndex will	99787
UNKNOWN	// shift down.	99788
UNKNOWN	// Animate the view translation from its old position to its new	99789
UNKNOWN	// position	99790
UNKNOWN	// Handle mouse (or ext. device) by shifting the page depending on the scroll	99791
UNKNOWN	// This was our active pointer going up. Choose a new	99792
UNKNOWN	// active pointer and adjust accordingly.	99793
UNKNOWN	// TODO: Make this decision more intelligent.	99794
UNKNOWN	// We want the duration of the page snap animation to be influenced by the distance that	99795
UNKNOWN	// the screen has to travel, however, we dont want this duration to be effected in a	99796
UNKNOWN	// purely linear fashion. Instead, we use this method to moderate the effect that the distance	99797
UNKNOWN	// of travel has on the overall snap duration.	99798
UNKNOWN	// center the values about 0.	99799
UNKNOWN	// If the velocity is low enough, then treat this more as an automatic page advance	99800
UNKNOWN	// as opposed to an apparent physical response to flinging	99801
UNKNOWN	// Here we compute a distance that will be used in the computation of the overall	99802
UNKNOWN	// snap duration. This is a function of the actual distance that needs to be traveled;	99803
UNKNOWN	// we keep this value close to half screen size in order to reduce the variance in snap	99804
UNKNOWN	// duration as a function of the distance the page needs to travel.	99805
UNKNOWN	// we want the pages snap velocity to approximately match the velocity at which the	99806
UNKNOWN	// user flings, so we scale the duration by a value near to the derivative of the scroll	99807
UNKNOWN	// interpolator at zero, ie. 5. We use 4 to make it a little slower.	99808
UNKNOWN	// Trigger a compute() to finish switching pages if necessary	99809
UNKNOWN	// Defer loading associated pages until the scroll settles	99810
UNKNOWN	/**     * @return True is long presses are still allowed for the current touch     */	99811
UNKNOWN	/**     * Set true to allow long-press events to be triggered, usually checked by     * {@link Launcher} to accept or block dpad-initiated long-presses.     */	99812
UNKNOWN	// First, clear any pages that should no longer be loaded	99813
UNKNOWN	// Next, load any new pages	99814
UNKNOWN	// Force all scrolling-related behavior to end	99815
UNKNOWN	// Update all the pages	99816
UNKNOWN	// We must force a measure after weve loaded the pages to update the content width and	99817
UNKNOWN	// Set a new page as the current page if necessary	99819
UNKNOWN	// Mark each of the pages as dirty	99820
UNKNOWN	// Load any pages that are necessary for the current window of views	99821
UNKNOWN	// If the page is moving, then snap it to the final position to ensure we dont get	99822
UNKNOWN	// stuck between pages	99823
UNKNOWN	// Animate the drag view back to the original position	99824
UNKNOWN	// Set the touch state to reordering (allows snapping to pages, dragging a child, etc.)	99825
UNKNOWN	// We must invalidate to trigger a redraw to update the layers such that the drag view	99826
UNKNOWN	// is always drawn on top	99827
UNKNOWN	// Trigger the callback when reordering has settled	99828
UNKNOWN	// Check if we are within the reordering range	99829
UNKNOWN	// Find the drag view under the pointer	99830
UNKNOWN	// For simplicity, we call endReordering sometimes even if reordering was never started.	99831
UNKNOWN	// In that case, we dont want to do anything.	99832
UNKNOWN	// If we havent flung-to-delete the current child, then we just animate the drag view	99833
UNKNOWN	// back into position	99834
UNKNOWN	// Snap to the current page	99835
UNKNOWN	// Animate the drag view back to the front position	99836
UNKNOWN	// Handled in post-delete-animation-callbacks	99837
UNKNOWN	/*     * Flinging to delete - IN PROGRESS     */	99838
UNKNOWN	// Do a quick dot product test to ensure that we are flinging upwards	99839
UNKNOWN	// For each of the pages around the drag view, animate them from the previous	99840
UNKNOWN	// position to the new position in the layout (as a result of the drag view moving	99841
UNKNOWN	// in the layout)	99842
UNKNOWN	// NOTE: We can make an assumption here because we have side-bound pages that we	99843
UNKNOWN	//       will always have pages to animate in from the left	99844
UNKNOWN	// Setup the scroll to the correct page before we swap the views	99845
UNKNOWN	// dragViewIndex < pageUnderPointIndex, so after we remove the	99846
UNKNOWN	// drag view all subsequent views to pageUnderPointIndex will	99847
UNKNOWN	// shift down.	99848
UNKNOWN	// Simulate the page being offscreen with the page spacing	99849
UNKNOWN	// Animate the view translation from its old position to its new	99850
UNKNOWN	// position	99851
UNKNOWN	// Note: Hacky, but we want to skip any optimizations to not draw completely	99852
UNKNOWN	// hidden views	99853
UNKNOWN	// For each of the pages around the drag view, animate them from the previous	99854
UNKNOWN	// position to the new position in the layout (as a result of the drag view moving	99855
UNKNOWN	// in the layout)	99856
UNKNOWN	// NOTE: We can make an assumption here because we have side-bound pages that we	99857
UNKNOWN	//       will always have pages to animate in from the left	99858
UNKNOWN	// Setup the scroll to the correct page before we swap the views	99859
UNKNOWN	// dragViewIndex < pageUnderPointIndex, so after we remove the	99860
UNKNOWN	// drag view all subsequent views to pageUnderPointIndex will	99861
UNKNOWN	// shift down.	99862
UNKNOWN	// Simulate the page being offscreen with the page spacing	99863
UNKNOWN	// Animate the view translation from its old position to its new	99864
UNKNOWN	// position	99865
UNKNOWN	// Note: Hacky, but we want to skip any optimizations to not draw completely	99866
UNKNOWN	// hidden views	99867
UNKNOWN	// NOTE: Because it takes time for the first frame of animation to actually be	99868
UNKNOWN	// called and we expect the animation to be a continuation of the fling, we have	99869
UNKNOWN	// to account for the time that has elapsed since the fling finished.  And since	99870
UNKNOWN	// we dont have a startDelay, we will always get call to update when we call	99871
UNKNOWN	// start() (which we want to ignore).	99872
UNKNOWN	/* Anonymous inner class ctor */	99873
UNKNOWN	// Create and start the animation	99874
UNKNOWN	/* Drag to delete */	99875
UNKNOWN	// Create and start the complex animation	99876
UNKNOWN	/* Accessibility */	99877
UNKNOWN	// Dont let the view send real scroll events.	99878
UNKNOWN	// refactor the limits	99879
UNKNOWN	// update the information	99880
UNKNOWN	// clear the current state	99881
UNKNOWN	// add application to the bag	99882
UNKNOWN	// update the information	99883
UNKNOWN	// obtain the cached app information	99884
UNKNOWN	// if does not exist, create one	99885
UNKNOWN	// increment count	99886
UNKNOWN	// set the current time for the last execution	99887
UNKNOWN	// update the informations	99888
UNKNOWN	// obtain the cached app information	99889
UNKNOWN	// if does not exist, create one	99890
UNKNOWN	// obtain the cached app information	99891
UNKNOWN	// if does not exist, create one	99892
UNKNOWN	// set the current time for the last execution	99893
UNKNOWN	// obtain the cached app information	99894
UNKNOWN	// if does not exist, create one	99895
UNKNOWN	// obtain the cached app information	99896
UNKNOWN	//update age	99897
UNKNOWN	// remove data	99898
UNKNOWN	// if does not exist return	99899
UNKNOWN	// if its being used in the lists refactor the lists	99900
UNKNOWN	// most used	99901
UNKNOWN	// calculate the most used	99902
UNKNOWN	// calculate the most recent	99903
UNKNOWN	// update the recent apps	99911
UNKNOWN	// Process the most used apps	99912
UNKNOWN	// Called once the last instance of your widget is removed from the	99904
UNKNOWN	// homescreen	99905
UNKNOWN	// Widget instance is removed from the homescreen	99906
UNKNOWN	// Obtain appropriate widget and update it.	99907
UNKNOWN	// get the widgets	99908
UNKNOWN	// clear the current data	99909
UNKNOWN	// obtain the current data saved	99910
UNKNOWN	// if no information is available log it and continue	99913
UNKNOWN	// update the code	99914
UNKNOWN	// if no information is available log it and continue	99915
UNKNOWN	// update the code	99916
UNKNOWN	// generate the mostUsed row	99917
UNKNOWN	// get app icon and label	99918
UNKNOWN	// debug String with app count	99919
UNKNOWN	// generate the mostUsed row	99920
UNKNOWN	// get application icon and label	99921
UNKNOWN	// debug String with app count	99922
UNKNOWN	// create the intent for this app	99923
UNKNOWN	/*     * (non-Javadoc)     *      * @see     * android.appwidget.AppWidgetProvider#onUpdate(android.content.Context,     * android.appwidget.AppWidgetManager, int[])     *      * OnUpdate ==============================================================     * context The Context in which this receiver is running. appWidgetManager A     * AppWidgetManager object you can call updateAppWidget(ComponentName,     * RemoteViews) on. appWidgetIds The appWidgetIds for which an update is     * needed. Note that this may be all of the AppWidget instances for this     * provider, or just a subset of them.     */	99924
UNKNOWN	// Called in response to the ACTION_APPWIDGET_UPDATE broadcast when this	99925
UNKNOWN	// AppWidget provider	99926
UNKNOWN	// is being asked to provide RemoteViews for a set of AppWidgets.	99927
UNKNOWN	// Override this method to implement your own AppWidget functionality.	99928
UNKNOWN	// update the widget data	99929
UNKNOWN	// Called once the last instance of your widget is removed from the	99930
UNKNOWN	// homescreen	99931
UNKNOWN	// Widget instance is removed from the homescreen	99932
UNKNOWN	// Obtain appropriate widget and update it.	99933
UNKNOWN	// get the widgets	99934
UNKNOWN	/*     * (non-Javadoc)     *      * @see     * android.appwidget.AppWidgetProvider#onUpdate(android.content.Context,     * android.appwidget.AppWidgetManager, int[])     *      * OnUpdate ==============================================================     * context The Context in which this receiver is running. appWidgetManager A     * AppWidgetManager object you can call updateAppWidget(ComponentName,     * RemoteViews) on. appWidgetIds The appWidgetIds for which an update is     * needed. Note that this may be all of the AppWidget instances for this     * provider, or just a subset of them.     */	99935
UNKNOWN	// Called in response to the ACTION_APPWIDGET_UPDATE broadcast when this	99936
UNKNOWN	// AppWidget provider	99937
UNKNOWN	// is being asked to provide RemoteViews for a set of AppWidgets.	99938
UNKNOWN	// Override this method to implement your own AppWidget functionality.	99939
UNKNOWN	// update the widget data	99940
UNKNOWN	// Delete everything	99949
UNKNOWN	// SELECT query	99950
UNKNOWN	// args to SELECT query	99951
UNKNOWN	// SELECT query	99952
UNKNOWN	// args to SELECT query	99953
UNKNOWN	// SELECT query	99954
UNKNOWN	// args to SELECT query	99955
UNKNOWN	// SELECT query	99956
UNKNOWN	// args to SELECT query	99957
UNKNOWN	// cols to return	99958
UNKNOWN	// select query	99959
UNKNOWN	// args to select query	99960
UNKNOWN	// Load the preview image if possible	99961
UNKNOWN	//noinspection UnusedAssignment	99962
UNKNOWN	// check if the package is valid	99941
UNKNOWN	// check if it exists in our existing cache	99942
UNKNOWN	// not in cache; we need to load it from the db	99943
UNKNOWN	// its not in the db... we need to generate it	99944
UNKNOWN	// write to db on a thread pool... this can be done lazily and improves the performance	99945
UNKNOWN	// of the first time widget previews are loaded	99946
UNKNOWN	// Delete all the records; theyll be repopulated as this is a cache	99947
UNKNOWN	// should cache the string builder	99948
UNKNOWN	// Generate a preview image if we couldnt load one	99963
UNKNOWN	// This Drawable is not directly drawn, so theres no need to mutate it.	99964
UNKNOWN	// Draw the icon in the top left corner	99965
UNKNOWN	// Scale to fit width only - let the widget preview be clipped in the	99966
UNKNOWN	// vertical dimension	99967
UNKNOWN	// If a bitmap is passed in, we use it; otherwise, we create a bitmap of the right size	99968
UNKNOWN	// Draw the scaled preview into the final bitmap	99969
UNKNOWN	// Render the icon	99970
UNKNOWN	// Draw a desaturated/scaled version of the icon in the background as a watermark	99971
UNKNOWN	// Restore the bounds	99972
UNKNOWN	/**     * Dumps all files that are open in this process without allocating a file descriptor.     */	99973
UNKNOWN	// This is a gigantic hack but unfortunately the only way to resolve an fd	99974
UNKNOWN	// to a file name. Note that we have to loop over all possible fds because	99975
UNKNOWN	// reading the directory would require allocating a new fd. The kernel is	99976
UNKNOWN	// currently implemented such that no fd is larger then the current rlimit,	99977
UNKNOWN	// which is why its safe to loop over them in such a way.	99978
UNKNOWN	// getCanonicalPath() uses readlink behind the scene which doesnt require	99979
UNKNOWN	// a file descriptor.	99980
UNKNOWN	// Those are the files that dont point anywhere on the file system.	99981
UNKNOWN	// getCanonicalPath() wrongly interprets these as relative symlinks and	99982
UNKNOWN	// resolves them within /proc/<pid>/fd/.	99983
UNKNOWN	// Ignoring exceptions for non-existing file descriptors.	99984
UNKNOWN	// Catch everything. This is called from an exception handler that we shouldnt upset.	99985
UNKNOWN	// Delete all the records; theyll be repopulated as this is a cache	99986
UNKNOWN	/**     * Returns true if {@param srcPackage} has the permission required to start the activity from     * {@param intent}. If {@param srcPackage} is null, then the activity should not need     * any permissions     */	99987
UNKNOWN	// Not a valid target	99988
UNKNOWN	// No permission is needed	99989
UNKNOWN	// The activity requires some permission but there is no source.	99990
UNKNOWN	// Source does not have sufficient permissions.	99991
UNKNOWN	/* We have to fix that once we go to M */	99992
UNKNOWN	// if (!Utilities.ATLEAST_MARSHMALLOW) {	99993
UNKNOWN	//     // These checks are sufficient for below M devices.	99994
UNKNOWN	//     return true;	99995
UNKNOWN	// }	99996
UNKNOWN	// 	99997
UNKNOWN	// // On M and above also check AppOpsManager for compatibility mode permissions.	99998
UNKNOWN	// if (TextUtils.isEmpty(AppOpsManager.permissionToOp(target.activityInfo.permission))) {	99999
UNKNOWN	//     // There is no app-op for this permission, which could have been disabled.	100000
UNKNOWN	//     return true;	100001
UNKNOWN	// }	100002
UNKNOWN	// 	100003
UNKNOWN	// // There is no direct way to check if the app-op is allowed for a particular app. Since	100004
UNKNOWN	// // app-op is only enabled for apps running in compatibility mode, simply block such apps.	100005
UNKNOWN	// 	100006
UNKNOWN	// try {	100007
UNKNOWN	//     return pm.getApplicationInfo(srcPackage, 0).targetSdkVersion >= Build.VERSION_CODES.M;	100008
UNKNOWN	// } catch (NameNotFoundException e) { }	100009
UNKNOWN	// 	100010
UNKNOWN	// return false;	100011
UNKNOWN	/**	 * Serializes a component in order to be used has a map key	 * @param componentName component to serialize	 * @return the serialized component	 */	100012
UNKNOWN	/**	 * Transforms a string into a ComponentName	 * @param componentNameString serialized component	 * @return the ComponentName object	 */	100013
UNKNOWN	// get the current prefs and clear to update	100014
UNKNOWN	/**     * Get the singleton instance of the fonts manager.     */	100015
UNKNOWN	/**     * Setup the fonts used within the application.     */	100016
UNKNOWN	// recursive search	100017
UNKNOWN	//                setupTheVideo();	100018
UNKNOWN	//                setupDefinitionsSteps();	100019
UNKNOWN	//setupEdgeGlowTutorialSteps();	100020
UNKNOWN	// button	100021
UNKNOWN	// increment the step counter	100022
UNKNOWN	// increment the step counter	100023
UNKNOWN	// decrement the step counter	100024
UNKNOWN	// increment the step counter	100025
UNKNOWN	// decrement the step counter	100026
UNKNOWN	//mMainBackground.setBackgroundResource(R.color.oobe_background);	100027
UNKNOWN	//startAnimation(new EdgeGlowTutorialAnimationHelper());	100028
UNKNOWN	//setTextView(mOOBETextGroup10);	100029
UNKNOWN	/* mNextButton.setVisibility(visibilityNext);        mBackButton.setVisibility(visibilityBack);        mStartButton.setVisibility(visibilityStart);        mSkipButton.setVisibility(visibilitySkip);*/	100030
UNKNOWN	//            Log.i(, send change locale request);	100031
UNKNOWN	//alphaAnim.addKeyframe(0, 1600, null);	100032
UNKNOWN	//alphaAnim.addKeyframe(0, 2000, null);	100033
UNKNOWN	// - DynamicGrid.pxFromDp(110, mDisplayMetrics);	100034
UNKNOWN	// - DynamicGrid.pxFromDp(110, mDisplayMetrics);	100035
UNKNOWN	//textEditAnimationOff.setFillAfter(true);	100036
UNKNOWN	/*titleView.animate().alpha(0f).setDuration(1000).setListener(null);        titleView.animate().alpha(1f).setDuration(1000).setListener(null);        textView.animate().alpha(1f).setStartDelay(10000).setDuration(400000).setListener(null);*/	100037
UNKNOWN	// editView.startAnimation(textEditAnimation);	100038
UNKNOWN	//spriteRoot.addChild(spriteHandShadow);	100039
UNKNOWN	//spriteMenu.addChild(spriteAppIconSelected);	100040
UNKNOWN	// Animation setup	100041
UNKNOWN	// Animation setup	100042
UNKNOWN	/**     * **************************************     * <p/>     * setupRemoveFavAnimation()     * <p/>     * ***************************************     */	100043
UNKNOWN	/**     * **************************************     * <p/>     * setupAddFavAnimation()     * <p/>     * ***************************************     */	100044
UNKNOWN	/**     * **************************************     * <p/>     * setupMoveFavAnimation()     * <p/>     * ***************************************     */	100045
UNKNOWN	//alphaAnim.addKeyframe(1, 4250, null);	100046
UNKNOWN	//xAnim.addKeyframe(((SCREEN_WIDTH/2) + DynamicGrid.pxFromDp(50f,mDisplayMetrics)), 1500, null);	100047
UNKNOWN	//xAnim.addKeyframe(((SCREEN_WIDTH/2) + DynamicGrid.pxFromDp(50f,mDisplayMetrics)), 1500, null);	100048
UNKNOWN	/* scaleAnim.addKeyframe(1f, 2600, null);        scaleAnim.addKeyframe(20.0f, 4000, decelerateInterpolator);*/	100049
UNKNOWN	// + DynamicGrid.pxFromDp(77f,mDisplayMetrics);	100050
UNKNOWN	// + DynamicGrid.pxFromDp(77f,mDisplayMetrics);	100051
UNKNOWN	/* (non-Javadoc)	 * @see java.lang.Object#hashCode()	 */	100052
UNKNOWN	/* (non-Javadoc)	 * @see java.lang.Object#equals(java.lang.Object)	 */	100053
UNKNOWN	/**     * Load the favorites apps from the shared preferences and get the Android     * application info from each, so we can get the app name and icon.     */	100054
UNKNOWN	/**     * Store the selected apps in the shared preferences as strings which is the     * package names of the apps. The package name of an app serves as the     * unique identifier of the app.     */	100055
UNKNOWN	/**     * Convert string array into a single string, where each element in the     * string array is separated by the delimiter string.     */	100056
UNKNOWN	/**     * Convert a string into an array of strings, using the delimiter as     * separator.     */	100057
UNKNOWN	// Defines a variable to store the action type for the incoming	100058
UNKNOWN	// event	100059
UNKNOWN	// Handles each of the expected events	100060
UNKNOWN	// Moving an icon to an occupied position replaces the	100061
UNKNOWN	// current one	100062
UNKNOWN	// toggle the red glow when removing favorites	100063
UNKNOWN	// get the Item data	100064
UNKNOWN	// 0 is the origin	100065
UNKNOWN	// 1 is the index	100066
UNKNOWN	// obtain the applicationInfo	100067
UNKNOWN	// when not removing an icon swap is performed	100068
UNKNOWN	// remove the favorite	100069
UNKNOWN	// only setup the icon if a valid id is obtained	100070
UNKNOWN	// hide zone remove zone	100071
UNKNOWN	//are we dragging mostly to the right?	100072
UNKNOWN	// Subtract the number of columns in order to get the correct item	100073
UNKNOWN	// due to the header	100074
UNKNOWN	// Set the listener	100086
UNKNOWN	/**     * Setup the list with all the apps installed on the device.     */	100075
UNKNOWN	// set the drag listener to enable favorite icon removal	100076
UNKNOWN	// display a circle around the possible destinations	100077
UNKNOWN	// set the item with the origin of the drag and the index of the dragged	100078
UNKNOWN	// view	100079
UNKNOWN	/**     * Setup the list with the selected app list, which is the holder of the     * apps that has been selected to become the favorite apps.     */	100080
UNKNOWN	// set the listeners	100081
UNKNOWN	// The last argument is set to false since this hasnt the ability	100082
UNKNOWN	// to remove icons, it only switches them	100083
UNKNOWN	// Log.d(TAG, Adding app :  +	100084
UNKNOWN	// applicationInfo.getApplicationTitle());	100085
UNKNOWN	// pass the main view and the instance setup the drag and visibility	100087
UNKNOWN	// of some views	100088
UNKNOWN	/**     * Update the icon and label of a favorite     *      * @param applicationInfo     *            App information that contains the icon and label     * @param icon     *            the icon to update     */	100089
UNKNOWN	/**     * Performs the animation when replacing one favorite     *      * @param viewToFadeIn     *            view that will appear. When null it means that we are swapping     *            two favorites     * @param viewToFadeOut     *            view that will disappear.     * @param applicationInfo     *            app info that is used to swap two favorites     */	100090
UNKNOWN	// get the new icon	100091
UNKNOWN	// get the new icon	100092
UNKNOWN	/**     * Capture the back button press, to make sure we save the selected apps     * before exiting.     */	100093
UNKNOWN	/**     * Serializes the item id and origin that is being dragged.     *      * @param appOrigin     *            the origin: can be SELECT_APPS_DRAG or ALL_APPS_DRAG     * @param appIndex     *            the item index     * @return the serialized item info     */	100094
UNKNOWN	/**     * Deserializes the item id and origin that is being dragged.     *      * @param toDeserialize     *            string to deserialize     * @return an array containing {appOrign, appIndex}     */	100095
UNKNOWN	// Show the zone where favorites can be removed	100096
UNKNOWN	// display a circle around the possible destinations	100097
UNKNOWN	// set the drag info	100098
UNKNOWN	// set the item with the origin of the drag and the index of the	100099
UNKNOWN	// dragged view	100100
UNKNOWN	// hide the circle around the possible destinations	100101
UNKNOWN	// the red glow only makes sense when removing favorites	100102
UNKNOWN	/**     * Displays a background on the favorite possible positions when configuring     * it     *      * @param selectedFavorite     *            the favorite position where the background will not be shown.     *            -1 means that all backgrounds will be shown.     * @param showBackground     *            true: displays the background; false: removes the background     */	100103
UNKNOWN	// to avoid the addition of Fairphone home launcher to	100104
UNKNOWN	// appSwitcher	100105
UNKNOWN	// CHECKS IF THE ANIMATION IS STARTING FROM THE LEFT OR RIGHT	100106
UNKNOWN	// TODO: CAtch the onMeasure and setup the correct sizes after that,	100107
UNKNOWN	// for now just calculate the initial size	100108
UNKNOWN	// IF ALL APPS ICON	100109
UNKNOWN	// Set the right ComponentName in order to launch Dialer	100110
UNKNOWN	// or Contacts correctly	100111
UNKNOWN	// WHEN THE USER SETS THE FINGER ON AN ITEM	100112
UNKNOWN	// IF ALL APPS ICON	100113
UNKNOWN	// CHECKS IF THE ANIMATION IS STARTING FROM THE LEFT OR RIGHT	100114
UNKNOWN	// IF ALL APPS ICON	100115
UNKNOWN	// set edit menu button timer	100116
UNKNOWN	// set the X coords	100117
UNKNOWN	// Defines local variables	100118
UNKNOWN	//Calculate the canvas size 	100119
UNKNOWN	// The drag shadow is a ColorDrawable. This sets its dimensions to	100120
UNKNOWN	// be the same as the	100121
UNKNOWN	// Canvas that the system will provide. As a result, the drag shadow	100122
UNKNOWN	// will fill the	100123
UNKNOWN	// Canvas.	100124
UNKNOWN	// Sets the size parameters width and height values. These get back	100125
UNKNOWN	// to the system	100126
UNKNOWN	// through the size parameter.	100127
UNKNOWN	// Sets the touch points position to be in the middle of the drag	100128
UNKNOWN	// shadow	100129
UNKNOWN	// Defines a callback that draws the drag shadow in a Canvas that the	100130
UNKNOWN	// system constructs	100131
UNKNOWN	// from the dimensions passed in onProvideShadowMetrics().	100132
UNKNOWN	// Draws the ColorDrawable in the Canvas passed in from the system.	100133
UNKNOWN	// shadow.draw(canvas);	100134
UNKNOWN	// Add a user badge in the bottom right of the image.	100135
UNKNOWN	// Return default icon below.	100136
UNKNOWN	//Guardo la referencia del scroll para poder usar ambos	100137
UNKNOWN	//Registramos un DataSetObserver para que cuando se produzcan cambios en el adaptador original lo podamos reflejar	100138
UNKNOWN	//en el fakeAdapter	100139
UNKNOWN	/**     * Adds the header view     *      * @param v     *            la vista     * @param data     *            extra data     * @param isSelectable     *            foo     */	100140
UNKNOWN	/**     * Aade la vista al layout     *      * @param v     */	100141
UNKNOWN	/**     * Nos indica si la cabecera se pinta por delante o por detrs del scroll de     * la lista     *      * @return boolean     */	100142
UNKNOWN	/**     * Define si la cabecera se pinta por delante del scroll o si el scroll va     * por encima y la cabecera est fija     *      * @param Boolean     *            isInFront     */	100143
UNKNOWN	/**     * Permite cambiar entre una cabecera fija o scrollable     *      * @param Boolean     *            fixed     */	100144
UNKNOWN	//Para evitar ciclos infinitos de onDraw / drawHeaders porque si en onDraw le pongo el topMargin efecta	100145
UNKNOWN	//repintado, entonces llama a drawHeaders y as....	100146
UNKNOWN	/**     * Elimina la cabecera     */	100147
UNKNOWN	// they sent us a bad intent	100148
UNKNOWN	// else, we are replacing the package, so a PACKAGE_ADDED will be sent	100149
UNKNOWN	// later, we will update the package at this time	100150
UNKNOWN	// EXTRA_REPLACING is available Kitkat onwards. For lower devices, it is broadcasted	100151
UNKNOWN	// when moving a package or mounting/un-mounting external storage. Assume that	100152
UNKNOWN	// it is a replacing operation.	100153
UNKNOWN	// they sent us a bad intent	100154
UNKNOWN	// else, we are replacing the package, so a PACKAGE_ADDED will be sent	100155
UNKNOWN	// later, we will update the package at this time	100156
UNKNOWN	// EXTRA_REPLACING is available Kitkat onwards. For lower devices, it is broadcasted	100157
UNKNOWN	// when moving a package or mounting/un-mounting external storage. Assume that	100158
UNKNOWN	// it is a replacing operation.	100159
UNKNOWN	// try again later	100163
UNKNOWN	// try again later	100160
UNKNOWN	/**     * This should be called by the implementations to register a package update.     */	100161
UNKNOWN	// no longer necessary to track this package	100162
UNKNOWN	/**     * Adds {@link UserHandle} to the intent in for L or above.     * Pre-L the launcher doesnt support showing apps for multiple     * profiles so this is a no-op.     */	100164
UNKNOWN	// No op	100165
UNKNOWN	// Called on mWorker thread.	100166
UNKNOWN	// Not yet ready	100167
UNKNOWN	// Nothing to update	100168
UNKNOWN	// Try again later	100169
UNKNOWN	// Replay all updates with a one time update for this installed package. No	100170
UNKNOWN	// need to store this record for future updates, as the app list will get	100171
UNKNOWN	// refreshed on resume.	100172
UNKNOWN	// 1 is top	100173
UNKNOWN	// The great Android hackatlon, the love, the magic.	100174
UNKNOWN	// The two leftmost bits in the height measure spec have	100175
UNKNOWN	// a special meaning, hence we cant use them to describe height.	100176
UNKNOWN	// Any other height should be respected as is.	100177
UNKNOWN	/**     * Setup the list with all the apps installed on the device.     *     * @param view     */	100178
UNKNOWN	//fire the easter egg	100179
UNKNOWN	//fire the easter egg	100180
UNKNOWN	//Redraw the drawer	100181
UNKNOWN	//Redraw the drawer	100182
UNKNOWN	/**     * Clean up after dragging.     *     * @param target where the item was dragged to (can be null if the item was     *               flung)     */	100183
UNKNOWN	// Exit spring loaded mode if we have not successfully dropped or	100184
UNKNOWN	// have not handled the	100185
UNKNOWN	// drop in Workspace	100186
UNKNOWN	// We delay entering spring-loaded mode slightly to make sure the UI	100187
UNKNOWN	// thready is free of any work.	100188
UNKNOWN	// We dont enter spring-loaded mode if the drag has been	100189
UNKNOWN	// cancelled	100190
UNKNOWN	// Go into spring loaded mode (must happen before we	100191
UNKNOWN	// startDrag())	100192
UNKNOWN	// We dont enter spring-loaded mode if the drag has been	100193
UNKNOWN	// cancelled	100194
UNKNOWN	// Go into spring loaded mode (must happen before we	100195
UNKNOWN	// startDrag())	100196
UNKNOWN	// mForceDrawAllChildrenNextFrame = !toWorkspace;	100197
UNKNOWN	// Return early if this is not initiated from a touch	100198
UNKNOWN	// if (!v.isInTouchMode()) return false;	100199
UNKNOWN	// When we have exited all apps or are in transition, disregard long	100200
UNKNOWN	// clicks	100201
UNKNOWN	// if (!mLauncher.isAgingAppDrawerVisible() ||	100202
UNKNOWN	// !mLauncher.isAllAppsVisible() ||	100203
UNKNOWN	// mLauncher.getWorkspace().isSwitchingState()) return false;	100204
UNKNOWN	// // Return if global dragging is not enabled	100205
UNKNOWN	// if (!mLauncher.isDraggingEnabled()) return false;	100206
UNKNOWN	// Return early and wait for onFlingToDeleteCompleted if this was the	100207
UNKNOWN	// result of a fling	100208
UNKNOWN	// Display an error message if the drag failed due to there not being	100209
UNKNOWN	// enough space on the	100210
UNKNOWN	// target layout we were dropping on.	100211
UNKNOWN	// We just dismiss the drag when we fling, so cleanup here	100212
UNKNOWN	// otherwise it may crash	100213
UNKNOWN	//Open the searchview bar	100214
UNKNOWN	// otherwise it may crash	100215
UNKNOWN	// the final location.	100460
UNKNOWN	// Remove the affected components	100496
UNKNOWN	// Remove the current widget	100542
UNKNOWN	// estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each	100216
UNKNOWN	// dimension if unsuccessful	100217
UNKNOWN	// Use the first non-custom page to estimate the child position	100218
UNKNOWN	// Prevent any Un/InstallShortcutReceivers from updating the db while we are dragging	100219
UNKNOWN	// Re-enable any Un/InstallShortcutReceiver and now process any queued items	100220
UNKNOWN	/**     * Initializes various states for this workspace.     */	100221
UNKNOWN	// Set the wallpaper dimensions when Launcher starts up	100222
UNKNOWN	// We want to show layout transitions when pages are deleted, to close the gap.	100223
UNKNOWN	/**     * @return The open folder on the current screen, or null if there is none     */	100224
UNKNOWN	// Disable all layout transitions before removing all pages to ensure that we dont get the	100225
UNKNOWN	// transition animations competing with us changing the scroll when we add pages or the	100226
UNKNOWN	// custom content screen	100227
UNKNOWN	// Since we increment the current page when we call addCustomContentPage via bindScreens	100228
UNKNOWN	// (and other places), we need to adjust the current page back when we clear the pages	100229
UNKNOWN	// Remove the pages and clear the screen models	100230
UNKNOWN	// Re-enable the layout transitions	100231
UNKNOWN	// Find the index to insert this view into.  If the empty screen exists, then	100232
UNKNOWN	// insert it before that.	100233
UNKNOWN	// Log to disk	100234
UNKNOWN	// We want no padding on the custom content	100235
UNKNOWN	// Ensure that the current page and default page are maintained.	100236
UNKNOWN	// Update the custom content hint	100237
UNKNOWN	// Ensure that the current page and default page are maintained.	100238
UNKNOWN	// Update the custom content hint	100239
UNKNOWN	// Add the custom content to the full screen custom page	100240
UNKNOWN	// Verify that the child is removed from any existing parent.	100241
UNKNOWN	// Log to disk	100242
UNKNOWN	// Cancel any pending removal of empty screen	100243
UNKNOWN	// If this is the last item on the final screen	100244
UNKNOWN	// Log to disk	100245
UNKNOWN	// Log to disk	100246
UNKNOWN	// Invalid and dangerous operation if workspace is loading	100247
UNKNOWN	// If the final screen is empty, convert it to the extra empty screen	100248
UNKNOWN	// if this is the last non-custom content screen, convert it to the empty screen	100249
UNKNOWN	// Update the model if we have changed any screens	100250
UNKNOWN	// Log to disk	100251
UNKNOWN	// Dont strip empty screens if the workspace is still loading	100252
UNKNOWN	// If were not going to strip the empty screens after removing	100253
UNKNOWN	// the extra empty screen, do it right away.	100254
UNKNOWN	// Log to disk	100255
UNKNOWN	// XXX: Do we need to update LM workspace screens below?	100256
UNKNOWN	// Log to disk	100257
UNKNOWN	// Invalid and dangerous operation if workspace is loading	100258
UNKNOWN	// Update the page indicator marker	100259
UNKNOWN	// Update the model for the new screen	100260
UNKNOWN	// Log to disk	100261
UNKNOWN	// Dont strip empty screens if the workspace is still loading.	100262
UNKNOWN	// This is dangerous and can result in data loss.	100263
UNKNOWN	// We enforce at least one page to add new items to. In the case that we remove the last	100264
UNKNOWN	// such screen, we convert the last screen to the empty screen	100265
UNKNOWN	// if this is the last non-custom content screen, convert it to the empty screen	100266
UNKNOWN	// Update the model if we have changed any screens	100267
UNKNOWN	// See implementation for parameter definition.	100268
UNKNOWN	// At bind time, we use the rank (screenId) to compute x and y for hotseat items.	100269
UNKNOWN	// See implementation for parameter definition.	100270
UNKNOWN	// See implementation for parameter definition.	100271
UNKNOWN	/**     * Adds the specified child in the specified screen. The position and dimension of     * the child are defined by x, y, spanX and spanY.     *     * @param child The child to add in one of the workspaces screens.     * @param screenId The screen in which to add the child.     * @param x The X position of the child in the screens grid.     * @param y The Y position of the child in the screens grid.     * @param spanX The number of cells spanned horizontally by the child.     * @param spanY The number of cells spanned vertically by the child.     * @param insert When true, the child is inserted at the beginning of the children list.     * @param computeXYFromRank When true, we use the rank (stored in screenId) to compute     *                          the x and y position in which to place hotseat items. Otherwise     *                          we use the x and y position to compute the rank.     */	100272
UNKNOWN	// DEBUGGING - Print out the stack trace to see where we are adding from	100273
UNKNOWN	// This should never happen	100274
UNKNOWN	// Show folder title	100275
UNKNOWN	// Get the canonical child id to uniquely represent this view in this screen	100276
UNKNOWN	// TODO: This branch occurs when the workspace is adding views	100277
UNKNOWN	// outside of the defined grid	100278
UNKNOWN	// maybe we should be deleting these items from the LauncherModel?	100279
UNKNOWN	/**     * Called directly from a CellLayout (not by the framework), after weve been added as a     * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout     * that it should intercept touch events, which is not something that is normally supported.     */	100280
UNKNOWN	/** This differs from isSwitchingState in that we take into account how far the transition     *  has completed. */	100281
UNKNOWN	// Ignore pointer scroll events if the custom content doesnt allow scrolling.	100282
UNKNOWN	// Remove the current widget which is inflated with the wrong orientation	100283
UNKNOWN	// Pass swipes to the right to the custom content page.	100284
UNKNOWN	// Dont allow workspace scrolling if the current custom content screen doesnt allow	100285
UNKNOWN	// scrolling.	100286
UNKNOWN	// Above MAX_SWIPE_ANGLE, we dont want to ever start scrolling the workspace	100287
UNKNOWN	// Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to	100288
UNKNOWN	// increase the touch slop to make it harder to begin scrolling the workspace. This	100289
UNKNOWN	// results in vertically scrolling widgets to more easily. The higher the angle, the	100290
UNKNOWN	// more we increase touch slop.	100291
UNKNOWN	// Below START_DAMPING_TOUCH_SLOP_ANGLE, we dont do anything special	100292
UNKNOWN	// were snapping to a particular screen	100293
UNKNOWN	// this is when user is actively dragging a particular screen, they might	100294
UNKNOWN	// swipe it either left or right (but we wont advance by more than one screen)	100295
UNKNOWN	// If we are in springloaded mode, then force an event to check if the current touch	100296
UNKNOWN	// is under a new page (to scroll to)	100297
UNKNOWN	// Exclude the leftmost page	100298
UNKNOWN	// Exclude the last extra empty screen (if we have > MIN_PARALLAX_PAGE_SPAN pages)	100299
UNKNOWN	// TODO: do different behavior if its  a live wallpaper?	100300
UNKNOWN	// Sometimes the left parameter of the pages is animated during a layout transition;	100301
UNKNOWN	// this parameter offsets it to keep the wallpaper from animating as well	100302
UNKNOWN	// Dont use up all the wallpaper parallax until you have at least	100303
UNKNOWN	// MIN_PARALLAX_PAGE_SPAN pages	100304
UNKNOWN	// On RTL devices, push the wallpaper offset to the right if we dont have enough	100305
UNKNOWN	// pages (ie if numScrollingPages < MIN_PARALLAX_PAGE_SPAN)	100306
UNKNOWN	// Set wallpaper offset steps (1 / (number of screens - 1))	100307
UNKNOWN	// Dont animate if were going from 0 screens	100308
UNKNOWN	// Dont announce if apps is on top of us.	100309
UNKNOWN	//child.setBackgroundAlphaMultiplier(1 - alpha);	100310
UNKNOWN	// In case accessibility state has changed, we need to perform this on every	100311
UNKNOWN	// attach to window	100312
UNKNOWN	// Update wallpaper dimensions if they were changed since last onResume	100313
UNKNOWN	// (we also always set the wallpaper dimensions in the constructor)	100314
UNKNOWN	// Force the wallpaper offset steps to be set again, because another app might have changed	100315
UNKNOWN	// them	100316
UNKNOWN	// Call back to LauncherModel to finish binding after the first draw	100317
UNKNOWN	// In software mode, we dont want the items to continue to be drawn into bitmaps	100318
UNKNOWN	// make sure were caching at least two pages always	100319
UNKNOWN	// enable layers between left and right screen inclusive, except for the	100320
UNKNOWN	// customScreen, which may animate its content during transitions.	100321
UNKNOWN	// force layers to be enabled just for the call to buildLayer	100322
UNKNOWN	/*    *    * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we    * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace    *    * These methods mark the appropriate pages as accepting drops (which alters their visual    * appearance).    *    */	100323
UNKNOWN	// Compose a drag bitmap with the view scaled to the icon size	100324
UNKNOWN	// If this is a text view, use its drawable instead	100325
UNKNOWN	// Compose the bitmap to create the icon from	100326
UNKNOWN	// The outline is used to visualize where the item will land if dropped	100327
UNKNOWN	// The outline is used to visualize where the item will land if dropped	100328
UNKNOWN	// Reordering handles its own animations, disable the automatic ones.	100329
UNKNOWN	// Invalid and dangerous operation if workspace is loading	100330
UNKNOWN	// Re-enable auto layout transitions for page deletion.	100331
UNKNOWN	// Initialize animation arrays for the first time if necessary	100332
UNKNOWN	//getResources().getInteger(R.integer.config_workspaceUnshrinkTime);	100333
UNKNOWN	// If we are animating to/from the small state, then hide the side pages and fade the	100334
UNKNOWN	// current page in	100335
UNKNOWN	// in low power mode the animation doesnt play, so set the end value here	100336
UNKNOWN	// in low power mode the animation doesnt play,	100337
UNKNOWN	// so set the end value here	100338
UNKNOWN	// create a dummy animation so we dont need to do null checks later	100339
UNKNOWN	// For animation optimations, we may need to provide the Launcher transition	100340
UNKNOWN	// with a set of views on which to force build layers in certain scenarios.	100341
UNKNOWN	// in low power mode the animation doesnt play, so set the end value here	100342
UNKNOWN	// in low power mode the animation doesnt play,	100343
UNKNOWN	// so set the end value here	100344
UNKNOWN	// We want to avoid the extra layout pass by setting the views to GONE unless	100345
UNKNOWN	// accessibility is on, in which case not setting them to GONE causes a glitch.	100346
UNKNOWN	// We want the views to be visible for animation, so fade-in/out is visible	100347
UNKNOWN	// Invalidate here to ensure that the pages are rendered during the state change transition.	100348
UNKNOWN	/**     * Draw the View v into the given Canvas.     *     * @param v the view to draw     * @param destCanvas the canvas to draw on     * @param padding the horizontal and vertical padding to use when drawing     */	100349
UNKNOWN	// For FolderIcons the text can bleed into the icon area, and so we need to	100350
UNKNOWN	// hide the text completely (which cant be achieved by clipping).	100351
UNKNOWN	// Restore text visibility of FolderIcon if necessary	100352
UNKNOWN	/**     * Returns a new bitmap to show when the given View is being dragged around.     * Responsibility for the bitmap is transferred to the caller.     * @param expectedPadding padding to add to the drag view. If a different padding was used     * its value will be changed     */	100353
UNKNOWN	/**     * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.     * Responsibility for the bitmap is transferred to the caller.     */	100354
UNKNOWN	/**     * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.     * Responsibility for the bitmap is transferred to the caller.     */	100355
UNKNOWN	// center the image	100356
UNKNOWN	// Make sure the drag was started by a long press as opposed to a long click.	100357
UNKNOWN	// The outline is used to visualize where the item will land if dropped	100358
UNKNOWN	// The drag bitmap follows the touch point around on the screen	100359
UNKNOWN	// Note: The drag region is used to calculate drag layer offsets, but the	100360
UNKNOWN	// dragVisualizeOffset in addition to the dragRect (the size) to position the outline.	100361
UNKNOWN	// Clear the pressed state if necessary	100362
UNKNOWN	// Notify launcher of drag start	100363
UNKNOWN	// Compose a new drag bitmap that is of the icon size	100364
UNKNOWN	// Find the childs location on the screen	100365
UNKNOWN	// Note: The drag region is used to calculate drag layer offsets, but the	100366
UNKNOWN	// dragVisualizeOffset in addition to the dragRect (the size) to position the outline.	100367
UNKNOWN	// Start the drag	100368
UNKNOWN	// Recycle temporary bitmaps	100369
UNKNOWN	/**     * {@inheritDoc}     */	100370
UNKNOWN	// If its an external drop (e.g. from All Apps), check if it should be accepted	100371
UNKNOWN	// Dont accept the drop if were not over a screen at time of drop	100372
UNKNOWN	// We want the point to be mapped to the dragTarget.	100373
UNKNOWN	// Dont accept the drop if theres no room for the item	100374
UNKNOWN	// if the drag started here, we need to remove it from the workspace	100375
UNKNOWN	// If the dragView is null, we cant animate	100376
UNKNOWN	// if the drag started here, we need to remove it from the workspace	100377
UNKNOWN	// We want the point to be mapped to the dragTarget.	100378
UNKNOWN	// Move internally	100379
UNKNOWN	// First we find the cell nearest to point at which the item is	100380
UNKNOWN	// dropped, without any consideration to whether there is an item there.	100381
UNKNOWN	// If the item being dropped is a shortcut and the nearest drop	100382
UNKNOWN	// cell also contains a shortcut, then create a folder with the two shortcuts.	100383
UNKNOWN	// Aside from the special case where were dropping a shortcut onto a shortcut,	100384
UNKNOWN	// we need to find the nearest cell location that is vacant	100385
UNKNOWN	// if the widget resizes on drop	100386
UNKNOWN	// Reparent the view	100387
UNKNOWN	// update the items position after drop	100388
UNKNOWN	// We post this call so that the widget has a chance to be placed	100389
UNKNOWN	// in its final location	100390
UNKNOWN	// If we cant find a drop location, we return the item to its original position	100391
UNKNOWN	// Prepare it to be animated into its new position	100392
UNKNOWN	// This must be called after the view has been re-parented	100393
UNKNOWN	/** Return a rect that has the cellWidth/cellHeight (left, top), and     * widthGap/heightGap (right, bottom) */	100394
UNKNOWN	// Here we store the final page that will be dropped to, if the workspace in fact	100395
UNKNOWN	// receives the drop	100396
UNKNOWN	// If the user drops while the page is scrolling, we should use that page as the	100397
UNKNOWN	// destination instead of the page that is being hovered over.	100398
UNKNOWN	// Reset the scroll area and previous drag target	100399
UNKNOWN	// We dont want to cancel the re-order alarm every time the target cell changes	100400
UNKNOWN	// as this feels to slow / unresponsive.	100401
UNKNOWN	// Any pending reorders are canceled	100402
UNKNOWN	/*    *    * Convert the 2D coordinate xy from the parent Views coordinate space to this CellLayouts    * coordinate space. The argument xy is modified with the return result.    *    * if cachedInverseMatrix is not null, this method will just use that matrix instead of    * computing it itself; we use this to avoid redundant matrix inversions in    * findMatchingPageForDragOver    *    */	100403
UNKNOWN	/*    *    * Convert the 2D coordinate xy from this CellLayouts coordinate space to    * the parent Views coordinate space. The argument xy is modified with the return result.    *    */	100404
UNKNOWN	/*     *     * This method returns the CellLayout that is currently being dragged to. In order to drag     * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second     * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one     *     * Return null if no CellLayout is currently being dragged over     *     */	100405
UNKNOWN	// We loop through all the screens (ie CellLayouts) and see which ones overlap	100406
UNKNOWN	// with the item being dragged and then choose the one thats closest to the touch point	100407
UNKNOWN	// The custom content screen is not a valid drag over option	100408
UNKNOWN	// Transform the touch coordinates to the CellLayouts local coordinates	100409
UNKNOWN	// If the touch point is within the bounds of the cell layout, we can return immediately	100410
UNKNOWN	// Get the center of the cell layout in screen coordinates	100411
UNKNOWN	// Calculate the distance between the center of the CellLayout	100412
UNKNOWN	// and the touch point	100413
UNKNOWN	// This is used to compute the visual center of the dragView. This point is then	100414
UNKNOWN	// used to visualize drop locations and determine where to drop an item. The idea is that	100415
UNKNOWN	// the visual center represents the users interpretation of where the item is, and hence	100416
UNKNOWN	// is the appropriate point to use when determining drop location.	100417
UNKNOWN	// First off, the drag view has been shifted in a way that is not represented in the	100418
UNKNOWN	// x and y values or the x/yOffsets. Here we account for that shift.	100419
UNKNOWN	// These represent the visual top and left of drag view if a dragRect was provided.	100420
UNKNOWN	// If a dragRect was not provided, then they correspond to the actual view left and	100421
UNKNOWN	// top, as the dragRect is in that case taken to be the entire dragView.	100422
UNKNOWN	// R.dimen.dragViewOffsetY.	100423
UNKNOWN	// In order to find the visual center, we shift by half the dragRect	100424
UNKNOWN	// Skip drag over events while we are dragging over side pages	100425
UNKNOWN	// Ensure that we have proper spans for the item that we are dropping	100426
UNKNOWN	// Identify whether we have dragged over a side page	100427
UNKNOWN	// Handle the drag over	100428
UNKNOWN	// We want the point to be mapped to the dragTarget.	100429
UNKNOWN	// Otherwise, if we arent adding to or creating a folder and theres no pending	100430
UNKNOWN	// reorder, then we schedule a reorder	100431
UNKNOWN	// This shouldnt happen ever, but just in case, make sure we clean up the mess.	100432
UNKNOWN	// We want the workspace to have the whole area of the display (it will find the correct	100433
UNKNOWN	// cell layout to drop to in the existing drag/drop logic.	100434
UNKNOWN	/**     * Add the item specified by dragInfo to the given layout.     * @return true if successful     */	100435
UNKNOWN	/**     * Drop an item that didnt originate on one of the workspace screens.     * It may have come from Launcher (e.g. from all apps or customize), or it may have     * come from another app altogether.     *     * NOTE: This can also be called when we are outside of a drag event, when we want     * to add an item to one of the workspace screens.     */	100436
UNKNOWN	// Normally removeExtraEmptyScreen is called in Workspace#onDragEnd, but when	100437
UNKNOWN	// adding an item that may not be dropped right away (due to a config activity)	100438
UNKNOWN	// we defer the removal until the activity returns.	100439
UNKNOWN	// When dragging and dropping from customization tray, we deal with creating	100440
UNKNOWN	// widgets/shortcuts/folders in a slightly different way	100441
UNKNOWN	// This is for other drag/drop cases, like dragging from All Apps	100442
UNKNOWN	// Came from all apps -- make a copy	100443
UNKNOWN	// First we find the cell nearest to point at which the item is	100444
UNKNOWN	// dropped, without any consideration to whether there is an item there.	100445
UNKNOWN	// when dragging and dropping, just find the closest free spot	100446
UNKNOWN	// Add the item to DB before adding to screen ensures that the container and other	100447
UNKNOWN	// values of the info is properly updated.	100448
UNKNOWN	// We wrap the animation call in the temporary set and reset of the current	100449
UNKNOWN	// cellLayout to its final transform -- this means we animate the drag view to	100450
UNKNOWN	// the correct final location.	100451
UNKNOWN	// Normally removeExtraEmptyScreen is called in Workspace#onDragEnd, but when	100452
UNKNOWN	// adding an item that may not be dropped right away (due to a config activity)	100453
UNKNOWN	// we defer the removal until the activity returns.	100454
UNKNOWN	// When dragging and dropping from customization tray, we deal with creating	100455
UNKNOWN	// widgets/shortcuts/folders in a slightly different way	100456
UNKNOWN	// Now we animate the dragView, (ie. the widget or shortcut preview) into its final	100457
UNKNOWN	// location and size on the home screen.	100458
UNKNOWN	// The animation will scale the dragView about its center, so we need to center about	100459
UNKNOWN	// In the case where weve prebound the widget, we remove it from the DragLayer	100461
UNKNOWN	/**     * Return the current {@link CellLayout}, correctly picking the destination     * screen while a scroll is in progress.     */	100462
UNKNOWN	/**     * Return the current CellInfo describing our current drag; this method exists     * so that Launcher can sync this object with the correct info when the activity is created/     * destroyed     *     */	100463
UNKNOWN	/**     * Calculate the nearest cell where the given object would be dropped.     *     * pixelX and pixelY should be in the coordinate system of layout     */	100464
UNKNOWN	// hardware layers on children are enabled on startup, but should be disabled until	100465
UNKNOWN	// needed	100466
UNKNOWN	/**     * Called at the end of a drag which originated on the workspace.     */	100467
UNKNOWN	/// maybe move this into a smaller part	100468
UNKNOWN	// Null check required as the AllApps button doesnt have an item info	100469
UNKNOWN	// Null check required as the AllApps button doesnt have an item info	100470
UNKNOWN	// If dataUri is not null / empty or if this component isnt one that would	100471
UNKNOWN	// have previously showed up in the AllApps list, then this is a widget-type	100472
UNKNOWN	// shortcut, so ignore it.	100473
UNKNOWN	// If dataUri is not null / empty or if this component isnt one that would	100474
UNKNOWN	// have previously showed up in the AllApps list, then this is a widget-type	100475
UNKNOWN	// shortcut, so ignore it.	100476
UNKNOWN	// Null check required as the AllApps button doesnt have an item info	100477
UNKNOWN	// Do nothing	100478
UNKNOWN	// Do nothing	100479
UNKNOWN	// We dont dispatch restoreInstanceState to our children using this code path.	100480
UNKNOWN	// Some pages will be restored immediately as their items are bound immediately, and	100481
UNKNOWN	// others we will need to wait until after their items are bound.	100482
UNKNOWN	// We always want to exit the current layout to ensure parity of enter / exit	100483
UNKNOWN	// Ensure that we are not dragging over to the custom content screen	100484
UNKNOWN	// Workspace is responsible for drawing the edge glow on adjacent pages,	100485
UNKNOWN	// so we need to redraw the workspace when this may have changed.	100486
UNKNOWN	/**     * Returns a specific CellLayout     */	100487
UNKNOWN	/**     * Returns a list of all the CellLayouts in the workspace.     */	100488
UNKNOWN	/**     * We should only use this to search for specific children.  Do not use this method to modify     * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from     * the hotseat and workspace pages     */	100489
UNKNOWN	// not done, process all the shortcuts	100490
UNKNOWN	// not done, process all the shortcuts	100491
UNKNOWN	// Removes ALL items that match a given package name, this is usually called when a package	100492
UNKNOWN	// has been removed and we want to remove all components (widgets, shortcuts, apps) that	100493
UNKNOWN	// belong to that package.	100494
UNKNOWN	// Filter out all the ItemInfos that this is going to affect	100495
UNKNOWN	// Removes items that match the application info specified, when applications are removed	100497
UNKNOWN	// as a part of an update, this is called to ensure that other widgets and application	100498
UNKNOWN	// shortcuts are not removed.	100499
UNKNOWN	// Just create a hash table of all the specific components that this will affect	100500
UNKNOWN	// Remove all the things	100501
UNKNOWN	// Remove all the apps from their folders	100502
UNKNOWN	// Remove all the other children	100503
UNKNOWN	// Note: We can not remove the view directly from CellLayoutChildren as this	100504
UNKNOWN	// does not re-mark the spaces as unoccupied.	100505
UNKNOWN	// Strip all the empty screens	100506
UNKNOWN	/**     * Map the operator over the shortcuts and widgets, return the first-non-null value.     *     * @param recurse true: iterate over folder children. false: op get the folders themselves.     * @param op the operator to map over the shortcuts     */	100507
UNKNOWN	// map over all the shortcuts on the workspace	100508
UNKNOWN	// map over all the children in the folder	100509
UNKNOWN	// Break the appinfo list per user	100510
UNKNOWN	// Create a map of the apps to test against	100511
UNKNOWN	// Auto install icon	100512
UNKNOWN	// Try to find the best match activity.	100513
UNKNOWN	// Could not find a default activity. Remove this item.	100514
UNKNOWN	// process next shortcut.	100515
UNKNOWN	// Restore the shortcut.	100516
UNKNOWN	// process all the shortcuts	100517
UNKNOWN	// Auto install icon	100518
UNKNOWN	// Try to find the best match activity.	100519
UNKNOWN	// Could not find a default activity. Remove this item.	100520
UNKNOWN	// process next shortcut.	100521
UNKNOWN	// Restore the shortcut.	100522
UNKNOWN	// process all the shortcuts	100523
UNKNOWN	// For auto install apps update the icon as well as label.	100524
UNKNOWN	// Only update the icon for restored apps.	100525
UNKNOWN	// process all the shortcuts	100526
UNKNOWN	// For auto install apps update the icon as well as label.	100527
UNKNOWN	// Only update the icon for restored apps.	100528
UNKNOWN	// process all the shortcuts	100529
UNKNOWN	// Mark this info as broken.	100530
UNKNOWN	// process all the shortcuts	100531
UNKNOWN	// Note that package states are sent only for myUser	100532
UNKNOWN	// Mark this info as broken.	100533
UNKNOWN	// process all the shortcuts	100534
UNKNOWN	// Iterate non recursively as widgets cant be inside a folder.	100535
UNKNOWN	// Remove the provider not ready flag	100536
UNKNOWN	// process all the widget	100537
UNKNOWN	// Re-inflate the widgets which have changed status	100538
UNKNOWN	// widgetRefresh will automatically run when the packages are updated.	100539
UNKNOWN	// Remove the provider not ready flag	100540
UNKNOWN	// process all the widget	100541
UNKNOWN	// Exclude the leftmost page	100543
UNKNOWN	// Exclude the last extra empty screen (if we have > MIN_PARALLAX_PAGE_SPAN pages)	100544
UNKNOWN	// TODO: do different behavior if its  a live wallpaper?	100545
UNKNOWN	// Sometimes the left parameter of the pages is animated during a layout transition;	100546
UNKNOWN	// this parameter offsets it to keep the wallpaper from animating as well	100547
UNKNOWN	// Dont use up all the wallpaper parallax until you have at least	100548
UNKNOWN	// MIN_PARALLAX_PAGE_SPAN pages	100549
UNKNOWN	// On RTL devices, push the wallpaper offset to the right if we dont have enough	100550
UNKNOWN	// pages (ie if numScrollingPages < MIN_PARALLAX_PAGE_SPAN)	100551
UNKNOWN	// Set wallpaper offset steps (1 / (number of screens - 1))	100552
UNKNOWN	// Dont animate if were going from 0 screens	100553
UNKNOWN	// We want to avoid the extra layout pass by setting the views to GONE unless	100554
UNKNOWN	// accessibility is on, in which case not setting them to GONE causes a glitch.	100555
UNKNOWN	// We want the views to be visible for animation, so fade-in/out is visible	100556
UNKNOWN	// This shouldnt happen ever, but just in case, make sure we clean up the mess.	100557
UNKNOWN	// Remove the current widget	100558
