// post a new callback	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Sets the alarm to go off in a certain number of milliseconds. If the alarm is already set,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// its overwritten and only the new alarm setting is used	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// this is called when our timer runs out	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We still need to wait some time to trigger spring loaded mode--	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the application title     *      * @return application title     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Updates the app widgets whose id has changed during the restore process.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The widget no long exists.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Unregister the widget IDs which are not present on the workspace. This could happen	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// when a widget place holder is removed from workspace, before this method is called.	UNKNOWN	WITHOUT_CLASSIFICATION	0.837	0.000
/**     * Add the supplied ApplicationInfo objects to the list, and enqueue it into the     * list to broadcast when notify() is called.     *     * If the app is already in the list, doesnt add it.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: do we clear these too?	UNKNOWN	DESIGN	1.000	0.000
/**     * Add the icons for the supplied apk called packageName.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Remove the apps for the given apk identified by packageName.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Add and remove icons for this package which has been updated.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.673	0.000
// Find disabled/removed activities and remove them from data and add them	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to the removed list.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Find enabled activities and add them to the adapter	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Also updates existing activities with new labels/icons	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove all data for this package.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns whether <em>apps</em> contains <em>component</em>.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Query the launcher apps service for whether the supplied package has     * MAIN/LAUNCHER activities in the supplied package.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.986	0.000
/**     * Returns whether <em>apps</em> contains <em>component</em>.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Find an ApplicationInfo object for the given packageName and className.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Clears all the key listeners for the individual icons.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: revisit this	UNKNOWN	DESIGN	0.994	0.000
/**     * Convenience methods to select specific tabs.  We want to set the content type immediately     * in these cases, but we note that we still call setCurrentTabByTag() so that the tab view     * reflects the new content (but doesnt do the animation and logic associated with changing     * tabs manually).     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Setup the tab host and create all necessary tabs.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the content type for the specified tab tag.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the tab tag for a given content type.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Disable focus on anything under this view in the hierarchy if we are not visible.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reset immediately	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We unload the widget previews when the UI is hidden, so need to reload pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load the current page synchronously, and the neighboring pages asynchronously	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear the widget pages of all their subviews - this will trigger the widget previews	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// to delete their bitmaps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* LauncherTransitionable overrides */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Going from All Apps -> Workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Going from Workspace -> All Apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Make sure the current page is loaded (we start loading the side pages after the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// transition to prevent slowing down the animation)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Make sure adjacent pages are loaded (we wait until after the transition to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// prevent slowing down the animation)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Opening apps, need to announce what page we are on.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Notify the user when the page changes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Going from Workspace -> All Apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// NOTE: We should do this at the end since we check visibility state in some of the	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// cling initialization/dismiss code above.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     *  Here we bound the deltas such that the frame cannot be stretched beyond the extents     *  of the CellLayout, and such that the frames borders cant cross.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     *  Based on the deltas, we resize the frame, and, if needed, we resize the widget.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
/**     *  Based on the current deltas, we determine if and how to resize the widget.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For each border, we bound the resizing based on the minimum width, and the maximum	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// expandability.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the widgets dimensions and position according to the deltas computed above	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We always want the final commit to match the feedback, so we make sure to use the	UNKNOWN	WITHOUT_CLASSIFICATION	0.950	0.000
// last used direction vector when committing the resize / reorder.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Compute landscape size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Compute portrait size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This is the final step of the resize. Here we save the new widget size and position     * to LauncherModel and animate the resize frame.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We need to make sure the frames touchable regions lie fully within the bounds of the 	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// DragLayer. We allow the actual handles to be clipped, but we shift the touch regions	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// down accordingly to provide a proper touch target.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In this case we shift the touch region down to start at the top of the DragLayer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In this case we shift the touch region up to end at the bottom of the DragLayer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the rect to animate to (the view is center aligned)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Center the destination rect about the trash icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure we are using the right text size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Call the superclass onTouchEvent first, because sometimes it changes the state to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// isPressed() on an ACTION_UP	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// So that the pressed outline is visible immediately on setStayPressed(),	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we pre-create it on ACTION_DOWN (it takes a small but perceptible amount of time	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to create it)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If weve touched down and up on an item, and its still not pressed, then	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// destroy the pressed outline	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only show the shadow effect when persistent pressed state is set.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pre-create shadow so show immediately on click.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Unlike touch events, keypress event propagate pressed state change immediately,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// without waiting for onClickHandler to execute. Disable pressed state changes here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to avoid flickering.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If text is transparent, dont draw any shadow	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We enhance the shadow by drawing the shadow twice	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Keep track of the set of screens which need to be added to the db.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Read the extras	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Send a broadcast to configure the widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.927	0.000
// We can only have folders with >= 2 items, so we need to remove the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// folder and clean up if less than 2 items were included, or some	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// failed to add, and less than 2 were actually added	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we have a single item, promote it to where the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// would have been.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//noinspection StatementWithEmptyBody	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Return attribute value, attempting launcher-specific namespace first     * before falling back to anonymous attribute.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Return attribute resource value, attempting launcher-specific namespace     * first before falling back to anonymous attribute.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Read the extras	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Send a broadcast to configure the widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.927	0.000
// We can only have folders with >= 2 items, so we need to remove the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// folder and clean up if less than 2 items were included, or some	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// failed to add, and less than 2 were actually added	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we have a single item, promote it to where the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// would have been.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Schedule runnable to run after everything thats on the queue right now. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Schedule runnable to run when the queue goes idle. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//noinspection StatementWithEmptyBody	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Runs all queued Runnables from the calling thread. */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Get the drawable	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the hover color	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The current drawable is set to either the remove drawable or the uninstall drawable	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// and is initially set to the remove drawable, as set in the layout xml.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the text in the Phone UI in landscape	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are dragging an application from AppsCustomize, only show the control if we can	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// delete the app (it was downloaded), and rename the string to uninstall in such a case.	UNKNOWN	WITHOUT_CLASSIFICATION	0.966	0.000
// Hide the delete target if it is a widget from AppsCustomize.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the hover color if we are deleting	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only allow manifest shortcuts to initiate an un-install.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Uninstall the application if it is being dragged from AppsCustomize	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the folder from the workspace and delete the contents from launcher model	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the widget from the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// Deleting an app widget ID is a void call but writes to disk before returning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to the caller...	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Creates an animation from the current drag view to the delete trash icon.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Calculate how far along the velocity vector we should put the intermediate point on	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the bezier curve	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// intermediate t/l	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drag view t/l	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// delete target t/l	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont highlight the icon as its animating	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont highlight the target if we are flinging from AllApps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Defer animating out the drop target if we are animating to it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// NOTE: Because it takes time for the first frame of animation to actually be	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// called and we expect the animation to be a continuation of the fling, we have	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to account for the time that has elapsed since the fling finished.  And since	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we dont have a startDelay, we will always get call to update when we call	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// start() (which we want to ignore).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are dragging from AllApps, then we allow AppsCustomizePagedView to clean up	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// itself, otherwise, complete the drop to initiate the deletion process	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are dragging from AllApps, then we allow AppsCustomizePagedView to clean up	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// itself, otherwise, complete the drop to initiate the deletion process	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clean up any references to source/generated bitmaps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load each of the widget previews in the background	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// All the widget previews are loaded, so we can just callback to inflate the page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load the widget previews	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load the widget previews	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * PagedViewWithDraggableItems implementation     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the item index of the center item on this page so that we can restore to this     *  item index when we rotate. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Get the index of the item to restore to if we need to restore the current page. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the page in the current orientation which is expected to contain the specified     *  item index. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Restores the page for an item at the specified index */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Now that the data is ready, we can calculate the content width, the number of cells to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// use for each page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Force a measure to update recalculate the gaps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This code triggers requestLayout so must be posted outside of the	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// layout pass.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This code triggers requestLayout so must be posted outside of the	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// layout pass.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the list of widgets and shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that all widgets we show can be added on a workspace of this size	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// just add shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When we have exited all apps or are in transition, disregard clicks	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Let the user know that they have to long press to add a widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Create a little animation to show that the widget can move	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// Disable dragging by pulling an app down for now.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want the first widget layout to be the correct size. This will be important	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// for width size reporting to the AppWidgetManager.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want the first widget layout to be the correct size. This will be important	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// for width size reporting to the AppWidgetManager.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We are anticipating a long press, and we use this time to load bind and instantiate	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the widget. This will need to be cleaned up if it turns out no long press occurs.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Just in case the cleanup process wasnt properly executed. This shouldnt happen.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the widget was not added, we may need to do further cleanup.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We never did any preloading, so just remove pending callbacks to do so	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete the widget id which was allocated	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We never got around to inflating the widget, so remove the callback to do so.	UNKNOWN	WITHOUT_CLASSIFICATION	0.825	0.000
// Delete the widget id which was allocated	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The widget was inflated and added to the DragLayer -- remove it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the widget preview as the drag representation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the ImageView doesnt have a drawable yet, the widget preview hasnt been loaded and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we abort the drag.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Compose the drag image	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This can happen in some weird cases involving multi-touch. We cant start dragging	UNKNOWN	WITHOUT_CLASSIFICATION	0.994	0.000
// the widget if this is null, so we break out.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Compare the size of the drag preview to the preview in the AppsCustomize tray	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The bitmap in the AppsCustomize tray is always the the same size, so there	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// might be extra pixels around the preview itself - this accounts for that	UNKNOWN	WITHOUT_CLASSIFICATION	0.955	0.000
// Dont clip alpha values for the drag outline if were using the default widget preview	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Save the preview for the outline generation, then dim the preview	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Start the drag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We delay entering spring-loaded mode slightly to make sure the UI	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// thready is free of any work.	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// We dont enter spring-loaded mode if the drag has been cancelled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Go into spring loaded mode (must happen before we startDrag())	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont enter spring-loaded mode if the drag has been cancelled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Go into spring loaded mode (must happen before we startDrag())	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Clean up after dragging.     *     * @param target where the item was dragged to (can be null if the item was flung)     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Exit spring loaded mode if we have not successfully dropped or have not handled the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drop in Workspace	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Return early and wait for onFlingToDeleteCompleted if this was the result of a fling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Display an error message if the drag failed due to there not being enough space on the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// target layout we were dropping on.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We just dismiss the drag when we fling, so cleanup here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clean up all the async tasks	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Weve already preallocated the views for the data to load into, so clear them as well	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Widgets appear to be cleared every time you leave, always force invalidate for them	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the thread priorities given the direction lookahead	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * Apps PagedView implementation     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Note: We force a measure here to get around the fact that when we do layout calculations	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// immediately after syncing, we dont have a proper width.  That said, we already know the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// expected page width, so we can actually optimize by hiding all the TextView-based	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// children that are expensive to measure, and let that happen naturally later.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ensure that we have the right number of items on the pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * A helper to return the priority for loading of the specified widget page.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are snapping to another page, use that index as the target page index	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We use the distance from the target page as an initial guess of priority, but if there	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// are no pages of higher priority than the page specified, then bump up the priority of	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the specified page.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Return the appropriate thread priority for loading for a given page (we give the current     * page much higher priority)     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below	UNKNOWN	WITHOUT_CLASSIFICATION	0.824	0.000
/**     * Creates and executes a new AsyncTask to load a page of widget previews.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Prune all tasks that are no longer needed	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We introduce a slight delay to order the loading of side pages so that we dont thrash	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// do cleanup inside onSyncWidgetPageItems	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that the task is appropriately prioritized and runs in parallel	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// do cleanup inside onSyncWidgetPageItems	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * Widgets PagedView implementation     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Note: We force a measure here to get around the fact that when we do layout calculations	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// immediately after syncing, we dont have a proper width.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Calculate the dimensions of each cell we are giving to each widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Prepare the set of widgets to load previews for in the background	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Prepopulate the pages with the other widget info, and fill in the previews later	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fill in the widget information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Determine the widget spans and min resize spans.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fill in the shortcuts information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Layout each widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// wait until a call on onLayout to start loading, because	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// PagedViewWidget.getPreviewSize() will return 0 if it hasnt been laid out	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: can we do a measure/layout immediately?	UNKNOWN	DESIGN	1.000	0.000
// loadWidgetPreviewsInBackground can be called without a task to load a set of widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// previews synchronously	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that this task starts running at the correct priority	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load each of the widget/shortcut previews	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure we havent been cancelled yet	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Before work on each item, ensure that this task is running at the correct	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// priority	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update all thread priorities	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want our pages to be z-ordered such that the further a page is to the left, the higher	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// it is in the z-order. This is important to insure touch events are handled correctly.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// make sure were caching at least two pages always	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Used by the parent to get the content width to set the tab bar to     * @return     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.933	0.000
// We reset the save index when we change pages so that it will be recalculated on next	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// rotation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * AllAppsView implementation     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * We should call thise method whenever the core data changes (mApps, mWidgets) so that we can     * appropriately determine when to invalidate the PagedView page data.  In cases where the data     * has yet to be set, we can requestLayout() and wait for onDataReady() to be called in the     * next onMeasure() pass, which will trigger an invalidatePageData() itself.     */	UNKNOWN	DESIGN	0.999	0.000
// The next layout pass will trigger data-ready if both widgets and apps are set, so	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// request a layout to trigger the page data when ready.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We add it in place, in alphabetical order	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// loop through all the apps and remove apps that have the same component	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We remove and re-add the updated applications list because its properties may have	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// changed (ie. the title), and this will ensure that the items will be in their proper	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// place in the list.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we have reset, then we should not continue to restore the previous state	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: Dump information related to current list of Applications, Widgets, etc.	UNKNOWN	WITHOUT_CLASSIFICATION	0.763	0.000
// TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we	UNKNOWN	DESIGN	0.891	0.000
// should stop this now.	UNKNOWN	WITHOUT_CLASSIFICATION	0.976	0.000
// Stop all background tasks	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Put the page indicators above the hotseat	UNKNOWN	WITHOUT_CLASSIFICATION	0.982	0.000
// Layout AllApps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Center the all apps page indicator	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Apply any Partner customization grid overrides.     *     * Currently we support: all apps row / column count.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// AllApps uses the original non-scaled icon size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Determine the exact visual footprint of the all apps button, taking into account scaling     * and internal padding of the drawable.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There are three possible configurations that the dynamic grid accounts for, portrait,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// landscape with the nav bar at the bottom, and landscape with the nav bar at the side.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// To prevent waiting for fitSystemWindows(), we make the observation that in landscape,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the height is the smallest height (either with the nav bar at the bottom or to the	UNKNOWN	WITHOUT_CLASSIFICATION	0.994	0.000
// side) and otherwise, the height is simply the largest possible height for a portrait	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// device.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check to see if the icons fit in the new available height.  If not, then we need to	UNKNOWN	WITHOUT_CLASSIFICATION	0.994	0.000
// shrink the icon size.	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// Make the callbacks	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Search Bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Calculate the actual text height	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// All Apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the closest device profile given the width and height and a list of profiles */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the closest device profiles ordered by closeness to the specified width and height */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Sort the profiles by their closeness to the dimensions	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the search bar top offset */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the search bar bounds in the current orientation */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the search bar bounds in the specified orientation */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pad the left and right of the workspace to ensure consistent spacing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// between all icons	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: If the icon size changes across orientations, we will have to take	UNKNOWN	WITHOUT_CLASSIFICATION	0.971	0.000
//      that into account here too.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the bounds of the workspace page indicators. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns the workspace padding in the specified orientation */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pad the left and right of the workspace with search/hotseat bar sizes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pad the left and right of the workspace to ensure consistent spacing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// between all icons	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pad the top and bottom of the workspace with search/hotseat bar sizes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In landscape mode the page spacing is set to the default.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In portrait, we want the pages spaced such that there is no	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// overhang of the previous / next page into the current page viewport.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We assume symmetrical padding in portrait mode.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The rect returned will be extended to below the system ui that covers the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Layout the search bar space	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Vertical search bar space	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//            searchBar.setPadding(	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//                    0, 2 * edgeMarginPx, 0,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//                    2 * edgeMarginPx);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Horizontal search bar space	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//            searchBar.setPadding(	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//                    2 * edgeMarginPx,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//                    getSearchBarTopOffset(),	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//                    2 * edgeMarginPx, 0);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Layout the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Layout the page indicators	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Hide the page indicators when we have vertical search/hotseat	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Constrain the dimensions of all apps so that it does not span the full width	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only adjust the side paddings on landscape phones, or tablets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The icons are centered, so we cant just offset by the page indicator height	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// because the empty space will actually be pageIndicatorHeight + paddingTB	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Horizontal padding for the whole paged view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Layout the Overview Mode	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We have enough space. Lets add some margin too.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set margin of all visible children except the last visible child	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Sets the scale of the view over the normal workspace icon size. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// suppress dead code warning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Create a window containing this view and show it.     *     * @param windowToken obtained from v.getWindowToken() from one of your views     * @param touchX the x coordinate the user touched in DragLayer coordinates     * @param touchY the y coordinate the user touched in DragLayer coordinates     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Start the pick-up animation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Post the animation to skip other expensive work happening on the first frame	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Move the window containing this view.     *     * @param touchX the x coordinate the user touched in DragLayer coordinates     * @param touchY the y coordinate the user touched in DragLayer coordinates     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Starts a drag.     *     * @param v The view that is being dragged     * @param bmp The bitmap that represents the view being dragged     * @param source An object representing where the drag originated     * @param dragInfo The data associated with the object that is being dragged     * @param dragAction The drag action: either {@link #DRAG_ACTION_MOVE} or     *        {@link #DRAG_ACTION_COPY}     * @param dragRegion Coordinates within the bitmap b for the position of item being dragged.     *          Makes dragging feel more precise, e.g. you can clip out a transparent border     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Starts a drag.     *     * @param b The bitmap to display as the drag image.  It will be re-scaled to the     *          enlarged size.     * @param dragLayerX The x position in the DragLayer of the left-top of the bitmap.     * @param dragLayerY The y position in the DragLayer of the left-top of the bitmap.     * @param source An object representing where the drag originated     * @param dragInfo The data associated with the object that is being dragged     * @param dragAction The drag action: either {@link #DRAG_ACTION_MOVE} or     *        {@link #DRAG_ACTION_COPY}     * @param dragRegion Coordinates within the bitmap b for the position of item being dragged.     *          Makes dragging feel more precise, e.g. you can clip out a transparent border     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Hide soft keyboard, if visible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Draw the view into a bitmap.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Reset the drawing cache background color to fully transparent	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// for the duration of this operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Call this from a drag source view like this:     *     * <pre>     *  @Override     *  public boolean dispatchKeyEvent(KeyEvent event) {     *      return mDragController.dispatchKeyEvent(this, event)     *              || super.dispatchKeyEvent(event);     * </pre>     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Stop dragging without dropping.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Cancel the current drag if we are removing an app that we are dragging	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Added null checks to prevent NPE weve seen in the wild	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only end the drag if we are not deferred	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This only gets called as a result of drag view cleanup being deferred in endDrag();     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// If we skipped calling onDragEnd() before, do it now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Clamps the position to the drag layer bounds.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Call this from a drag source view.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// suppress dead code warning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the velocity tracker	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// verify the edgeswipe menu	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Remember location of down touch	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mDragging = false;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ignore menu if dragging	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if from the edges and in limits	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Sets the view that should handle move events.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.989	0.000
// Drop on someone?	UNKNOWN	WITHOUT_CLASSIFICATION	0.976	0.000
// Check if we are hovering over the scroll areas	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Call this from a drag source view.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the velocity tracker	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remember where the motion event started	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that weve processed a move event at the current pointer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// location.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Determines whether the user flung the current item to delete it.     *     * @return the vector at which the item was flung, or null if no fling was detected.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do a quick dot product test to ensure that we are flinging upwards	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clean up dragging on the target if its not the current fling delete target otherwise,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// start dragging to it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Drop onto the fling-to-delete target	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We must set dragComplete to true _only_ after we enter the fling-to-delete target for	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Sets the drag listner which will be notified when a drag starts or ends.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Remove a previously installed drag listener.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Add a DropTarget to the list of potential places to receive drop events.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Dont send drop events to <em>target</em> any more.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Sets the current fling-to-delete drop target.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Set which view scrolls for touch events near the edge of the screen.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Check the scroll again so that we can requeue the scroller if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check the scroll again so that we can requeue the scroller if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Applies the new bitmap.     * @return true if the view was invalidated.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw the bitmap into the bounding rect	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// No op	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * When enabled, the icon is grayed out and the contrast is increased to give it a ghost     * appearance.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For ghost mode, set the color range to [GHOST_MODE_MIN_COLOR_RANGE, 255]	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Brightness: C-new = C-old*(1-amount) + amount	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the amount to RGB components of the matrix, as per the above formula.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fifth elements in the array correspond to the constant being added to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// red, blue, green, and alpha channel respectively.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// only used for ViewPropertyAnimators	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the current play time exceeds the duration, or the animated fraction is 1,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the animation will get finished, even if we call setCurrentPlayTime -- therefore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dont adjust the animation in that case	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we havent drawn our first frame, reset the time to t = 0	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// (give up after MAX_DELAY ms of waiting though - might happen, for example, if we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// are no longer in the foreground and no frames are being rendered ever)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The first frame on animations doesnt always trigger an invalidate...	UNKNOWN	WITHOUT_CLASSIFICATION	0.939	0.000
// force an invalidate here to make sure the animation continues to advance	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For the second frame, if the first frame took more than 16ms,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// adjust the start time and pretend it took only 16ms anyway. This	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// prevents a large jump in the animation due to an expensive first frame	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Redraw if it is already showing. This avoids a bug where the height changes by a small	UNKNOWN	WITHOUT_CLASSIFICATION	0.994	0.000
// amount on connecting/disconnecting a bluetooth keyboard.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// View not yet laid out. Wait until the view is ready to be drawn, so that be can	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the location on screen.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Gets the location of a view relative in the window, off-setting any shift due to     * page view scroll     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Ill take it from here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ensure that the overlay view stays on top. we cant use drawing order for this	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// because in API level 16 touch dispatch doesnt respect drawing order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Skip propagating onRequestSendAccessibilityEvent all for other children	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when a folder is open	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only add the folder as a child for accessibility when it is open	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If weve received this, weve already done the necessary handling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in onInterceptHoverEvent. Return true to consume the event.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Determine the rect of the descendant in this DragLayers coordinates     *     * @param descendant The descendant whose coordinates we want to find.     * @param r The rect into which to place the results.     * @return The factor by which this descendant is scaled relative to this DragLayer.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// because in API level 16 touch dispatch doesnt respect drawing order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// between platform versions 17 and 18, behavior for onChildViewRemoved / Added changed.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pre-18, the child was not added / removed by the time of those callbacks. We need to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// force update our representation of things here to avoid crashing on pre-18 devices	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in certain instances.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// i represents the current draw iteration	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given a coordinate relative to the descendant, find the coordinate in this DragLayers     * coordinates.     *     * @param descendant The descendant to which the passed coordinate is relative.     * @param coord The coordinate that we want mapped.     * @param includeRootScroll Whether or not to account for the scroll of the root descendant:     *          sometimes this is relevant as in a childs coordinates within the root descendant.     * @return The factor by which this descendant is scaled relative to this DragLayer. Caution     *         this scale factor is assumed to be equal in X and Y, and so if at any point this     *         assumption fails, we will need to return a pair of scale factors.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Since the child hasnt necessarily been laid out, we force the lp to be updated with	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the correct coordinates (above) and use these to determine the final location	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We need to account for the scale of the child itself, as the above only accounts for	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// for the scale in parents.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Account for the source scale of the icon (ie. from AllApps to Workspace, in which	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the workspace may have smaller icon bounds).	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// The child may be scaled (always about the center of the view) so to account for it,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we have to offset the position by the scaled size.  Once we do that, we can center	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the drag view about the scaled child view.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Account for holographic blur padding on the drag view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Center in the x coordinate about the targets drawable	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This method animates a view at the end of a drag and drop animation.     *     * @param view The view to be animated. This view is drawn directly into DragLayer, and so     *        doesnt need to be a child of DragLayer.     * @param from The initial location of the view. Only the left and top parameters are used.     * @param to The final location of the view. Only the left and top parameters are used. This     *        location doesnt account for scaling, and so should be centered about the desired     *        final location (including scaling).     * @param finalAlpha The final alpha of the view, in case we want it to fade as it animates.     * @param finalScale The final scale of the view. The view is scaled about its center.     * @param duration The duration of the animation.     * @param motionInterpolator The interpolator to use for the location of the view.     * @param alphaInterpolator The interpolator to use for the alpha of the view.     * @param onCompleteRunnable Optional runnable to run on animation completion.     * @param fadeOut Whether or not to fade out the view once the animation completes. If true,     *        the runnable will execute after the view is faded out.     * @param anchorView If not null, this represents the view which the animated view stays     *        anchored to in case scrolling is currently taking place. Note: currently this is     *        only used for the X dimension for the case of the workspace.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.956	0.000
// Calculate the duration of the animation based on the objects distance	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If duration < 0, this is a cue to compute the duration based on the distance	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fall back to cubic ease out interpolator for the animation if none is specified	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animate the view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clean up the previous animations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Show the drop view if it was previously hidden	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the anchor view if the page is scrolling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create and start the animation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ensure that the overlay view stays on top. we cant use drawing order for this	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// because in API level 16 touch dispatch doesnt respect drawing order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ensure that the overlay view stays on top. we cant use drawing order for this	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// in general we do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if we have a top index, we return it when drawing last item (highest z-order)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// for indexes greater than the top index, we fetch one item above to shift for the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// displacement of the top index	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.     */	UNKNOWN	DESIGN	0.826	0.000
// Draw the background gradient below children.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want to draw the page hints above the workspace, but below the drag view.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// List do not scroll horizontally.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Catch the back button on the soft keyboard so that we can just close the activity	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if there is no next page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the next icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Private helper to get the parent TabHost in the view hiearchy.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the Viewgroup containing page contents for the page at the index specified.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There are two layers, a PagedViewCellLayout and PagedViewCellLayoutChildren	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Handles key events in a PageViewExtendedLayout containing PagedViewWidgets.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.891	0.000
// Now that we load items in the bg asynchronously, we cant just focus	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// child siblings willy-nilly	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the previous widget or the last widget on the previous page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the next widget or the first widget on the next page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the closest icon in the previous row, otherwise select the tab bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the closest icon in the previous row, otherwise do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Simulate a click on the widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first item on the previous page, or the first item on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if there is no previous page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first item on the next page, or the last item on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if there is no next page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first item on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the last item on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Handles key events in a PageViewCellLayout containing PagedViewIcons.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Note we have an extra parent because of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// PagedViewCellLayout/PagedViewCellLayoutChildren relationship	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Side pages do not always load synchronously, so check before focusing child siblings	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// willy-nilly	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the previous icon or the last icon on the previous page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the next icon or the first icon on the next page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the closest icon in the previous row, otherwise select the tab bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the closest icon in the next row, otherwise do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first icon on the previous page, or the first icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if there is no previous page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first icon on the next page, or the last icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the last icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Handles key events in the tab widget.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Select the previous tab	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the next tab, or if the last tab has a focus right id, select that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the content view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Handles key events in the workspace hotseat (bottom of the screen).     */	UNKNOWN	DESIGN	0.779	0.000
// NOTE: currently we dont special case for the phone UI in different	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// orientations, even though the hotseat is on the side in landscape mode. This	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is to ensure that accessibility consistency is maintained across rotations.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the previous button, otherwise do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the next button, otherwise do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first bubble text view in the current page of the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Private helper method to get the CellLayoutChildren given a CellLayout index.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Private helper method to sort all the CellLayout children in order of their (x,y) spatially     * from top left to bottom right.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First we order each the CellLayout children by their x,y coordinates	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Private helper method to find the index of the next BubbleTextView or FolderIcon in the      * direction delta.     *      * @param delta either -1 or 1 depending on the direction we want to search     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Then we find the next BubbleTextView offset by delta from i	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Private helper method to find the next closest BubbleTextView or FolderIcon in the direction      * delta on the next line.     *      * @param delta either -1 or 1 depending on the line and direction we want to search     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Handles key events in a Workspace containing.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// Select the previous icon or the last icon on the previous page if possible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to the previous page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the next icon or the first icon on the next page if possible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to the next page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the closest icon in the previous line, otherwise select the tab bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the closest icon in the next line, otherwise select the button bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first icon on the previous page or the first icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if there is no previous page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to the previous page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first icon on the next page or the last icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if there is no previous page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to the next page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the last icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Handles key events for items in a Folder.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the previous icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the closest icon in the previous line	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the closest icon in the next line	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the first icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select the last icon on this page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Add an app or shortcut     *     * @param item     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Remove an app or shortcut. Does not change the DB.     *     * @param item     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// One time call to generate the pressed/focused state -- must be called after	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// measure/layout	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// One time call to generate the pressed/focused state -- must be called after	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// measure/layout	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// suppress dead code warning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Offset the preview background to center this view accordingly	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Location is expressed in window coordinates	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Location is expressed in window coordinates	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: we currently dont support spring-loading for PendingAddShortcutInfos even	UNKNOWN	DESIGN	0.997	0.000
// though widget-style shortcuts can be added to folders. The issue is that we need	UNKNOWN	WITHOUT_CLASSIFICATION	0.890	0.000
// to deal with configuration activities which are currently handled in	UNKNOWN	WITHOUT_CLASSIFICATION	0.989	0.000
// Workspace#onDropExternal.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Came from all apps -- make a copy.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ShortcutInfo	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// These correspond two the drawable and view that the icon was dropped _onto_	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This will animate the first item from its position as an icon into its	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position as the first item in the preview	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This will animate the dragView (srcView) into the new folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This will animate the first item from its position as an icon into its	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position as the first item in the preview	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Typically, the animateView corresponds to the DragView; however, if this is being done	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// after a configuration activity (ie. for a Shortcut being dragged from AllApps) we	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// will not have a view to animate	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set cellLayout and this to its final state to compute final animation locations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Finished computing final animation locations, restore current state	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Came from all apps -- make a copy	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cos(45) = 0.707  + ~= 0.1) = 0.8f	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want to imagine our coordinates from the bottom left, growing up and to the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// right. This is natural for the x-axis, but for the y-axis, we have to invert things.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Update our drawing parameters if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Call the superclass onTouchEvent first, because sometimes it changes the state to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// isPressed() on an ACTION_UP	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Location is expressed in window coordinates	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Location is expressed in window coordinates	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Generate the pressed/focused states if necessary.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.958	0.000
//noinspection ZeroLengthArrayAllocation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Invalidates the pressed/focused states.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Creates a copy of the original image.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Creates a new press state image which is the old image with a blue overlay.     * Responsibility for the bitmap is transferred to the caller.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Applies a more expensive and accurate outline to whatever is currently drawn in a specified     * bitmap.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We start by removing most of the alpha channel so as to ignore shadows, and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// other types of partial transparency when defining the shape of the object	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// calculate the outer blur first	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// calculate the inner blur	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mask out the inner blur	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// draw the inner and outer blur	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// draw the bright outline	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cleanup	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// adjust the clip rect so that we dont include the text label	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw the View into the bitmap.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The translate of scrollX and scrollY is necessary when drawing TextViews, because	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// they set scrollX and scrollY to large values to achieve centered text	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We use the same intents as Lawnchair.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We find out how tall the text view wants to be (it is set to wrap_content), so that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we can allocate the appropriate amount of space for it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We disable action mode for now since it messes up the view on phones	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return if global dragging is not enabled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Convert to a string here to ensure that no other state associated with the text field	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// gets saved.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In order to clear the focus from the text field, we set the focus on ourself. This	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ensures that every time the field is clicked, focus is gained, giving reliable behavior.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * We need to handle touch events to prevent them from falling through to the workspace below.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.974	0.000
// When the folder gets focus, we dont want to announce the list of items.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * @return the FolderInfo object associated with this folder     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// We rearrange the items in case there are any empty gaps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If our folder has too many items we prune them from the list. This is an issue	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when upgrading from the old Folders implementation which could contain an unlimited	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// number of items.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In case any children didnt come across during loading, clean up the folder accordingly	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Creates a new UserFolder, inflated from R.layout.user_folder.     *     * @param context The applications context.     *     * @return A new UserFolder.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This method is intended to make the UserFolder to be visually identical in size and position     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// in low power mode the animation doesnt play, so set the end value here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in low power mode the animation doesnt play, so set the end value here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* mContent.setAlpha(0f);            Animator iconsAlpha = LauncherAnimUtils.ofFloat(mContent, alpha, 0f, 1f);            iconsAlpha.setDuration(mMaterialExpandDuration);            iconsAlpha.setStartDelay(mMaterialExpandStagger);            iconsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));            mFolderName.setAlpha(0f);            Animator textAlpha = LauncherAnimUtils.ofFloat(mFolderName, alpha, 0f, 1f);            textAlpha.setDuration(mMaterialExpandDuration);            textAlpha.setStartDelay(mMaterialExpandStagger);            textAlpha.setInterpolator(new AccelerateInterpolator(1.5f));*/	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in low power mode the animation doesnt play, so set the end value here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* anim.play(iconsAlpha);            anim.play(textAlpha);*/	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Make sure the folder picks up the last drag move even if the finger doesnt move.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in low power mode the animation doesnt play, so set the end value here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*final ObjectAnimator oa =                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);*/	UNKNOWN	WITHOUT_CLASSIFICATION	0.593	0.000
// power save mode is no fun - skip alpha animation and just set it to 0	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// otherwise the icons will stay around until the duration of the animation	UNKNOWN	WITHOUT_CLASSIFICATION	0.976	0.000
// We need to check here to verify that the given items location isnt already occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// by another item.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This shouldnt happen, log it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is used to compute the visual center of the dragView. The idea is that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the visual center represents the users interpretation of where the item is, and hence	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is the appropriate point to use when determining drop location.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// These represent the visual top and left of drag view if a dragRect was provided.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If a dragRect was not provided, then they correspond to the actual view left and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// top, as the dragRect is in that case taken to be the entire dragView.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// R.dimen.dragViewOffsetY.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In order to find the visual center, we shift by half the dragRect	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Exiting folder; stop the auto scroller.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We only close the folder if this is a true drag exit, ie. not because	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// a drop has occurred above the folder.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The drag failed, we need to return the item to the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reordering may have occured, and we need to save the new item locations. We do this once	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// at the end to prevent unnecessary database operations.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Current grid is too small, expand it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In case the workspace is scrolling, we need to use the final scroll to compute	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// the folders bounds.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We first fetch the currently visible CellLayoutChildren	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We reset the workspaces scroll	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We need to bound the folder to the currently visible CellLayoutChildren	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Center the folder if it is full (on phones only)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the folder doesnt fit within the bounds, center it about the desired bounds	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont cap the height of the content to allow scrolling.	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Add the last remaining child to the workspace in place of the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Move the item from the folder to the workspace, in the position of the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// b/12446428 -- sometimes the cell layout has already gone away?	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We add the child after removing the folder to prevent both from existing at	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the same time in the CellLayout.  We need to add the new item with addInScreenFromBind()	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to ensure that hotseat items are placed correctly.	UNKNOWN	WITHOUT_CLASSIFICATION	0.603	0.000
// Move the item from the folder to the workspace, in the position of the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// b/12446428 -- sometimes the cell layout has already gone away?	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We add the child after removing the folder to prevent both from existing at	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the same time in the CellLayout.  We need to add the new item with addInScreenFromBind()	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to ensure that hotseat items are placed correctly.	UNKNOWN	WITHOUT_CLASSIFICATION	0.603	0.000
// This method keeps track of the last item in the folder for the purposes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// of keyboard focus	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are coming from All Apps space, we defer removing the extra empty screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// until the folder closes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Actually move the item in the database if it was an external drag. Call this	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// before creating the view, so that ShortcutInfo is updated appropriately.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We only need to update the locations if it doesnt get handled in #onDropCompleted.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Temporarily reset the scale such that the animation target gets calculated correctly.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Temporarily suppress the listener, as we did all the work already here.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Clear the drag info, as it is no longer being dragged.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is used so the item doesnt immediately appear in the folder when added. In one case	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we need to create the illusion that the item isnt added back to the folder yet, to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to correspond to the animation of the icon back into the folder. This is	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the item was dropped onto this open folder, we have done the work associated	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// with adding the item to the folder, as indicated by mSuppressOnAdd being set	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The current layout is full, can we expand it?	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If this item is being dragged from this open folder, we have already handled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the work associated with removing the item, so we dont have to do anything here.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the hover color	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: investigate why this is ever happening. Presently only on one known device.	UNKNOWN	DESIGN	0.995	0.000
// Remove the text in the Phone UI in landscape	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// acceptDrop is called just before onDrop. We do the work here, rather than	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in onDrop, because it allows us to reject the drop (by returning false)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// so that the object being dragged isnt removed from the drag source.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There is no post-drop animation, so clean up the DragView now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Hide this button unless we are dragging something from AllApps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We cant move out horizontally	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We cant move out vertically	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// If an animation is started and then stopped very quickly, we can still	UNKNOWN	WITHOUT_CLASSIFICATION	0.994	0.000
// get spurious updates weve cleared the tag. Guard against this.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// suppress dead code warning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try to prevent it from continuing to run	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set whether or not to invert the layout horizontally if the layout is in RTL mode.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When were large, we are either drawn in a hover state (ie when dragging an item to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// a neighboring page) or with just a normal background (if backgroundAlpha > 0.0f)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When were small, we are either drawn normally or in the accepts drops state (during	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// a drag). However, we also drag the mini hover background *over* one of those two	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// backgrounds	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In the mini case, we draw the active_glow bg *over* the active background	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The folder outer / inner ring image(s)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw outer ring, if it exists	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw inner ring	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mismatched viewId / viewType preventing restore. Skip restore on production builds.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Cancel long press for all children	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Generate an id for each view, this assumes we have at most 256x256 cells	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// per workspace screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the horizontal or vertical span is set to -1, it is taken to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mean that it spans the extent of the CellLayout	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First we clear the tag to ensure that on every touch down we start with a fresh slate,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// even in the case where we return early. Not clearing here was causing bugs whereby on	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// long-press wed end up picking up an item from a previous drag operation.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given a point, return the cell that strictly encloses that point     * @param x X coordinate of the point     * @param y Y coordinate of the point     * @param result Array of 2 ints to hold the x and y coordinate of the cell     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given a point, return the cell that most closely encloses that point     * @param x X coordinate of the point     * @param y Y coordinate of the point     * @param result Array of 2 ints to hold the x and y coordinate of the cell     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given a cell coordinate, return the point that represents the upper left corner of that cell     *     * @param cellX X coordinate of the cell     * @param cellY Y coordinate of the cell     *     * @param result Array of 2 ints to hold the x and y coordinate of the point     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given a cell coordinate, return the point that represents the center of the cell     *     * @param cellX X coordinate of the cell     * @param cellY Y coordinate of the cell     *     * @param result Array of 2 ints to hold the x and y coordinate of the point     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given a cell coordinate and span return the point that represents the center of the regio     *     * @param cellX X coordinate of the cell     * @param cellY Y coordinate of the cell     *     * @param result Array of 2 ints to hold the x and y coordinate of the point     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given a cell coordinate and span fills out a corresponding pixel rect     *     * @param cellX X coordinate of the cell     * @param cellY Y coordinate of the cell     * @param result Rect in which to write the result     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Return a rect that has the cellWidth/cellHeight (left, top), and     * widthGap/heightGap (right, bottom) */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Expand the background drawing bounds by the padding baked into the background drawable	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We cancel any existing animations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Exit early if were not actually moving the view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the animation was cancelled, it means that another animation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// has interrupted this one, and we dont want to lock the item into	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// place just yet.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the animation was cancelled, it means that another animation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// has interrupted this one, and we dont want to lock the item into	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// place just yet.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Estimate where the top left cell of the dragged item will land if it is dropped.     *     * @param originX The X value of the top left corner of the item     * @param originY The Y value of the top left corner of the item     * @param spanX The number of horizontal cells that the item spans     * @param spanY The number of vertical cells that the item spans     * @param result The estimated drop cell X and Y.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// pointToCellRounded takes the top left of a cell but will pad that with	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cellWidth/2 and cellHeight/2 when finding the matching cell	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the item isnt fully on this screen, snap to the edges	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to right	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to left	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to bottom	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to top	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the top left corner of the rect the object will occupy	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When drawing the drag outline, it did not account for margin offsets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// added by the views parent.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Offsets due to the size difference between the View and the dragOutline.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There is a size difference to account for the outer blur, which may lie	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// outside the bounds of the view.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We center about the x axis	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Center the drag region *horizontally* in the cell and apply a drag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// outline offset	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Center the drag outline in the cell	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We verify that the current rect is not a sub-rect of any of our previous	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// candidates. In this case, the current rect is disqualified in favour of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// containing rect.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// re-mark space taken by ignoreView as occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return -1, -1 if no suitable location found	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	UNKNOWN	DESIGN	0.712	0.000
/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param minSpanX The minimum horizontal span required     * @param minSpanY The minimum vertical span required     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	UNKNOWN	DESIGN	0.992	0.000
/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreOccupied If true, the result can be an occupied cell     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.793	0.000
/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param minSpanX The minimum horizontal span required     * @param minSpanY The minimum vertical span required     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreOccupied If true, the result can be an occupied cell     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	UNKNOWN	DESIGN	0.930	0.000
// mark space take by ignoreView as available (method checks if ignoreView is null)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For items with a spanX / spanY > 1, the passed in point (pixelX, pixelY) corresponds	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to the center of the item, but we are searching based on the top-left cell, so	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we translate the point over to correspond to the top-left.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Keep track of best-scoring drop area	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First, lets see if this thing fits anywhere	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We know that the item will fit at _some_ acceptable size, now lets see	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// how big we can make it. Well alternate between incrementing x and y spans	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// until we hit a limit.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location, and will also weigh in a suggested direction vector of the     * desired location. This method computers distance based on unit grid distances,     * not pixel distances.     *     * @param cellX The X cell nearest to which you want to search for a vacant area.     * @param cellY The Y cell nearest which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param direction The favored direction in which the views should move from x, y     * @param exactDirectionOnly If this parameter is true, then only solutions where the direction     *        matches exactly. Otherwise we find the best matching direction.     * @param occoupied The array which represents which cells in the CellLayout are occupied     * @param blockOccupied The array which represents which cells in the specified block (cellX,     *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views.     * @param result Array in which to place the result, or null (in which case a new array will     *        be allocated)     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Keep track of best-scoring drop area	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First, lets see if this thing fits anywhere	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The direction score is just the dot product of the two candidate direction	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// and that passed in.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return -1, -1 if no suitable location found	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Determine the edge of the cluster that will be leading the push and how far	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the cluster must be shifted.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Break early for invalid push distance.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mark the occupied state as false for the group of views we want to move.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We save the current configuration -- if we fail to find a solution we will revert	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// to the initial state. The process of finding a solution modifies the configuration	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in place, hence the need for revert in the failure case.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The pushing algorithm is simplified by considering the views in the order in which	UNKNOWN	WITHOUT_CLASSIFICATION	0.972	0.000
// they would be pushed by the cluster. For example, if the cluster is leading with its	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// left edge, we consider sort the views by their right edge, from right to left.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// For each view that isnt in the cluster, we see if the leading edge of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cluster is contacting the edge of that view. If so, we add that view to the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cluster.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The push solution includes the all apps button, this is not viable.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Adding view to cluster, mark it as not occupied.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The cluster has been completed, now we move the whole thing over in the appropriate	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// direction.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Due to the nature of the algorithm, the only check required to verify a valid solution	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is to ensure that completed shifted cluster lies completely within the cell layout.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In either case, we set the occupied array as marked for the location of the views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We construct a rect which represents the entire group of views passed in	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mark the occupied state as false for the group of views we want to move.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We mark more precisely which parts of the bounding rect are truly occupied, allowing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// for interlocking.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we successfuly found a location by pushing the block of views, we commit it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In either case, we set the occupied array as marked for the location of the views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This method tries to find a reordering solution which satisfies the push mechanic by trying	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// to push items in each of the cardinal directions, in an order based on the direction vector	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// passed.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the direction vector has two non-zero components, we try pushing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// separately in each of the components.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Revert the direction	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Now we try pushing in each component of the opposite direction	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// revert the direction	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the direction vector has a single non-zero component, we push first in the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// direction of the vector	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Then we try the opposite direction	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Switch the direction back	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we have failed to find a push solution with the above, then we try	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to find a solution by pushing along the perpendicular axis.	UNKNOWN	WITHOUT_CLASSIFICATION	0.620	0.000
// Swap the components	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Then we try the opposite direction	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Switch the direction back	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Swap the components back	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return early if get invalid cell positions	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mark the desired location of the view currently being dragged.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First we try to find a solution which respects the push mechanic. That is,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we try to find a solution such that no displaced item travels through another item	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// without also displacing that item.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Next we try moving the views as a block, but without requiring the push mechanic.	UNKNOWN	WITHOUT_CLASSIFICATION	0.990	0.000
// Ok, they couldnt move as a block, lets move them individually	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between     * the provided point and the provided cell     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Copy the current state into the solution. This solution will be manipulated as necessary.	UNKNOWN	WITHOUT_CLASSIFICATION	0.985	0.000
// Copy the current occupied array into the temporary occupied array. This array will be	UNKNOWN	WITHOUT_CLASSIFICATION	0.915	0.000
// manipulated as necessary to find a solution.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// We find the nearest cell into which we would place the dragged item, assuming theres	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// nothing in its way.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First we try the exact nearest position of the item being dragged,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we will then want to try to move this around to other neighbouring positions	UNKNOWN	DESIGN	0.748	0.000
// We try shrinking the widget down to size in an alternating pattern, shrink 1 in	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// x, then 1 in y etc.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// This method starts or changes the reorder preview animations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We make sure to end only after a full period	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We make sure to end only after a full period	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We do a null check here because the item info can be null in the case of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// AllApps button in the hotseat.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* This seems like it should be obvious and straight-forward, but when the direction vector    needs to match with the notion of the dragView pushing other views, we have to employ    a slightly more subtle notion of the direction vector. The question is what two points is    the vector between? The center of the dragView and its desired destination? Not quite, as    this doesnt necessarily coincide with the interaction of the dragView and items occupying    those cells. Instead we use some heuristics to often lock the vector to up, down, left    or right, which helps make pushing feel right.    */	UNKNOWN	WITHOUT_CLASSIFICATION	0.770	0.000
// No idea what to do, give a random direction.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For a given cell and span, fetch the set of views intersecting the region.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First we determine if things have moved enough to cause a different layout	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were just testing for a possible location (MODE_ACCEPT_DROP), we dont bother	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// committing anything or animating anything as we just want to determine if a solution	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// exists	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First we determine if things have moved enough to cause a different layout	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When we are checking drop validity or actually dropping, we dont recompute the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// direction vector, since we want the solution to match the preview, and its possible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// that the exact position of the item has changed to result in a new reordering outcome.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We reset this vector after drop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find a solution involving pushing / displacing any items in the way	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// We attempt the approach which doesnt shuffle views at all	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the reorder solution requires resizing (shrinking) the item being dropped, we instead	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// favor a solution in which the item is not resized, but	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were just testing for a possible location (MODE_ACCEPT_DROP), we dont bother	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// committing anything or animating anything as we just want to determine if a solution	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// exists	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Copy current state into savedMap	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore current state from savedMap	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreView Considers space occupied by this view as unoccupied     * @param result Previously returned value to possibly recycle.     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	UNKNOWN	DESIGN	0.754	0.000
// re-mark space taken by ignoreView as occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * A drag event has begun over this layout.     * It may have begun over this layout (in which case onDragChild is called first),     * or it may have begun on another layout.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Find a vacant area that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param minSpanX The minimum horizontal span required     * @param minSpanY The minimum vertical span required     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreView Considers space occupied by this view as unoccupied     * @param result Previously returned value to possibly recycle.     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	UNKNOWN	DESIGN	0.994	0.000
/**     * Find a starting cell position that will fit the given bounds nearest the requested     * cell location. Uses Euclidean distance to score multiple vacant areas.     *     * @param pixelX The X location at which you want to search for a vacant area.     * @param pixelY The Y location at which you want to search for a vacant area.     * @param spanX Horizontal span of the object.     * @param spanY Vertical span of the object.     * @param ignoreView Considers space occupied by this view as unoccupied     * @param result Previously returned value to possibly recycle.     * @return The X, Y cell of a vacant area that can contain this object,     *         nearest the requested location.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.616	0.000
/**     * Finds the upper-left coordinate of the first rectangle in the grid that can     * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,     * then this method will only return coordinates for rectangles that contain the cell     * (intersectX, intersectY)     *     * @param cellXY The array that will contain the position of a vacant cell if such a cell     *               can be found.     * @param spanX The horizontal span of the cell we want to find.     * @param spanY The vertical span of the cell we want to find.     *     * @return True if a vacant cell of the specified dimension was found, false otherwise.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Like above, but ignores any cells occupied by the item ignoreView     *     * @param cellXY The array that will contain the position of a vacant cell if such a cell     *               can be found.     * @param spanX The horizontal span of the cell we want to find.     * @param spanY The vertical span of the cell we want to find.     * @param ignoreView The home screen item we should treat as not occupying any space     * @return     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.841	0.000
/**     * Like above, but if intersectX and intersectY are not -1, then this method will try to     * return coordinates for rectangles that contain the cell [intersectX, intersectY]     *     * @param spanX The horizontal span of the cell we want to find.     * @param spanY The vertical span of the cell we want to find.     * @param ignoreView The home screen item we should treat as not occupying any space     * @param intersectX The X coordinate of the cell that we should try to overlap     * @param intersectX The Y coordinate of the cell that we should try to overlap     *     * @return True if a vacant cell of the specified dimension was found, false otherwise.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * The superset of the above two methods     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mark space take by ignoreView as available (method checks if ignoreView is null)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// small optimization: we can skip to after the column we just found	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// an occupied cell	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if we failed to find anything, try again but without any requirements of	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// intersecting	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Called when drag has left this CellLayout or has been completed (successfully or not)     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This can actually be called when we arent in a drag, e.g. when adding a new	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// item to this layout via the customize drawer.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Guard against that case.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Invalidate the drag data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Mark a child as having been dropped.     * At the beginning of the drag operation, the child may have been on another     * screen, but it is re-parented before this method is called.     *     * @param child The child that is being dropped     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Computes a bounding rectangle for a range of cells     *     * @param cellX X coordinate of upper left corner expressed as a cell position     * @param cellY Y coordinate of upper left corner expressed as a cell position     * @param cellHSpan Width in cells     * @param cellVSpan Height in cells     * @param resultRect Rect into which to put the results     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Computes the required horizontal and vertical cell spans to always     * fit the given rectangle.     *     * @param width Width in pixels     * @param height Height in pixels     * @param result An array of length 2 in which to store the result (may be null).     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Always assume were working with the smallest span to make sure we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// reserve enough space in both orientations.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Always round up to next largest cell	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Calculate the grid spans needed to fit given item     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Its not a widget, so it must be 1x1	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Find the first vacant cell, if there is one.     *     * @param vacant Holds the x and y coordinate of the vacant cell     * @param spanX Horizontal cell span.     * @param spanY Vertical cell span.     *     * @return True if a vacant cell was found     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// We make sure to end only after a full period	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We make sure to end only after a full period	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Copy current state into savedMap	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore current state from savedMap	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lazy-create inflater	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Use the convert-view where possible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the text	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lazy-create inflater	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Use the convert-view where possible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the text	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Make sure its stopped before we modify any values	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// TODO: We dont really need to do the animation if startValue == toValue, but	UNKNOWN	WITHOUT_CLASSIFICATION	0.850	0.000
// somehow that doesnt seem to work, possibly a quirk of the animation framework	UNKNOWN	WITHOUT_CLASSIFICATION	0.989	0.000
// Ensure we dont calculate a non-sensical duration	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Return true when the animation is not running and it hasnt even been started.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This is the equivalent of calling Animator.start(), except that it can be called when     * the animation is running in the opposite direction, in which case we reverse     * direction and animate for a correspondingly shorter duration.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This is the roughly the equivalent of calling Animator.reverse(), except that it uses the     * same interpolation curve as animateIn(), rather than mirroring it. Also, like animateIn(),     * if the animation is currently running in the opposite direction, we reverse     * direction and animate for a correspondingly shorter duration.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.651	0.000
/**     * Remove any records for the supplied ComponentName.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Remove any records for the supplied package name.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Empty out the cache.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Empty out the cache that arent of the correct grid size     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Fill in application with the icon and label for info.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.983	0.000
/**     * Parse the appfilter.xml file from the selected icon pack.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Check if an icon is available in the current icon pack.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// null info means not installed, but if we have a component from the intent then	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we should still look in the cache for restored app icons.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Fill in shortcutInfo with the icon and label for info.     */	UNKNOWN	DESIGN	0.925	0.000
// null info means not installed, but if we have a component from the intent then	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we should still look in the cache for restored app icons.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Retrieves the entry from the cache. If the entry is not present, it creates a new entry.     * This method is not thread safe, it must be called from a synchronized method.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Adds a default package entry in the cache. This entry is not persisted and will be removed     * when the cache is flushed.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.985	0.000
/**     * Gets an entry for the package, which can be used as a fallback entry for various components.     * This method is not thread safe, it must be called from a synchronized method.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Pre-load an icon into the persistent cache.     *     * <P>Queries for a component that does not exist in the package manager     * will be answered by the persistent cache.     *     * @param context application context     * @param componentName the icon should be returned for this component     * @param icon the icon to be persisted     * @param dpi the native density of the icon     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// TODO rescale to the correct native DPI	UNKNOWN	DESIGN	0.650	0.000
// component is present on the system already, do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// pass	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Read a pre-loaded icon from the persistent icon cache.     *     * @param componentName the component that should own the icon     * @returns a bitmap if one is cached, or null.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont keep icons for other profiles in persistent cache.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Remove a pre-loaded icon from the persistent icon cache.     *     * @param componentName the component that should own the icon     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// We dont keep icons for other profiles in persistent cache.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Write the fields of this item to the DB     *      * @param context A context object to use for getting UserManagerCompat     * @param values     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// We should never persist an item on the extra empty screen.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try go guesstimate how much space the icon will take when serialized	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to avoid unnecessary allocations/copies during the write.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
/**     * It is very important that sub-classes implement this if they contain any references     * to the activity (anything in the view hierarchy etc.). If not, leaks can result since     * ItemInfo objects persist across rotation and can hence leak by holding stale references     * to the old view hierarchy / activity.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Helper method. Assumes a draw is pending, and that if the animations duration is 0	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// it should be cancelled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Use this as a signal that the animation was cancelled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Use this as a signal that the animation was cancelled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Were willing to let this slide. The exception is being caused by the list of	UNKNOWN	WITHOUT_CLASSIFICATION	0.982	0.000
// RemoteViews which is being passed back. The startListening relationship will	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// have been established by this point, and we will end up populating the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// widgets upon bind anyway. See issue 14255011 for more context.	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// Once we get the message that widget packages are updated, we need to rebind items	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// in AppsCustomize accordingly.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns true if the intent is a valid launch intent for a launcher activity of an app.     * This is used to identify shortcuts which are different from the ones exposed by the     * applications manifest file.     *     * @param launchIntent The intent that will be launched when the shortcut is clicked.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// An app target can either have no extra or have ItemInfo.EXTRA_PROFILE.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This name is only used for comparisons and notifications, so fall back to activity name	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if not supplied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Queue the item up for adding if launcher has not loaded properly yet	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Since its a custom shortcut, verify that it is safe to launch.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Target cannot be launched, or requires some special permission to launch	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//final Intent data = pendingInfo.data;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//final boolean allowDuplicate = data.getBooleanExtra(Launcher.EXTRA_SHORTCUT_DUPLICATE, true);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the intent specifies a package, make sure the package exists	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Generate a shortcut info to add into the model	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Notify the user once if we werent able to place any duplicates	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the new apps to the model and bind them	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns true if the intent is a valid launch intent for a shortcut.     * This is used to identify shortcuts which are different from the ones exposed by the     * applications manifest file.     *     * When DISABLE_ALL_APPS is true, shortcuts exposed via the apps manifest should never be     * duplicated or removed(unless the app is un-installed).     *     * @param launchIntent The intent that will be launched when the shortcut is clicked.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Ensures that we have a valid, non-null name.  If the provided name is null, we will return     * the application name instead.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Need a version that doesnt require an instance of LauncherAppState for the wallpaper picker	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Returns false on non-dogfood builds.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Call from Application.onTerminate(), which is not guaranteed to ever be called.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the database has ever changed, then we really need to force a reload of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// workspace on the next load	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the icon size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Updates the icons and label of all icons for the provided package name.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.994	0.000
/**     * When we bind the widget, we should notify the widget that the size has changed if we have not     * done so already (only really for default workspace widgets).     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Trigger an update callback to the widget to notify it that its size has changed.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.837	0.000
// Store the orientation in which the widget was inflated	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Re-inflate is required if the orientation has changed since last inflated.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Just in case the previous long press hasnt been cleared, we make sure to start fresh	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// on touch down.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Consume any touch events for ourselves after longpress is triggered	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Watch for longpress events at this level to make sure	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// users can always pick up this widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
// Otherwise continue letting touch events fall through to children	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the widget does not handle touch, then cancel	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// long press when we release the touch	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If a long press has been performed, we dont want to clear the record of that since	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we still may be receiving a touch up which we want to intercept	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Notify the backup manager that out database is dirty.     *     * <P>This does not force an immediate backup.     *     * @param context application context     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There is only one process accessing this preference file, but the restore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// modifies the file outside the normal codepaths, so it looks like another	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// process.  This forces a reload of the file, in case this process persists.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// No restore for old devices.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear dB before restore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If no favorite was migrated, clear the data and start fresh.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the restore fails, we should do a fresh start.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Disable the migration cling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Copy the shortcuts from the old database	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the flag to skip the folder cling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Disable the migration cling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Shows the migration cling.     *     * This flow is mutually exclusive with showFirstRunCling, and only runs if this Launcher     * package was not preinstalled and there exists a db to migrate from.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Show the longpress cling next	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Show the longpress cling next	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Show the longpress cling next	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is the first cling being shown. No need to animate.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animate	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Hides the specified Cling */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// To catch cases where siblings of top-level views are made invisible, just check whether	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the cling is directly set to GONE before dismissing it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns whether the clings are enabled or should be shown */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// disable clings when running in a test harness	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Disable clings for accessibility when explore by touch is enabled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restricted secondary users (child mode) will potentially have very few apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// seeded when they start up for the first time. Clings wont work well with that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont backup apps in other profiles for now.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Back up launcher data so we can restore the users state on a new device.     *     * <P>The journal is a timestamp and a list of keys that were saved as of that time.     *     * <P>Keys may come back in any order, so each key/value is one complete row of the database.     *     * @param oldState notes from the last backup     * @param data incremental key/value pairs to persist off-device     * @param newState notes for the next backup     * @throws IOException     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Restore launcher configuration from the restored data stream.     *     * <P>Keys may arrive in any order.     *     * @param data the key/value pair from the server     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//noinspection UnusedAssignment	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
/**     * Record the restore state for the next backup.     *     * @param newState notes about the backup state after restore.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clear the output journal time, to force a full backup to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// will catch any changes the restore process might have made	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Write all modified favorites to the data stream.     *     *     * @param in notes from last backup     * @param data output stream for key/value pairs     * @param out notes about this backup     * @param keys keys to mark as clean in the notes for next backup     * @throws IOException     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.770	0.000
// read the old ID set	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// persist things that have changed since the last backup	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont backup apps in other profiles for now.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// these IDs must have been deleted	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Read a favorite from the stream.     *     * <P>Keys arrive in any order, so screens and containers may not exist yet.     *     * @param key identifier for the row     * @param buffer the serialized proto from the stream, may be larger than dataSize     * @param dataSize the size of the proto from the stream     * @param keys keys to mark as clean in the notes for next backup     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Write all modified screens to the data stream.     *     *     * @param in notes from last backup     * @param data output stream for key/value pairs     * @param out notes about this backup     * @param keys keys to mark as clean in the notes for next backup     * @throws IOException     */	UNKNOWN	DESIGN	0.954	0.000
// read the old ID set	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// persist things that have changed since the last backup	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// these IDs must have been deleted	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Read a screen from the stream.     *     * <P>Keys arrive in any order, so children of this screen may already exist.     *     * @param key identifier for the row     * @param buffer the serialized proto from the stream, may be larger than dataSize     * @param dataSize the size of the proto from the stream     * @param keys keys to mark as clean in the notes for next backup     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Write all the static icon resources we need to render placeholders     * for a package that is not installed.     *     * @param in notes from last backup     * @param data output stream for key/value pairs     * @param out notes about this backup     * @param keys keys to mark as clean in the notes for next backup     * @throws IOException     */	UNKNOWN	DESIGN	0.999	0.000
// persist icons that havent been persisted yet	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// try again later	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// read the old ID set	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// remember that we already backed this up previously	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// too many icons for this pass, request another.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// these IDs must have been deleted	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Read an icon from the stream.     *     * <P>Keys arrive in any order, so shortcuts that use this icon may already exist.     *     * @param key identifier for the row     * @param buffer the serialized proto from the stream, may be larger than dataSize     * @param dataSize the size of the proto from the stream     * @param keys keys to mark as clean in the notes for next backup     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Write all the static widget resources we need to render placeholders     * for a package that is not installed.     *     * @param in notes from last backup     * @param data output stream for key/value pairs     * @param out notes about this backup     * @param keys keys to mark as clean in the notes for next backup     * @throws IOException     */	UNKNOWN	DESIGN	1.000	0.000
// persist static widget info that hasnt been persisted yet	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// read the old ID set	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// remember that we already backed this up previously	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// too many widgets for this pass, request another.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// these IDs must have been deleted	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Read a widget from the stream.     *     * <P>Keys arrive in any order, so widgets that use this data may already exist.     *     * @param key identifier for the row     * @param buffer the serialized proto from the stream, may be larger than dataSize     * @param dataSize the size of the proto from the stream     * @param keys keys to mark as clean in the notes for next backup     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
//else {	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// future site of widget table mutation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//}	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** create a new key, with an integer ID.     *     * <P> Keys contain their own checksum instead of using     * the heavy-weight CheckedMessage wrapper.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
/** create a new key for a named object.     *     * <P> Keys contain their own checksum instead of using     * the heavy-weight CheckedMessage wrapper.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
/** keys need to be strings, serialize and encode. */	UNKNOWN	WITHOUT_CLASSIFICATION	0.989	0.000
/** keys need to be strings, decode and parse. */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/** Compute the checksum over the important bits of a key. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Serialize a Favorite for persistence, including a checksum wrapper. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Deserialize a Favorite from persistence, after verifying checksum wrapper. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Let LauncherModel know weve been here.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/** Serialize a Screen for persistence, including a checksum wrapper. */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
/** Deserialize a Screen from persistence, after verifying checksum wrapper. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Serialize an icon Resource for persistence, including a checksum wrapper. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Deserialize an icon resource from persistence, after verifying checksum wrapper. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Serialize a widget for persistence, including a checksum wrapper. */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/** Deserialize a widget from persistence, after verifying checksum wrapper. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Read the old journal from the input file.     *     * In the event of any error, just pretend we didnt have a journal,     * in that case, do a full backup.     *     * @param oldState the read-0only file descriptor pointing to the old journal     * @return a Journal protocol buffer     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// OMG what are you doing? This is crazy inefficient!	UNKNOWN	DESIGN	1.000	0.000
// If we read a byte that is not ours, we will cause trouble: b/12491813	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// However, we dont know how many bytes to expect (oops).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// So we have to step through *slowly*, watching for the end.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// stop reading and see what there is to parse	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check the buffer to see if we have a valid journal	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if we are here, then we have read a valid, checksum-verified journal	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if we dont have the whole journal yet, mergeFrom will throw. keep going.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Write the new journal to the output file.     *     * In the event of any error, just pretend we didnt have a journal,     * in that case, do a full backup.     * @param newState the write-only file descriptor pointing to the new journal     * @param journal a Journal protocol buffer     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Wrap a proto in a CheckedMessage and compute the checksum. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Unwrap a proto message from a CheckedMessage, verifying the checksum. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check if the launcher is in a state to support backup	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// launcher data has been wiped, do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// launcher services are unavailable, try again later	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pin to mMinY <= mCurrY <= mMaxY	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * The amount of friction applied to flings. The default value     * is {@link ViewConfiguration#getScrollFriction}.     *     * @param friction A scalar dimension-less value representing the coefficient of     *         friction.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// g (m/s^2)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// inch/meter	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// pixels per inch	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     *     * Returns whether the scroller has finished scrolling.     *     * @return True if the scroller has finished scrolling, false otherwise.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Force the finished field to a particular value.     *     * @param finished The new finished value.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns how long the scroll event will take, in milliseconds.     *     * @return The duration of the scroll in milliseconds.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
/**     * Returns the current X offset in the scroll.     *     * @return The new X offset as an absolute distance from the origin.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the current Y offset in the scroll.     *     * @return The new Y offset as an absolute distance from the origin.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the current velocity.     *     * @return The original velocity less the deceleration. Result may be     * negative.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the start X offset in the scroll.     *     * @return The start X offset as an absolute distance from the origin.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the start Y offset in the scroll.     *     * @return The start Y offset as an absolute distance from the origin.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns where the scroll will end. Valid only for fling scrolls.     *     * @return The final X offset as an absolute distance from the origin.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns where the scroll will end. Valid only for fling scrolls.     *     * @return The final Y offset as an absolute distance from the origin.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Call this when you want to know the new location.  If it returns true,     * the animation is not yet finished.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.888	0.000
// Pin to mMinX <= mCurrX <= mMaxX	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Start scrolling by providing a starting point and the distance to travel.     * The scroll will use the default value of 250 milliseconds for the     * duration.     *     * @param startX Starting horizontal scroll offset in pixels. Positive     *        numbers will scroll the content to the left.     * @param startY Starting vertical scroll offset in pixels. Positive numbers     *        will scroll the content up.     * @param dx Horizontal distance to travel. Positive numbers will scroll the     *        content to the left.     * @param dy Vertical distance to travel. Positive numbers will scroll the     *        content up.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
/**     * Start scrolling by providing a starting point, the distance to travel,     * and the duration of the scroll.     *     * @param startX Starting horizontal scroll offset in pixels. Positive     *        numbers will scroll the content to the left.     * @param startY Starting vertical scroll offset in pixels. Positive numbers     *        will scroll the content up.     * @param dx Horizontal distance to travel. Positive numbers will scroll the     *        content to the left.     * @param dy Vertical distance to travel. Positive numbers will scroll the     *        content up.     * @param duration Duration of the scroll in milliseconds.     */	UNKNOWN	DESIGN	0.636	0.000
/**     * Start scrolling based on a fling gesture. The distance travelled will     * depend on the initial velocity of the fling.     *     * @param startX Starting point of the scroll (X)     * @param startY Starting point of the scroll (Y)     * @param velocityX Initial velocity of the fling (X) measured in pixels per     *        second.     * @param velocityY Initial velocity of the fling (Y) measured in pixels per     *        second     * @param minX Minimum X value. The scroller will not scroll past this     *        point.     * @param maxX Maximum X value. The scroller will not scroll past this     *        point.     * @param minY Minimum Y value. The scroller will not scroll past this     *        point.     * @param maxY Maximum Y value. The scroller will not scroll past this     *        point.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.909	0.000
// Continue a scroll or fling in progress	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pin to mMinX <= mFinalX <= mMaxX	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pin to mMinY <= mFinalY <= mMaxY	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 1/e == exp(-1)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Stops the animation. Contrary to {@link #forceFinished(boolean)},     * aborting the animating cause the scroller to move to the final x and y     * position     *     * @see #forceFinished(boolean)     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Extend the scroll animation. This allows a running animation to scroll     * further and longer, when used with {@link #setFinalX(int)} or {@link #setFinalY(int)}.     *     * @param extend Additional time to scroll in milliseconds.     * @see #setFinalX(int)     * @see #setFinalY(int)     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the time elapsed since the beginning of the scrolling.     *     * @return The elapsed time in milliseconds.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Sets the final position (X) for this scroller.     *     * @param newX The new X offset as an absolute distance from the origin.     * @see #extendDuration(int)     * @see #setFinalY(int)     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Sets the final position (Y) for this scroller.     *     * @param newY The new Y offset as an absolute distance from the origin.     * @see #extendDuration(int)     * @see #setFinalX(int)     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * @hide     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * The content:// style URL for a given row, identified by its id.         *         * @param id The row id.         * @param notify True to send a notification is the content changes.         *         * @return The unique content URL for the specified row.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * The content:// style URL for a given row, identified by its id.         *         * @param id The row id.         * @param notify True to send a notification is the content changes.         *         * @return The unique content URL for the specified row.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is the first time we get a handle to the internal ValueAnimator	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// used by the ViewPropertyAnimator.	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// FirstFrameAnimatorHelper hooks itself up to the updates on the animator,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// and then adjusts the play time to keep the first two frames jank-free	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Not supported and throws an exception when used.     */	UNKNOWN	DESIGN	0.683	0.000
/**     * Not supported and throws an exception when used.     */	UNKNOWN	DESIGN	0.683	0.000
/**     * Not supported and throws an exception when used.     */	UNKNOWN	DESIGN	0.683	0.000
// 256K	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ugh, whatever	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// will block	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log.v(TAG, update: pid  + pid +  pss= + info.currentPss +  uss= + info.currentUss);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// catch up in case we crashed but other processes are still running	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// they sent us a bad intent	UNKNOWN	WITHOUT_CLASSIFICATION	0.967	0.000
// in rare cases the receiver races with the application to set up LauncherAppState	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the current icon pack was deleted, we reload the icons.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//  DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)	UNKNOWN	WITHOUT_CLASSIFICATION	0.990	0.000
// In very limited cases, we support system|signature permission apps to add to the db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// always notify the backup agent	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is only required one time while loading the workspace during the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// upgrade path, and should never be called from anywhere else.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Should we load the old db for upgrade? first run only.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Clears all the data for a fresh start.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Loads the default workspace based on the following priority scheme:     *   1) From a package provided by play store     *   2) From a partner configuration APK, already in the system image     *   3) The default configuration for the particular device     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.564	0.000
// Populate favorites table with initial favorites	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont import the old databse for tablets, as the grid size has changed.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Are you sure? (y/n)	UNKNOWN	WITHOUT_CLASSIFICATION	0.990	0.000
/**         * Send notification that weve deleted the {@link AppWidgetHost},         * probably as part of the initial database creation. The receiver may         * want to re-call {@link AppWidgetHost#startListening()} to ensure         * callbacks are correctly set.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Database was just created, so wipe any previous widgets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try converting the old database	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try and upgrade from the Launcher2 db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we fail, then set a flag to load the default workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Right now, in non-default workspace cases, we want to run the final	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// upgrade code (ie. to fix workspace screen indices -> ids, etc.), so	UNKNOWN	WITHOUT_CLASSIFICATION	0.537	0.000
// set that flag too.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fresh and clean launcher DB.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete items directly on the workspace whos screen id doesnt exist	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//   AND container = -100	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete items contained in folders which no longer exist (after above statement)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//  DELETE FROM favorites  WHERE container <> -100 AND container <> -101 AND container	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We rearrange the screens from the old launcher	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 12345 -> 34512	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We already have a favorites database in the old provider	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Convert widgets from this import into widgets	UNKNOWN	WITHOUT_CLASSIFICATION	0.849	0.000
// Update max item id	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// upgrade 1,2 -> 3 added appWidgetId column	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Insert new column for holding appWidgetIds	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Convert existing widgets only if table upgrade was successful	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Wheres version 5?	UNKNOWN	WITHOUT_CLASSIFICATION	0.990	0.000
// - Donut and sholes on 2.0 shipped with version 4 of launcher1.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// - Passion shipped on 2.1 with version 6 of launcher3	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// - Sholes shipped on 2.1r1 (aka Mr. 3) with version 5 of launcher 1	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//   but version 5 on there was the updateContactsShortcuts change	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//   which was version 6 in launcher 2 (first shipped on passion 2.1r1).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The updateContactsShortcuts change is idempotent, so running it twice	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is okay so well do that when upgrading the devices that shipped with it.	UNKNOWN	WITHOUT_CLASSIFICATION	0.986	0.000
// We went from 3 to 5 screens. Move everything 1 to the right	UNKNOWN	WITHOUT_CLASSIFICATION	0.955	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We added the fast track.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Version 7 gets rid of the special search widget.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Version 8 (froyo) has the icons all normalized.  This should	UNKNOWN	WITHOUT_CLASSIFICATION	0.975	0.000
// already be the case in practice, but we now rely on it and dont	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// resample the images each time.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The max id is not yet set at this point (onUpgrade is triggered in the ctor	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// before it gets a change to get set, so we need to read it here when we use it)	UNKNOWN	DESIGN	0.674	0.000
// Add default hotseat icons	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We bumped the version three time during JB, once to update the launch flags, once to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the override for the default launch animation and once to set the mimetype	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to improve startup performance	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// Contact shortcuts need a different set of flags to be launched now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The updateContactsShortcuts change is idempotent, so we can keep using it like	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// back in the Donut days	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// With the new shrink-wrapped and re-orderable workspaces, it makes sense	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to persist workspace screens and their relative order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This will never happen in the wild, but when we switch to using workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// screen ids, redo the import from old launcher.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Insert new column for holding widget provider name	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Insert new column for holding update timestamp	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Insert new column for holding restore status	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We use the db version upgrade here to identify users who may not have seen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clings yet (because they werent available), but for whom the clings are now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// available (tablet users). Because one of the possible cling flows (migration)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is very destructive (wipes out workspaces), we want to prevent this from showing	UNKNOWN	WITHOUT_CLASSIFICATION	0.729	0.000
// until clear data. We do so by marking that the clings have been shown.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// No-op	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Due to a data loss bug, some users may have items associated with screen ids	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// which no longer exist. Since this can cause other problems, and since the user	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// will never see these items anyway, we use database upgrade as an opportunity to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clean things up.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add userId column	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// else old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This shouldnt happen -- throw our hands up in the air and start over.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Clears all the data for a fresh start.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Default to the serial number of this user, for older	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shortcuts.	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
// Insert new column for holding user serial number	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select and iterate through each matching widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When starting from the launcher, start in a new, cleared task	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clear the whole thing preemptively here since	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// QuickContactActivity will finish itself when launching other	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// detail activities.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Determine the type and also put that in the shortcut	UNKNOWN	WITHOUT_CLASSIFICATION	0.976	0.000
// (that can speed up launch a bit)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Generates a new ID to use for an object in your database. This method should be only	UNKNOWN	WITHOUT_CLASSIFICATION	0.974	0.000
// called from the main UI thread. As an exception, we do call it when we call the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// constructor from the worker thread; however, this doesnt extend until after the	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// constructor is called, and we only pass a reference to LauncherProvider to LauncherApp	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// after that point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the result	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Generates a new ID to use for an workspace screen in your database. This method	UNKNOWN	WITHOUT_CLASSIFICATION	0.679	0.000
// should be only called from the main UI thread. As an exception, we do call it when we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// call the constructor from the worker thread; however, this doesnt extend until after the	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// constructor is called, and we only pass a reference to LauncherProvider to LauncherApp	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// after that point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the result	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Upgrade existing clock and photo frame widgets into their new widget         * equivalents.         */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Select and iterate through each matching widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Allocate and update database with new appWidgetId	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Original widgets might not have valid spans when upgrading	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: check return value	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// TODO: check return value	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// TODO: check return value	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// Update max item id	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 1. Ensure that externally added items have a valid item id	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 2. In the case of an app widget, and if no app widget id is specified, we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// attempt allocate and bind the widget.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add screen id if not present	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Returns true of screen id exists, or if successfully added	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the result	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//noinspection StatementWithEmptyBody	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: Use multiple loaders with fall-back and transaction.	UNKNOWN	DESIGN	1.000	0.000
// Add the screens specified by the items above	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that the max ids are initialized	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Loads the default set of favorite packages from an xml file.         *         * @param db The database to write the values into         * @param res The resources         * @param workspaceResourceId The specific container id of items to load         * @param screenIds The set of screenIds which are used by the favorites         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// recursively load some more favorites, why not?	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Assuming its a <favorite> at this point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This looks through the contained favorites (or meta-favorites) and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// attempts to add them as shortcuts in the fallback groups location	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// until one is added successfully.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Folder contents are nested in this XML file	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Folder contents come from an external XML resource	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Keep track of the set of screens which need to be added to the db.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Parse folder items starting at {@link XmlPullParser} location. Allow recursive         * includes of items.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Parse folder starting at current {@link XmlPullParser} location.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We can only have folders with >= 2 items, so we need to remove the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// folder and clean up if less than 2 items were included, or some	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// failed to add, and less than 2 were actually added	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we have a single item, promote it to where the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// would have been.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// A meta shortcut attempts to resolve an intent specified as a URI in the XML, if a	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// logical choice for what shortcut should be used for that intent exists, then it is	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// added. Otherwise add nothing.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Verify that the result is an app and not just the resolver dialog asking which	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// app to use.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If only one of the results is a system app then choose that as the default.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There is no logical choice for this meta-favorite, so rather than making	UNKNOWN	WITHOUT_CLASSIFICATION	0.954	0.000
// a bad choice just add nothing.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the list contains the above resolved activity, then it cant be	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ResolverActivity itself.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If no component specified try to find a shortcut to add from the URI.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Gets an appwidget provider from the given package. If the package contains more than         * one appwidget provider, an arbitrary one is returned.         */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Read the extras	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: need to check return value	UNKNOWN	DESIGN	0.505	0.000
// Send a broadcast to configure the widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.927	0.000
// Oh well	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We already have a favorites database in the old provider	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Default to the serial number of this user, for older	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shortcuts.	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
// bogus intent?	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no intent? no icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// component no longer exists.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dedupe icons directly on the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	0.971	0.000
// Canonicalize	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the Play Store sets the package parameter, but Launcher	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// does not, so we clear that out to keep them the same.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Also ignore intent flags for the purposes of deduping.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In a folder, preserve position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For items contained directly on one of the workspace screen,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// well determine their location (screen, x, y) in a second pass.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Folders first	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Then shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Layout all the folders	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Hotseat items and folder items have already had their	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// location information set. Nothing to be done here.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Leave the last row of icons blank on every screen	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// ensure that new screens are created to hold these icons	UNKNOWN	WITHOUT_CLASSIFICATION	0.984	0.000
// Update max IDs; very important since we just grabbed IDs from another database	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Build a query string that will match any row where the column matches     * anything in the values list.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Return attribute value, attempting launcher-specific namespace first     * before falling back to anonymous attribute.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Return attribute resource value, attempting launcher-specific namespace     * first before falling back to anonymous attribute.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// (that can speed up launch a bit)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Determine the type and also put that in the shortcut	UNKNOWN	WITHOUT_CLASSIFICATION	0.976	0.000
// The max id is not yet set at this point (onUpgrade is triggered in the ctor	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**         * Send notification that weve deleted the {@link AppWidgetHost},         * probably as part of the initial database creation. The receiver may         * want to re-call {@link AppWidgetHost#startListening()} to ensure         * callbacks are correctly set.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Database was just created, so wipe any previous widgets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try converting the old database	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try and upgrade from the Launcher2 db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we fail, then set a flag to load the default workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Right now, in non-default workspace cases, we want to run the final	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// upgrade code (ie. to fix workspace screen indices -> ids, etc.), so	UNKNOWN	WITHOUT_CLASSIFICATION	0.537	0.000
// set that flag too.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fresh and clean launcher DB.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete items directly on the workspace whos screen id doesnt exist	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//  DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)	UNKNOWN	WITHOUT_CLASSIFICATION	0.990	0.000
//   AND container = -100	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete items contained in folders which no longer exist (after above statement)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//  DELETE FROM favorites  WHERE container <> -100 AND container <> -101 AND container	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We rearrange the screens from the old launcher	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 12345 -> 34512	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We already have a favorites database in the old provider	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Convert widgets from this import into widgets	UNKNOWN	WITHOUT_CLASSIFICATION	0.849	0.000
// Update max item id	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// upgrade 1,2 -> 3 added appWidgetId column	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Insert new column for holding appWidgetIds	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Convert existing widgets only if table upgrade was successful	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Wheres version 5?	UNKNOWN	WITHOUT_CLASSIFICATION	0.990	0.000
// - Donut and sholes on 2.0 shipped with version 4 of launcher1.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// - Passion shipped on 2.1 with version 6 of launcher3	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// - Sholes shipped on 2.1r1 (aka Mr. 3) with version 5 of launcher 1	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//   but version 5 on there was the updateContactsShortcuts change	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//   which was version 6 in launcher 2 (first shipped on passion 2.1r1).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The updateContactsShortcuts change is idempotent, so running it twice	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is okay so well do that when upgrading the devices that shipped with it.	UNKNOWN	WITHOUT_CLASSIFICATION	0.986	0.000
// We went from 3 to 5 screens. Move everything 1 to the right	UNKNOWN	WITHOUT_CLASSIFICATION	0.955	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We added the fast track.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Version 7 gets rid of the special search widget.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Version 8 (froyo) has the icons all normalized.  This should	UNKNOWN	WITHOUT_CLASSIFICATION	0.975	0.000
// already be the case in practice, but we now rely on it and dont	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// resample the images each time.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// before it gets a change to get set, so we need to read it here when we use it)	UNKNOWN	DESIGN	0.674	0.000
// Add default hotseat icons	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We bumped the version three time during JB, once to update the launch flags, once to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the override for the default launch animation and once to set the mimetype	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to improve startup performance	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// Contact shortcuts need a different set of flags to be launched now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The updateContactsShortcuts change is idempotent, so we can keep using it like	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// back in the Donut days	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// With the new shrink-wrapped and re-orderable workspaces, it makes sense	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to persist workspace screens and their relative order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This will never happen in the wild, but when we switch to using workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// screen ids, redo the import from old launcher.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Insert new column for holding widget provider name	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Insert new column for holding update timestamp	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Insert new column for holding restore status	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We use the db version upgrade here to identify users who may not have seen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clings yet (because they werent available), but for whom the clings are now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// available (tablet users). Because one of the possible cling flows (migration)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is very destructive (wipes out workspaces), we want to prevent this from showing	UNKNOWN	WITHOUT_CLASSIFICATION	0.729	0.000
// until clear data. We do so by marking that the clings have been shown.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// No-op	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Due to a data loss bug, some users may have items associated with screen ids	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// which no longer exist. Since this can cause other problems, and since the user	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// will never see these items anyway, we use database upgrade as an opportunity to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clean things up.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add userId column	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// else old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This shouldnt happen -- throw our hands up in the air and start over.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Clears all the data for a fresh start.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Default to the serial number of this user, for older	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shortcuts.	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
// Insert new column for holding user serial number	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Old version remains, which means we wipe old data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Select and iterate through each matching widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When starting from the launcher, start in a new, cleared task	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// CLEAR_WHEN_TASK_RESET cannot reset the root of a task, so we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clear the whole thing preemptively here since	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// QuickContactActivity will finish itself when launching other	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// detail activities.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Generates a new ID to use for an object in your database. This method should be only	UNKNOWN	WITHOUT_CLASSIFICATION	0.974	0.000
// called from the main UI thread. As an exception, we do call it when we call the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// constructor from the worker thread; however, this doesnt extend until after the	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// constructor is called, and we only pass a reference to LauncherProvider to LauncherApp	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// after that point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the result	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Generates a new ID to use for an workspace screen in your database. This method	UNKNOWN	WITHOUT_CLASSIFICATION	0.679	0.000
// should be only called from the main UI thread. As an exception, we do call it when we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// call the constructor from the worker thread; however, this doesnt extend until after the	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// constructor is called, and we only pass a reference to LauncherProvider to LauncherApp	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// after that point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the result	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Upgrade existing clock and photo frame widgets into their new widget         * equivalents.         */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Select and iterate through each matching widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Allocate and update database with new appWidgetId	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Original widgets might not have valid spans when upgrading	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: check return value	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// TODO: check return value	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// TODO: check return value	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// Update max item id	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 1. Ensure that externally added items have a valid item id	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 2. In the case of an app widget, and if no app widget id is specified, we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// attempt allocate and bind the widget.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add screen id if not present	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Returns true of screen id exists, or if successfully added	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the result	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//noinspection StatementWithEmptyBody	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: Use multiple loaders with fall-back and transaction.	UNKNOWN	DESIGN	1.000	0.000
// Add the screens specified by the items above	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that the max ids are initialized	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Loads the default set of favorite packages from an xml file.         *         * @param db The database to write the values into         * @param res The resources         * @param workspaceResourceId The specific container id of items to load         * @param screenIds The set of screenIds which are used by the favorites         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// recursively load some more favorites, why not?	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Assuming its a <favorite> at this point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This looks through the contained favorites (or meta-favorites) and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// attempts to add them as shortcuts in the fallback groups location	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// until one is added successfully.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Folder contents are nested in this XML file	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Folder contents come from an external XML resource	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Keep track of the set of screens which need to be added to the db.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Parse folder items starting at {@link XmlPullParser} location. Allow recursive         * includes of items.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Parse folder starting at current {@link XmlPullParser} location.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We can only have folders with >= 2 items, so we need to remove the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// folder and clean up if less than 2 items were included, or some	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// failed to add, and less than 2 were actually added	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we have a single item, promote it to where the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// would have been.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// A meta shortcut attempts to resolve an intent specified as a URI in the XML, if a	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// logical choice for what shortcut should be used for that intent exists, then it is	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// added. Otherwise add nothing.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Verify that the result is an app and not just the resolver dialog asking which	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// app to use.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If only one of the results is a system app then choose that as the default.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There is no logical choice for this meta-favorite, so rather than making	UNKNOWN	WITHOUT_CLASSIFICATION	0.954	0.000
// a bad choice just add nothing.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the list contains the above resolved activity, then it cant be	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// ResolverActivity itself.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If no component specified try to find a shortcut to add from the URI.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Gets an appwidget provider from the given package. If the package contains more than         * one appwidget provider, an arbitrary one is returned.         */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Read the extras	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: need to check return value	UNKNOWN	DESIGN	0.505	0.000
// Send a broadcast to configure the widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.927	0.000
// Oh well	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We already have a favorites database in the old provider	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Default to the serial number of this user, for older	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shortcuts.	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
// bogus intent?	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no intent? no icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// component no longer exists.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dedupe icons directly on the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	0.971	0.000
// Canonicalize	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the Play Store sets the package parameter, but Launcher	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// does not, so we clear that out to keep them the same.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Also ignore intent flags for the purposes of deduping.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In a folder, preserve position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For items contained directly on one of the workspace screen,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// well determine their location (screen, x, y) in a second pass.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Folders first	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Then shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Layout all the folders	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Hotseat items and folder items have already had their	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// location information set. Nothing to be done here.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Leave the last row of icons blank on every screen	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// ensure that new screens are created to hold these icons	UNKNOWN	WITHOUT_CLASSIFICATION	0.984	0.000
// Update max IDs; very important since we just grabbed IDs from another database	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove all the previous children that are no longer in the window	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add all the new children that belong in the window	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the markers alpha	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Center the active marker	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Cancel long press for all children	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Generate an id for each view, this assumes we have at most 256x256 cells	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// per workspace screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the horizontal or vertical span is set to -1, it is taken to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mean that it spans the extent of the CellLayout	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Clears all the key listeners for the individual icons.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We only intercept the touch if we are tapping in empty space after the final row	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add a little bit of buffer if there is room for another row	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Always assume were working with the smallest span to make sure we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// reserve enough space in both orientations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Always round up to next largest cell	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Start dragging the specified child     *     * @param child The child that is being dragged     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Estimates the number of cells that the specified width would take up.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont show the next/previous pages any more, so we use the full width, minus the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// padding	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We know that we have to fit N cells with N-1 width gaps, so we just juggle to solve for N	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont do anything fancy to determine if we squeeze another row in.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Estimates the number of cells that the specified height would take up.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The space for a page is the height - top padding (current page) - bottom padding (current	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// page)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We know that we have to fit N cells with N-1 height gaps, so we juggle to solve for N	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont do anything fancy to determine if we squeeze another row in.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns an estimated center position of the cell at the specified index */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Estimates the width that the number of hSpan cells will take up.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: we need to take widthGap into effect	UNKNOWN	DESIGN	0.908	0.000
/**     * Estimates the height that the number of vSpan cells will take up.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: we need to take heightGap into effect	UNKNOWN	DESIGN	0.993	0.000
// Update the drawing caches	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Cancel long press for all children	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// determine the max width of all the rows and center accordingly	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
/**     * Clears all the key listeners for the individual widgets.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We only intercept the touch if we are tapping in empty space after the final row	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure we are using the right text size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// center horizontally	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Remove the longpress detection timer.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// We eat up the touch events here, since the PagedView (which uses the same swiping	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// touch code as Workspace previously) uses onInterceptTouchEvent() to determine when	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// the user is scrolling between pages.  This means that if the pages themselves dont	UNKNOWN	WITHOUT_CLASSIFICATION	0.849	0.000
// handle touch events, it gets forwarded up to PagedView itself, and its own	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// onTouchEvent() handling will prevent further intercept touch events from being called	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// (its the same view in that case).  This is not ideal, but to prevent more changes,	UNKNOWN	WITHOUT_CLASSIFICATION	0.905	0.000
// we just always mark the touch event as handled.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// wait no longer than 1sec at a time	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fail if we dont have any apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Sort the applications by name	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create the ApplicationInfos	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This builds the icon bitmaps.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Check if any workspace icons overlap with each other	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Clears all the sBg data structures */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Runs the specified runnable immediately if called from the main thread, otherwise it is     * posted on the main thread handler. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are on the worker thread, post onto the main handler	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Runs the specified runnable immediately if called from the worker thread, otherwise it is     * posted on the worker thread handler. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are not on the worker thread, then post to the worker handler	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on the app so that we dont try and get the items while apps are being added	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Flush the LauncherModel worker thread, so that if we just did another	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// processInstallShortcut, we give it time for its shortcut to get added to the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// database (getItemsInLocalCoordinates reads the database)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try adding to the workspace screens incrementally, starting at the default or center	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Update the Launcher db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Process the updated package state	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Process the updated package badge	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Process the newly added applications and add them to the database first	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Process the newly added applications and add them to the database first	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the list of workspace screens.  We need to append to this list and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// can not use sBgWorkspaceScreens because loadWorkspace() may not have been	UNKNOWN	WITHOUT_CLASSIFICATION	0.963	0.000
// called.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Short-circuit this logic if the icon exists somewhere on the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	0.980	0.000
// Only InstallShortcutReceiver sends us shortcutInfos, ignore them	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add this icon to the db, creating a new page if necessary.  If there	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is only the empty page then we just add items to the first page.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Otherwise, we add them to the next pages.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we cant find a valid position, then just add a new screen.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This takes time so we need to re-queue the add until the new	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// page is added.  Create as many screens as necessary to satisfy	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// the startSearchPageIndex.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Save the screen id for binding in the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the coordinate again	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the shortcut to the db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Save the ShortcutInfo for binding in the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the workspace screens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the list of workspace screens.  We need to append to this list and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// can not use sBgWorkspaceScreens because loadWorkspace() may not have been	UNKNOWN	WITHOUT_CLASSIFICATION	0.963	0.000
// called.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Short-circuit this logic if the icon exists somewhere on the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	0.980	0.000
// Only InstallShortcutReceiver sends us shortcutInfos, ignore them	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add this icon to the db, creating a new page if necessary.  If there	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is only the empty page then we just add items to the first page.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Otherwise, we add them to the next pages.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we cant find a valid position, then just add a new screen.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This takes time so we need to re-queue the add until the new	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// page is added.  Create as many screens as necessary to satisfy	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// the startSearchPageIndex.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Save the screen id for binding in the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the coordinate again	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the shortcut to the db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Save the ShortcutInfo for binding in the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the workspace screens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear any deferred bind runnables	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove any queued bind runnables	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Unbind all the workspace items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// Ensure that we dont use the same workspace items data structure on the main thread	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// by making a copy of workspace items first.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Adds an item to the DB if it was not created previously, or move it to a new     * <container, screen, cellX, cellY>     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// From all apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// From somewhere else	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check all the data is consistent	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For all intents and purposes, this is the same object	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the modelItem needs to match up perfectly with item if our model is	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to be consistent with the database-- for now, just require	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// modelItem == item or the equality check above	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Item is in a folder, make sure this folder exists	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// An items container is being set to a that of an item which is not in	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the list of Folders.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Query for the set of apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Items are added/removed from the corresponding FolderInfo elsewhere, such	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// as in Workspace.onDrop. Here, we just add/remove them from the list of items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// that are on the desktop, as appropriate	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Move an item in the DB to a new <container, screen, cellX, cellY>     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
/**     * Move items in the DB to a new <container, screen, cellX, cellY>. We assume that the     * cellX, cellY have already been updated on the ItemInfos.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
/**     * Move and/or resize item in the DB to a new <container, screen, cellX, cellY, spanX, spanY>     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Update an item to the database in a specified container.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns true if the shortcuts already exists in the database.     * we identify a shortcut by its title and intent.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If component is not null, an intent with null package will produce	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the same result and should also be a match.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns true if the promise shortcuts with the same package name exists on the workspace.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
/**     * Returns an ItemInfo array containing all the items in the LauncherModel.     * The ItemInfo.id is not set through this function.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.976	0.000
// Skip if user has been deleted.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Add an item to the database in a specified container. Sets the container, screen, cellX and     * cellY fields of the item. Also assigns an ID to the item.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fall through	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Adding an item to a folder that doesnt exist.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fall through	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Adding an item to a folder that doesnt exist.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Creates a new unique child id, for a given cell span across all layouts.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Removes all the items from the database corresponding to the specified package.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Removes the specified item from the database     * @param context     * @param item     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Removes the specified items from the database     * @param context     * @param item     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We are deleting a folder which still contains items that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// think they are contained by that folder.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We are deleting a folder which still contains items that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// think they are contained by that folder.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Update the order of the workspace screens in the database. The array list contains     * a list of screen ids in the order that they should appear.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove any negative screen ids -- these arent persisted	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Clear the table	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear the table	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Remove the contents of the specified folder from the database     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lock on mBgLock *after* the db operation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Set this as the current Launcher activity object for the loader.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only rebind if we support removable storage. It catches the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// case where	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// apps on the external sd card need to be reloaded	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// If we are replacing then just update the packages in the list	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and     * ACTION_PACKAGE_CHANGED.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// If we have changed locale we need to clear out the labels in all apps/workspace.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check if configuration change was an mcc/mnc change which would affect app resources	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// and we would need to clear out the labels in all apps/workspace. Same handling as	UNKNOWN	WITHOUT_CLASSIFICATION	0.986	0.000
// above for ACTION_LOCALE_CHANGED	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update previousConfig	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do this here because if the launcher activity is running it will be restarted.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If its not running startLoaderFromBackground will merely tell it that it needs	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to reload.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Stop any existing loaders first, so they dont set mAllAppsLoaded or	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mWorkspaceLoaded to true later	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * When the launcher is in the background, its possible for it to miss paired     * configuration changes.  So whenever we trigger the loader from the background     * tell the launcher that it needs to re-run the loader when it comes back instead     * of doing it now.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.947	0.000
// Only actually run the loader if theyre not paused.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If there is already a loader task running, tell it to stop.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// returns true if isLaunching() was true on the old task	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear any deferred bind-runnables from the synchronized load process	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We must do this before any loading/binding is scheduled below.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont bother to start the thread if we know its not going to do anything	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If there is already one running, tell it to stop.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// also, dont downgrade isLaunching if were already running	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Post the remaining side pages to be loaded	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Loads the workspace screens db into a map of Rank -> ScreenId */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns whether this is an upgrade path */	UNKNOWN	WITHOUT_CLASSIFICATION	0.957	0.000
// Load the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Bind the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Wait until the either were stopped or the other threads are done.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This way we dont start loading all apps until the workspace has settled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// down.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Just in case mFlushingWorkerThread changes but we arent woken up,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we have a valid page index to load synchronously	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we dont try and bind a specified page when the pages have not been	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// loaded already (we should load everything asynchronously in that case)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we are never running the background loading at this point since	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we also touch the background collections	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: Throw an exception if we are already loading (since we touch the worker thread	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
//      data structures, we cant allow any other thread to touch that data, but because	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//      this call is synchronous, we can get away with not locking).	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// The LauncherModel is static in the LauncherAppState and mHandler may have queued	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// operations from the previous activity.  We need to ensure that all queued operations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// are executed before any synchronous binding work is done.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Divide the set of loaded items into those that we are binding synchronously, and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// everything else that is to be bound normally (asynchronously).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: For now, continue posting the binding of AllApps as there are other issues that	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
//      arise from that.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Optimize for end-user experience: if the Launcher is up and // running with the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// All Apps interface in the foreground, load All Apps first. Otherwise, load the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// workspace first (default).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Elevate priority when Home launches for the first time to avoid	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// starving at boot time. Staring at a blank home is not cool.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Whew! Hard work done.  Slow us down, and wait until the UI thread has	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// settled down.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// second step	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the default thread priority after we are done loading items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the saved icons if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that all the applications that are in the system are	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// represented on the home screen.	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// Clear out this reference, otherwise we end up holding it until all of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// callback runnables are done.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are still the last one to be scheduled, remove ourselves.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Gets the callbacks object.  If weve been stopped, or if the launcher object         * has somehow been garbage collected, return null instead.  Pass in the Callbacks         * object that was around when the deferred message was scheduled, and if theres         * a new Callbacks object around then also return null.  This will save us from         * calling onto it with data that will be ignored.         */	UNKNOWN	WITHOUT_CLASSIFICATION	0.562	0.000
// Cross reference all the applications in our apps list with items in the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We are missing an application icon, so add this to the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is a rare event, so lets log it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check & update map of whats occupied; used to discard overlapping/invalid items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Skip further checking if it is not the hotseat or workspace container	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns whether this is an upgrade path */	UNKNOWN	WITHOUT_CLASSIFICATION	0.957	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// append the users Launcher2 shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Make sure the default workspace is loaded	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This code path is for our old migration code and should no longer be exercised	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// +1 for the hotseat (it can be larger than the workspace)	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Load workspace in reverse order to ensure that latest items are loaded first (and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// before any earlier duplicates)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//final int displayModeIndex = c.getColumnIndexOrThrow(	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//        LauncherSettings.Favorites.DISPLAY_MODE);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// User has been deleted remove the item.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no special handling necessary for this item	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We allow auto install apps to have their intent	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// updated after an install.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The app is installed but the component is no	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// longer available.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no special handling necessary for this item	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Package is not yet available but might be	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// installed later.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore has started once.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// App restore has started. Update the flag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do not wait for external media load anymore.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log the invalid package, and remove it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// SdCard is not ready yet. Package might get available,	UNKNOWN	WITHOUT_CLASSIFICATION	0.976	0.000
// once it is ready.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the icon on the workspace anyway.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For shortcuts with no component, keep them as they are	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont restore items for other profiles.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// App shortcuts that used to be automatically added to Launcher	UNKNOWN	WITHOUT_CLASSIFICATION	0.918	0.000
// didnt always have the correct intent flags set, so do that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// here	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// check & update map of whats occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Item is in a user folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// now that weve loaded everthing re-save it with the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// icon in case it disappears somehow.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check & update map of whats occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no special handling required for restored folders	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Read all Launcher-specific widget details	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If provider was not previously ready, update the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// status and UI flag.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Id would be valid only if the widget restore broadcast was received.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore has started once.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// App restore has started. Update the flag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check & update map of whats occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Break early if weve stopped loading	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove dead items	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Dont notify content observers	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update restored items that no longer require special handling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were importing we use the old screen order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the max item id after we load an old db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were importing we use the old screen order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove any empty screens	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// If there are any empty screens remove them, and update.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Filters the set of items who are directly or indirectly (via another container) on the         * specified screen. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Purge any null ItemInfos	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Order the set of items by their containers first, this allows use to walk through the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// list sequentially, build up a list of containers that are in the specified screen,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// as well as all items in those containers.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Filters the set of widgets which are on the specified screen. */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/** Filters the set of folders which are on the specified screen. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to         * right) */	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// XXX: review this	UNKNOWN	DESIGN	0.785	0.000
// +1 hotseat	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// +1 hotseat	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Bind the workspace items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Bind the folders	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Bind the widgets, one at a time	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Binds all loaded data to actual views on the main thread.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont use these two variables in any of the callback runnables.	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// Otherwise we hold a reference to them.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This launcher has exited and nobody bothered to tell us.  Just bail.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Save a copy of all the bg-thread collections	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There may be no workspace screens (just hotseat items and an empty page).	UNKNOWN	DESIGN	0.527	0.000
// Load all the items that are on the current page first (and in the process, unbind	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// all the existing workspace items before we call startBinding() below.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Separate the items that are on the current screen, and all the other remaining items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Tell the workspace that were about to start binding items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load items on the current page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load all the remaining pages (if we are loading synchronously, we want to defer this	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// work until after the first render)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Tell the workspace that were done binding items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were profiling, ensure this is the last thing in the queue.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were profiling, ensure this is the last thing in the queue.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This launcher has exited and nobody bothered to tell us.  Just bail.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shallow copy	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This launcher has exited and nobody bothered to tell us.  Just bail.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear the list of apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Huh? Shouldnt this be inside the Runnable below?	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// Post callback on main thread	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD     * runnable was missed by the launcher.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// Ensure that we add all the workspace applications to the db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the launcher db to reflect the changes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mark all packages in the broadcast to be removed	UNKNOWN	WITHOUT_CLASSIFICATION	0.795	0.000
// Mark disabled packages in the broadcast to be removed	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// Remove all the components associated with this package	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove all the specific components	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove any queued items from the install queue	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Call the components-removed callback	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Write all the logs to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the new data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Returns a list of ResolveInfos/AppWindowInfos in sorted order	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Make an ShortcutInfo object for a restored application or shortcut item that points     * to a package that is not yet installed on the system.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Make an Intent object for a restored application or shortcut item that points     * to the market page for the item.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This is called from the code that adds shortcuts from the intent receiver.  This     * doesnt have a Cursor, but     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Make an ShortcutInfo object for a shortcut that is an application.     *     * If c is not null, then it will be used to fill in missing data like the title and icon.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// the resource -- This may implicitly give us back the fallback icon,	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// but dont worry about that.  All were doing with usingFallbackIcon is	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to avoid saving lots of copies of that in the database, and most apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// have icons anyway.	UNKNOWN	WITHOUT_CLASSIFICATION	0.985	0.000
// the db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the fallback icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// From the cache.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// from the resource	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// from the db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// fall back to the class name of the activity	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We need to check for ACTION_MAIN otherwise getComponent() might	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// return null for some shortcuts (for instance, for shortcuts to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// web pages.)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// placeholder shortcuts get special treatment, let them through too.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Make an ShortcutInfo object for a shortcut that isnt an application.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.984	0.000
// Non-app shortcuts are only supported for current user.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: If theres an explicit component and we cant install that, delete it.	UNKNOWN	DESIGN	0.950	0.000
// the resource	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drop this.  we have other places to look for icons	UNKNOWN	WITHOUT_CLASSIFICATION	0.916	0.000
// the db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the fallback icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// suppress dead code warning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Attempts to find an AppWidgetProviderInfo that matches the given component.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the intent is null, we cant construct a valid ShortcutInfo, so we return null	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only support intents for current user for now. Intents sent from other	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// users wouldnt get here without intent forwarding anyway.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If apps cant be on SD, dont even bother.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If this icon doesnt have a custom icon, check to see	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// whats stored in the DB, and if it doesnt match what	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// were going to show, store what we are going to show back	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// into the DB.  We do this so when were loading, if the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// package manager cant find an icon (for example because	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the app is on SD) then we can use that instead.	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// This is slower than is ideal, but this only happens once	UNKNOWN	WITHOUT_CLASSIFICATION	0.966	0.000
// or when the app is updated with a new icon.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Return an existing FolderInfo object if we have encountered this ID previously,     * or make a new one.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// See if a placeholder was created for us already	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// No placeholder -- create a new instance	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// TODO Need to figure out rules for sorting	UNKNOWN	DESIGN	0.664	0.000
// profiles, this puts work second.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO Need to figure out rules for sorting	UNKNOWN	DESIGN	0.664	0.000
// profiles, this puts work second.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns whether this is an upgrade path */	UNKNOWN	WITHOUT_CLASSIFICATION	0.957	0.000
// Load the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Bind the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Wait until the either were stopped or the other threads are done.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This way we dont start loading all apps until the workspace has settled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// down.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Just in case mFlushingWorkerThread changes but we arent woken up,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// wait no longer than 1sec at a time	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we have a valid page index to load synchronously	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we dont try and bind a specified page when the pages have not been	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// loaded already (we should load everything asynchronously in that case)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we are never running the background loading at this point since	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we also touch the background collections	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: Throw an exception if we are already loading (since we touch the worker thread	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
//      data structures, we cant allow any other thread to touch that data, but because	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//      this call is synchronous, we can get away with not locking).	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// The LauncherModel is static in the LauncherAppState and mHandler may have queued	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// operations from the previous activity.  We need to ensure that all queued operations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// are executed before any synchronous binding work is done.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Divide the set of loaded items into those that we are binding synchronously, and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// everything else that is to be bound normally (asynchronously).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: For now, continue posting the binding of AllApps as there are other issues that	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
//      arise from that.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Optimize for end-user experience: if the Launcher is up and // running with the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// All Apps interface in the foreground, load All Apps first. Otherwise, load the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// workspace first (default).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Elevate priority when Home launches for the first time to avoid	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// starving at boot time. Staring at a blank home is not cool.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Whew! Hard work done.  Slow us down, and wait until the UI thread has	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// settled down.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// second step	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the default thread priority after we are done loading items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the saved icons if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that all the applications that are in the system are	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// represented on the home screen.	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// Clear out this reference, otherwise we end up holding it until all of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// callback runnables are done.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are still the last one to be scheduled, remove ourselves.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Gets the callbacks object.  If weve been stopped, or if the launcher object         * has somehow been garbage collected, return null instead.  Pass in the Callbacks         * object that was around when the deferred message was scheduled, and if theres         * a new Callbacks object around then also return null.  This will save us from         * calling onto it with data that will be ignored.         */	UNKNOWN	WITHOUT_CLASSIFICATION	0.562	0.000
// Cross reference all the applications in our apps list with items in the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We are missing an application icon, so add this to the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is a rare event, so lets log it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check & update map of whats occupied; used to discard overlapping/invalid items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Skip further checking if it is not the hotseat or workspace container	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check if any workspace icons overlap with each other	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Clears all the sBg data structures */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Returns whether this is an upgrade path */	UNKNOWN	WITHOUT_CLASSIFICATION	0.957	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// append the users Launcher2 shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Make sure the default workspace is loaded	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This code path is for our old migration code and should no longer be exercised	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// +1 for the hotseat (it can be larger than the workspace)	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Load workspace in reverse order to ensure that latest items are loaded first (and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// before any earlier duplicates)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//final int displayModeIndex = c.getColumnIndexOrThrow(	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//        LauncherSettings.Favorites.DISPLAY_MODE);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// User has been deleted remove the item.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no special handling necessary for this item	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We allow auto install apps to have their intent	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// updated after an install.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The app is installed but the component is no	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// longer available.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no special handling necessary for this item	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Package is not yet available but might be	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// installed later.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore has started once.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// App restore has started. Update the flag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do not wait for external media load anymore.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log the invalid package, and remove it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// SdCard is not ready yet. Package might get available,	UNKNOWN	WITHOUT_CLASSIFICATION	0.976	0.000
// once it is ready.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the icon on the workspace anyway.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For shortcuts with no component, keep them as they are	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont restore items for other profiles.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// App shortcuts that used to be automatically added to Launcher	UNKNOWN	WITHOUT_CLASSIFICATION	0.918	0.000
// didnt always have the correct intent flags set, so do that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// here	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// check & update map of whats occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Item is in a user folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// now that weve loaded everthing re-save it with the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// icon in case it disappears somehow.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check & update map of whats occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no special handling required for restored folders	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Read all Launcher-specific widget details	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If provider was not previously ready, update the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// status and UI flag.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Id would be valid only if the widget restore broadcast was received.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore has started once.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// App restore has started. Update the flag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check & update map of whats occupied	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Break early if weve stopped loading	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove dead items	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Dont notify content observers	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update restored items that no longer require special handling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were importing we use the old screen order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the max item id after we load an old db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were importing we use the old screen order.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove any empty screens	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// If there are any empty screens remove them, and update.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Filters the set of items who are directly or indirectly (via another container) on the         * specified screen. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Purge any null ItemInfos	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Order the set of items by their containers first, this allows use to walk through the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// list sequentially, build up a list of containers that are in the specified screen,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// as well as all items in those containers.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Filters the set of widgets which are on the specified screen. */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/** Filters the set of folders which are on the specified screen. */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to         * right) */	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// XXX: review this	UNKNOWN	DESIGN	0.785	0.000
// +1 hotseat	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// +1 hotseat	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Bind the workspace items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Bind the folders	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Bind the widgets, one at a time	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**         * Binds all loaded data to actual views on the main thread.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont use these two variables in any of the callback runnables.	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// Otherwise we hold a reference to them.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This launcher has exited and nobody bothered to tell us.  Just bail.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Save a copy of all the bg-thread collections	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There may be no workspace screens (just hotseat items and an empty page).	UNKNOWN	DESIGN	0.527	0.000
// Load all the items that are on the current page first (and in the process, unbind	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// all the existing workspace items before we call startBinding() below.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Separate the items that are on the current screen, and all the other remaining items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Tell the workspace that were about to start binding items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load items on the current page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load all the remaining pages (if we are loading synchronously, we want to defer this	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// work until after the first render)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Tell the workspace that were done binding items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were profiling, ensure this is the last thing in the queue.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were profiling, ensure this is the last thing in the queue.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This launcher has exited and nobody bothered to tell us.  Just bail.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shallow copy	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This launcher has exited and nobody bothered to tell us.  Just bail.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear the list of apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Query for the set of apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Fail if we dont have any apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Sort the applications by name	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create the ApplicationInfos	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This builds the icon bitmaps.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Huh? Shouldnt this be inside the Runnable below?	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// Post callback on main thread	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Write all the logs to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the new data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we add all the workspace applications to the db	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the launcher db to reflect the changes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mark all packages in the broadcast to be removed	UNKNOWN	WITHOUT_CLASSIFICATION	0.795	0.000
// Mark disabled packages in the broadcast to be removed	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// Remove all the components associated with this package	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove all the specific components	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove any queued items from the install queue	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Call the components-removed callback	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return early if this is not initiated from a touch	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return early if we are still animating the pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When we have exited all apps or are in transition, disregard long clicks	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return if global dragging is not enabled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * Determines if we should change the touch state to start scrolling after the     * user moves their touch point too far.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * Determines if we should change the touch state to start dragging after the     * user moves their touch point far enough.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*         * Locally do absolute value. mLastMotionX is set to the y value         * of the down event.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Drag if the user moved far enough along the Y axis	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Cancel any pending long press	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try canceling the long press. It could also have been scheduled	UNKNOWN	WITHOUT_CLASSIFICATION	0.835	0.000
// by a distant descendant, so use the mAllowLongPress flag to block	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// everything	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Find and return partner details, or {@code null} if none exists.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We initialize customizable fields to be invalid	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the hover color	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the text in the Phone UI in landscape	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// acceptDrop is called just before onDrop. We do the work here, rather than	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in onDrop, because it allows us to reject the drop (by returning false)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// so that the object being dragged isnt removed from the drag source.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There is no post-drop animation, so clean up the DragView now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Hide this button unless we are dragging something from AllApps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// empty and a re-bind occurred	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the previous launcher state	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check for special shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check for abandoned promise	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Start activities	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// or .detectAll() for all detectable problems	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Determine the dynamic grid properties	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Lazy-initialize the dynamic grid	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the LauncherApplication should call this, but in case of Instrumentation it might not be present yet	UNKNOWN	WITHOUT_CLASSIFICATION	0.945	0.000
// If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// this also ensures that any synchronous binding below doesnt re-trigger another	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// LauncherModel load.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the user leaves launcher, then we should just load items asynchronously when	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// they return.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We only load the page synchronously if the user rotates (or triggers a	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// configuration change) while launcher is in the foreground	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// For handling default keys	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// On large interfaces, we want the screen to auto-rotate based on the current orientation	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/** To be overriden by subclasses to hint to Launcher that we have custom content */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * To be overridden by subclasses to populate the custom content container and call     * {@link #addToCustomContentPage}. This will only be invoked if     * {@link #hasCustomContentToLeft()} is {@code true}.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The animated view may be null in the case of a rotation during widget configuration	UNKNOWN	WITHOUT_CLASSIFICATION	0.934	0.000
/**     * Invoked by subclasses to signal a change to the {@link #addCustomContentToLeft} value to     * ensure the custom content page is added or removed if necessary.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Not bound yet, wait for bindScreens to be called.	UNKNOWN	WITHOUT_CLASSIFICATION	0.981	0.000
// Create the custom content page and call the subclass to populate it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// recursive, but now with a locale configuration	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// recursive, but now with a locale configuration	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//noinspection ResultOfMethodCallIgnored	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We prevent dragging when we are loading the workspace as it is possible to pick up a view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// that is subsequently removed from the workspace in startBinding().	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// View.generateViewId() is not available. The following fallback logic is a copy	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// of its implementation.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// aapt-generated IDs have the high byte nonzero; clamp to the range under that.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Roll over to 1, not 0.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This cast is safe given the > 2B range for int.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns whether we should delay spring loaded mode -- for shortcuts and widgets that have     * a configuration step, this allows the proper animations to run after other transitions.     */	UNKNOWN	DESIGN	0.586	0.000
// When the screen id represents an actual screen (as opposed to a rank) we make sure	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// that the drop page actually exists.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Before adding this resetAddInfo(), after a shortcut was added to a workspace screen,	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
// if you turned the screen off and then back while in All Apps, Launcher would not	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// return to the workspace. Clearing mAddInfo.container here fixes this issue	UNKNOWN	WITHOUT_CLASSIFICATION	0.953	0.000
// Reset the startActivity waiting flag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We have special handling for widgets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// No need to remove the empty screen if were mid-binding, as the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the bind will not add the empty screen.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When the screen id represents an actual screen (as opposed to a rank)	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// we make sure that the drop page actually exists.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the widget view.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Leave the widget in the pending state if the user canceled the configure.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The pattern used here is that a user PICKs a specific application,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// which, depending on the target, might need to CREATE the actual target.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For example, the user would PICK_SHORTCUT for Music playlist, and we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// launch over to the Music app to actually CREATE_SHORTCUT.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Check to see if a given screen id exists. If not, create it at the end, return the new id.     *     * @param screenId the screen id to check     * @return the new screen, or screenId if it exists     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// its possible that the add screen was removed because it was	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Background was set to gradient in onPause(), restore to black if in all apps.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We might have postponed some bind calls until onResume (see waitUntilResume) --	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// execute them here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reset the pressed state of icons that were locked in the press state while activities	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// were launching	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Resets the previous workspace icon press state	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// It is possible that widgets can receive updates while launcher is not in the foreground.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Consequently, the widgets will be inflated in the orientation of the foreground activity	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// (framework issue). On resuming, we ensure that any widgets are inflated for the current	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// orientation.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Process any items that were added while Launcher was away.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Intent idleScreenIntent = new Intent(AppInterface.CAT_IDLE_SCREEN_ACTION);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//idleScreenIntent.putExtra(SCREEN_IDLE, true);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//og.d(TAG,Broadcasting Home Idle Screen Intent ...);	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
//sendBroadcast(idleScreenIntent);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are resuming and the custom content is the current page, we call onShow().	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// It is also possible that onShow will instead be called slightly after first layout	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// if PagedView#setRestorePage was set to the custom content page in onCreate().	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// show OOBE	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that items added to Launcher are queued until Launcher returns	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We call onHide() aggressively. The custom content callbacks should be able to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// debounce excess onHide calls.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Change to false to hide all apps on the overview pane	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The custom content needs to offset its content to account for the QSB	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Flag the loader to stop early before switching	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We cant hide the IME if it was forced open.  So dont bother	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// something usable has been typed - start a search	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the typed text will be retrieved and cleared by	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// showSearchDialog()	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If there are multiple keystrokes before the search dialog takes focus,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// onSearchRequested() will be called for every keystroke,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// but it is idempotent, so its fine.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Eat the long press event so the keyboard doesnt come up.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given the integer (ordinal) value of a State enum instance, convert it to a variable of type     * State     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Restores the previous state, if it exists.     *     * @param savedState The previous state.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the AppsCustomize tab	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Finds all the views we need and configure them properly.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.859	0.000
// Setup the drag layer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Setup the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the search/delete bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Setup AppsCustomize	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Setup the drag controller (drop targets have to be added in reverse order in priority)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Creates a view representing a shortcut.     *     * @param info The data structure describing the shortcut.     *     * @return A View inflated from R.layout.application.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.989	0.000
/**     * Creates a view representing a shortcut inflated from the specified resource.     *     * @param layoutResId The id of the XML layout used to create the shortcut.     * @param parent The group the shortcut belongs to.     * @param info The data structure describing the shortcut.     *     * @return A View inflated from layoutResId.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
/**     * Add a shortcut to the workspace.     *     * @param data The intent describing the shortcut.     * @param cellInfo The position on screen where to create the shortcut.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The app is trying to add a shortcut without sufficient permissions	UNKNOWN	WITHOUT_CLASSIFICATION	0.848	0.000
// First we check if we already know the exact location where we want to add this item.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If appropriate, either create a folder or add to an existing folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when dragging and dropping, just find the closest free spot	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want to account for the extra amount of padding that we are adding to the widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to ensure that it gets the full amount of space that it has requested	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Add a widget to the workspace.     *     * @param appWidgetId The app widget id     * @param cellInfo The position on screen where to create the widget.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Calculate the grid spans needed to fit this widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try finding open space on Launcher screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We have saved the position to which the widget was dragged-- this really only matters	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if we are placing widgets on a spring-loaded screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when dragging and dropping, just find the closest free spot	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Deleting an app widget ID is a void call but writes to disk before returning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to the caller...	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Build Launcher-specific widget info and save to database	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Perform actual inflation because were live	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The AppWidgetHostView has already been inflated and instantiated	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reset AllApps to its initial state only if we are not in the middle of	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// processing a multi-step drop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Listen for broadcasts related to user-presence	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For handling managed profiles	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Sets up transparent navigation and status bars in LMP.     * This method is a no-op for other platform versions.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO(sansid): use the APIs directly when compiling against L sdk.	UNKNOWN	WITHOUT_CLASSIFICATION	0.994	0.000
// Currently we use reflection to access the flags and the API to set the transparency	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// on the System bars.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The following code used to be in onResume, but it turns out onResume is called when	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// youre in All Apps and click home to go to the workspace. onWindowVisibilityChanged	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// is a more appropriate event to handle	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// We want to let Launcher draw itself at least once before we force it to build	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// layers on all the workspace pages, so that transitioning to Launcher from other	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// apps is nice and speedy.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We delay the layer building a bit in order to give	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// other message processing a time to run.  In particular	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// this avoids a delay in hiding the IME if it was	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// currently shown, because doing that may involve	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// some communication back with the app.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We delay the layer building a bit in order to give	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// other message processing a time to run.  In particular	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// this avoids a delay in hiding the IME if it was	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// currently shown, because doing that may involve	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// some communication back with the app.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove messages sent using postDelayed()	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Whatever we were doing is hereby canceled.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Close the menu	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// also will cancel mWaitingForResult.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Can be cases where mWorkspace is null, this prevents a NPE	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In all these cases, only animate if were already on home	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are already on home, then just animate back to the workspace,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// otherwise, just wait until onResume to set the state back to Workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reset the apps customize page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Override point for subclasses to prevent movement to the default screen when the home     * button is pressed. Used (for example) in GEL, to prevent movement during a search.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
/**     * Override point for subclasses to provide custom behaviour for when a home intent is fired.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// We close any open folder since it will not be re-opened, and we need to make sure	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// this state is reflected.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Save the current AppsCustomize tab	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove all pending runnables	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Stop callbacks from LauncherModel	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Its possible to receive onDestroy after a new Launcher activity has	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// been created. In this case, dont interfere with the new Launcher.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Disconnect any of the callbacks and drawables associated with ItemInfos on the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// to prevent leaking Launcher activities on orientation change.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Indicates that we want global search for this activity by setting the globalSearch     * argument for {@link #startSearch} to true.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Use any text typed in the launcher as the initial query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Start a text search.     *     * @return {@code true} if the search will start immediately, so any further keypresses     * will be handled directly by the search UI. {@code false} if {@link Launcher} should continue     * to buffer keypresses.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Starts the global search activity. This code is a copied from SearchManager     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// Make sure that we have a Bundle to put source in	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set source to package name of app that starts global search, if not set already.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Close any open folders	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Stop resizing any widgets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Show the overview mode	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Use a custom animation for launching search	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Launch over to configure widget, if needed	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Otherwise just add it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Exit spring loaded mode if necessary after adding the widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Exit spring loaded mode if necessary after adding the widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Close any folders that may be open.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Process a shortcut drop.     *     * @param componentName The name of the component     * @param screenId The ID of the screen where it should be added     * @param cell The cell it should be added to, optional     * @param position The location on the screen where it was dropped, optional     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Process a widget drop.     *     * @param info The PendingAppWidgetInfo of the widget being added.     * @param screenId The ID of the screen where it should be added     * @param cell The cell it should be added to, optional     * @param position The location on the screen where it was dropped, optional     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// In this case, we either need to start an activity to get permission to bind	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the widget, or we need to start an activity to configure the widget, or both.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: we need to make sure that this accounts for the options bundle.	UNKNOWN	DESIGN	0.908	0.000
// intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS, options);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the model	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create the view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Force measure the new folder icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Registers various content observers. The current implementation registers     * only a favorites observer to keep track of the favorites applications.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Back button is a no-op here, but give at least some feedback for the button press	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Re-listen when widgets are reset.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Launches the intent referred by the clicked shortcut.     *     * @param v The view representing the clicked shortcut.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Make sure that rogue clicks dont get through while allapps is launching, or after the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// view has detached (its possible for this to happen if the view is removed mid touch).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Event handler for the app widget view which has not fully restored.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// The install has not been queued	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Download has started.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Event handler for the search button     *     * @param v The view that was clicked.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Event handler for the voice button     *     * @param v The view that was clicked.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Event handler for the grid button that appears on the home screen, which     * enters all apps mode.     *     * @param v The view that was clicked.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.980	0.000
/**     * Event handler for an app shortcut click.     *     * @param v The view that was clicked. Must be a tagged with a {@link ShortcutInfo}.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Open shortcut	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
/**     * Event handler for a folder icon click.     *     * @param v The view that was clicked. Must be an instance of {@link FolderIcon}.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the folder info reports that the associated folder is open, then verify that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// it is actually opened. There have been a few instances where this gets out of sync.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Close any open folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Open the requested folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the open folder...	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// .. and close it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Close any folder open on the current screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pull the folder onto this screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Event handler for the (Add) Widgets button that appears after a long press     * on the home screen.     */	UNKNOWN	DESIGN	0.827	0.000
/**     * Event handler for the wallpaper picker button that appears after a long press     * on the home screen.     */	UNKNOWN	DESIGN	0.757	0.000
/**     * Event handler for a click on the settings button that appears after a long press     * on the home screen.     */	UNKNOWN	DESIGN	0.560	0.000
// Provide the same haptic feedback that the system offers for virtual keys.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Provide the same haptic feedback that the system offers for virtual keys.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Called when the user stops interacting with the launcher.     * This implies that the user is now on the homescreen and is not doing housekeeping.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.917	0.000
/**     * Called when the user starts interacting with the launcher.     * The possible interactions are:     *  - open all apps     *  - reorder an app shortcut, or a widget     *  - open the overview mode.     * This is a good time to stop doing things that only make sense     * when the user is on the homescreen and not doing housekeeping.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.740	0.000
// returns true if the activity was started	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// System applications cannot be installed. For now, show a toast explaining that.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We may give them the option of disabling apps this way.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only launch using the new animation if the shortcut has not opted out (this is a	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// private contract between launcher and may be ignored in the future).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Could be launching some bookkeeping activity	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO Component can be null when shortcuts are supported for secondary user	UNKNOWN	DESIGN	0.819	0.000
/**     * This method draws the FolderIcon to an ImageView and then adds and positions that ImageView     * in the DragLayer in the exact absolute location of the original FolderIcon.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// Lazy load ImageView, Bitmap and Canvas	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The layout from which the folder is being opened may be scaled, adjust the starting	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// view size by this scale factor.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Just in case this image view is still in the drag layer from a previous animation,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we remove it and re-add it.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Push an ImageView copy of the FolderIcon into the DragLayer and hide the original	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We remove and re-draw the FolderIcon in-case it has changed	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the ImageView copy of the FolderIcon and make the original visible.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the ImageView copy of the FolderIcon and make the original visible.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Opens the user folder described by the specified tag. The opening of the folder     * is animated relative to the specified View. If the View is null, no animation     * is played.     *     * @param folderInfo The FolderInfo describing the folder to open.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Just verify that the folder hasnt already been added to the DragLayer.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// There was a one-off crash where the folder had a parent already.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Notify the accessibility manager that this folder window has appeared and occluded	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the workspace items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Notify the accessibility manager that this folder window has disappeard and no	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// longer occludeds the workspace items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// User long pressed on empty space	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// User long pressed on an item	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the CellLayout of the specified container at the specified screen.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the workspace transition step as well	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the workspace transition step as well	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Things to test when changing the following seven functions.     *   - Home from workspace     *          - from center screen     *          - from other screens     *   - Home from all apps     *          - from center screen     *          - from other screens     *   - Back from all apps     *          - from center screen     *          - from other screens     *   - Launch app from workspace and quit     *          - with back     *          - with home     *   - Launch app from all apps and quit     *          - with back     *          - with home     *   - Go to a screen thats not the default, then all     *     apps, and launch and app, and go back     *          - with back     *          -with home     *   - On workspace, long press power and go back     *          - with back     *          - with home     *   - On all apps, long press power and go back     *          - with back     *          - with home     *   - On workspace, power off     *   - On all apps, power off     *   - Launch an app and turn off the screen while in that app     *          - Go back with home key     *          - Go back with back key  TODO: make this not go to workspace     *          - From all apps     *          - From workspace     *   - Enter and exit car mode (becuase it causes an extra configuration changed)     *          - From all apps     *          - From the center workspace     *          - From another workspace     */	UNKNOWN	DESIGN	0.935	0.000
/**     * Zoom the camera out from the workspace to reveal toView.     * Assumes that the view to show is anchored at either the very top or very bottom     * of the screen.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the content type for the all apps/widgets space	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If for some reason our views arent initialized, dont animate	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Hide the real page background, and swap in the fake one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We need to hide this view as the animation start will be posted.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the y delta between the center of the page and the center of the all apps button	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check that mStateAnimation hasnt changed while	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we waited for a layout/draw pass	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check that mStateAnimation hasnt changed while	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we waited for a layout/draw pass	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Zoom the camera back into the workspace, hiding fromView.     * This is the opposite of showAppsCustomizeHelper.     * @param animated If true, the transition will be animated.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If for some reason our views arent initialized, dont animate	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We need to hide side pages of the Apps / Widget tray to avoid some ugly edge cases	UNKNOWN	WITHOUT_CLASSIFICATION	0.798	0.000
// hideAppsCustomizeHelper is called in some cases when it is already hidden	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dont perform all these no-op animations. In particularly, this was causing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the all-apps button to pop in and out.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Hide the real page background, and swap in the fake one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The vertical motion of the apps panel should be delayed by one frame	UNKNOWN	WITHOUT_CLASSIFICATION	0.980	0.000
// from the conceal animation in order to give the right feel. We correspondingly	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// shorten the duration so that the slide and conceal end at the same time.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Unhide side pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reset page transforms	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check that mStateAnimation hasnt changed while	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we waited for a layout/draw pass	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Unhide side pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reset page transforms	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check that mStateAnimation hasnt changed while	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we waited for a layout/draw pass	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set focus to the AppsCustomize button	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Change the state *after* weve called all the transition code	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Resume the auto-advance of widgets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Send an accessibility event to announce the context change	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We post this in-case the all apps view isnt yet constructed.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Change the state *after* weve called all the transition code	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Pause the auto-advance of widgets until we are out of AllApps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Send an accessibility event to announce the context change	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We post this in-case the all apps view isnt yet constructed.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Before we show workspace, hide all apps again because	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// exitSpringLoadedDragMode made it visible. This is a bit hacky; we should	UNKNOWN	DESIGN	1.000	0.000
// clean up our state transition functions	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Before we show workspace, hide all apps again because	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// exitSpringLoadedDragMode made it visible. This is a bit hacky; we should	UNKNOWN	DESIGN	1.000	0.000
// clean up our state transition functions	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Otherwise, we are not in spring loaded mode, so dont do anything.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// TODO	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Add an item from all apps or customize onto the given workspace screen.     * If layout is null, add to the current screen.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Maps the current orientation to an index for referencing orientation correct global icons */	UNKNOWN	WITHOUT_CLASSIFICATION	0.886	0.000
// default - 0, landscape - 1	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Look for the toolbar icon specified in the activity meta-data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This can happen if the activity defines an invalid drawable	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This can happen if the activity defines an invalid drawable	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if successful in getting icon, return it; otherwise, set button to use default drawable	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// If we were unable to find the icon via the meta-data, use a generic one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if successful in getting icon, return it; otherwise, set button to use default drawable	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// If we were unable to find the icon via the meta-data, use a	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// generic one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Populate event with a fake title based on the current state.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * If the activity is currently paused, signal that we need to run the passed Runnable     * in onResume.     *     * This needs to be called from incoming places where resources might have been loaded     * while we are paused.  That is becaues the Configuration might be wrong     * when were not running, and if it comes back to what it was when we     * were paused, we are not restarted.     *     * Implementation of the method from LauncherModel.Callbacks.     *     * @return true if we are currently paused.  The caller might be able to     * skip some work in that case since we will come back again.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//noinspection StatementWithEmptyBody	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * If the activity is currently paused, signal that we need to re-run the loader     * in onResume.     *     * This needs to be called from incoming places where resources might have been loaded     * while we are paused.  That is becaues the Configuration might be wrong     * when were not running, and if it comes back to what it was when we     * were paused, we are not restarted.     *     * Implementation of the method from LauncherModel.Callbacks.     *     * @return true if we are currently paused.  The caller might be able to     * skip some work in that case since we will come back again.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Refreshes the shortcuts shown on the workspace.     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were starting binding all over again, clear any bind calls wed postponed in	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the past (see waitUntilResume) -- we dont need them since were starting binding	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// from scratch again	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear the workspace because its going to be rebound	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// If there are no screens, we need to have an empty screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create the custom content page (this call updates mDefaultScreen which calls	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// setCurrentPage() so ensure that all pages are added before calling this).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the new screens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We add the items without animation on non-visible pages, and with	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// animations on the new page (which we will try and snap to).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the extra empty screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Bind the items start-end from the list.     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the list of added shortcuts and intersect them with the set of shortcuts here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*                     * TODO: FIX collision case                     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.884	0.000
// Animate all the applications up now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animate to the correct page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We post the animation slightly delayed to prevent slowdowns	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when we are loading right after we return to launcher.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Add the views for a widget to the workspace.     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// Note: This assumes that the id remap broadcast is received before this step.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If that is not the case, the id remap will be ignored and user may see the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// click to setup view.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO consider showing a permission dialog when the widget is clicked.	UNKNOWN	DESIGN	0.998	0.000
// If the widget has a configure activity, it is still needs to set it up, otherwise	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the widget is ready to go.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Restores a pending widget.     *     * @param appWidgetId The app widget id     * @param cellInfo The position on screen where to create the widget.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Callback saying that there arent any more items to bind.     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we received the result of any pending adds while the loader was running (e.g. the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// widget configuration forced an orientation change), process them now.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: this moves the user to the page where the pending item was added. Ideally,	UNKNOWN	DESIGN	0.975	0.000
// the screen would be guaranteed to exist after bind, and the page would be set through	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the workspace restore process.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Add the icons for all apps.     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * A package was updated.     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Packages were restored     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Update the state of a package, typically related to install state.     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Update the label and icon of all the icons in a package     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * A package was uninstalled.  We take both the super set of packageNames     * in addition to specific applications to remove, the reason being that     * this can be called when a package is updated as well.  In that scenario,     * we only remove specific components from the workspace, where as     * package-removal should clear all items by package name.     *     * Implementation of the method from LauncherModel.Callbacks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Notify the drag controller	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update AllApps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the widgets pane	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We are currently in the same basic orientation as the natural orientation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We are currently in the other basic orientation to the natural orientation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Since the map starts at portrait, we need to offset if this devices natural orientation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is landscape.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Called when the SearchBar hint should be changed.     *     * @param hint the hint to be displayed in the search bar.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This method indicates whether or not we should suggest default wallpaper dimensions     * when our wallpaper cropper was not yet used to set a wallpaper.     */	UNKNOWN	DESIGN	0.981	0.000
/**     * To be overridden by subclasses to indicate that there is an activity to launch     * before showing the standard launcher experience.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * To be overridden by subclasses to launch any first run activity     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * To be overridden by subclasses to indicate that there is an in-activity full-screen intro     * screen that must be displayed and dismissed.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
/**     * Full screen intro screen to be shown and dismissed before the launcher can be used.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
/**     * To be overriden by subclasses to indicate whether the in-activity intro screen has been     * dismissed. This method is ignored if #hasDismissableIntroScreen returns false.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We delay hiding the intro view until the first run activity is showing. This	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// avoids a blip.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The two first run cling paths are mutually exclusive, if the launcher is preinstalled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// on the device, then we always show the first run cling experience (or if there is no	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// launcher2). Otherwise, we prompt the user upon started for migration	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//launcherClings.showLongPressCling(true);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Called from search suggestion, not supported in other profiles.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Called from search suggestion, not supported in other profiles.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Prints out out state for debugging.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Show OOBE tutorial on first use of Edge Swipe, Edit Favorites, etc...     *     * @param oobeToShow     *            Activity identifier: SHOW_OOBE_EDIT_FAVORITES or     *            SHOW_OOBE_EDGE_SWIPE_MENU     * @param oobeTutorial     *            Tutorial to show: OOBEActivity.OOBE_EDIT_FAVORITES_TUTORIAL,     *            OOBEActivity.OOBE_EDGE_SWIPE_TUTORIAL,     *            OOBEActivity.OOBE_FULL_TUTORIAL     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.790	0.000
//if (true || mSharedPrefs.getBoolean(oobeToShow, true)) { //Uncomment to loop the animation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Starts the OOBEActivity in the selected tutorial     *     * @param oobeTutorial     *            Tutorial to show: OOBEActivity.OOBE_EDIT_FAVORITES_TUTORIAL,     *            OOBEActivity.OOBE_EDGE_SWIPE_TUTORIAL,     *            OOBEActivity.OOBE_FULL_TUTORIAL     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Enable the hw layers before the animation starts (will be disabled in the onAnimationEnd	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// callback below)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the individual components	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create the various fade animations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * Gets various transition durations.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * DragController.DragListener implementation     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animate out the QSB search bar, and animate in the drop target bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the QSB search bar, and animate out the drop target bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The text fits in a single line. No need to draw the setup icon.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update left and top to indicate the position where the text will be drawn.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// No-op	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Re inflate is required any time the widget restore status changes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The view displays two modes, one with a setup icon and another with a preload icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in the center.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// AppWidgetHostView blocks all click events on the root view. Instead handle click events	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// on the content and pass it along.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Recreate the setup text.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The text cant be drawn in a single line. Draw a setup icon instead.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Load the preferences from an XML resource	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * The size of the indicator is same as the content region of the {@link #mBgDrawable} minus     * half the stroke size to accommodate the indicator.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Amount by which padding has to be scaled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The draw region has been clipped.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Stop Animation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the paint color only when the level changes, so that the dominant color	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is only calculated when needed.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Runs the finish animation if it is has not been run after last level change.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Make sure that the dominant color has enough saturation to be visible properly.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set a new alarm to expire for the screen that we are hovering over now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// this is called when our timer runs out	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to the screen that we are hovering over now	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// suppress dead code warning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Debug drawing for hit space	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set whether or not to invert the layout horizontally if the layout is in RTL mode.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Widgets have their own padding, so skip	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Otherwise, center the icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Cancel long press for all children	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the drawing caches	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Initializes various states for this workspace.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if (!mScroller.isFinished()) return;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Keep generating points as long as were more than 1px away from the target	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: initial wallpaper now that wallpapers are owned by another app	UNKNOWN	DESIGN	0.956	0.000
// TODO: make removeShortcut internally threadsafe	UNKNOWN	DESIGN	1.000	0.000
// Ignore	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: delayed writes	UNKNOWN	WITHOUT_CLASSIFICATION	0.648	0.000
// not a problem	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// more of a problem	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Log.v(WeightWatcher.ProcessWatcher,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//        MSG_UPDATE pss= + mMemInfo.currentPss);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// app	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// service	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Log.v(WeightWatcher.ProcessWatcher,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//        MSG_UPDATE pss= + mMemInfo.currentPss);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// app	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// service	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// draw a big box for the icon for debugging	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// suppress dead code warning	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns a FastBitmapDrawable with the icon, accurately sized.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.851	0.000
/**     * Resizes an icon drawable to the correct icon size.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Indicates if the device is running LMP or higher.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns a bitmap which is of the appropriate size to be displayed as an icon     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we share the statics :-(	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Returns a bitmap suitable for the all apps view.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we share the statics :-(	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Ensure the bitmap has a density.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Scale the icon proportionally to the icon dimensions	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// no intrinsic size --> use default size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Given a coordinate relative to the descendant, find the coordinate in a parent views     * coordinates.     *     * @param descendant The descendant to which the passed coordinate is relative.     * @param root The root view to make the coordinates relative to.     * @param coord The coordinate that we want mapped.     * @param includeRootScroll Whether or not to account for the scroll of the descendant:     *          sometimes this is relevant as in a childs coordinates within the descendant.     * @return The factor by which this descendant is scaled relative to this DragLayer. Caution     *         this scale factor is assumed to be equal in X and Y, and so if at any point this     *         assumption fails, we will need to return a pair of scale factors.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For TextViews, scroll has a meaning which relates to the text position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// which is very strange... ignore the scroll.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Utility method to determine whether the given point, in local coordinates,     * is inside the view, where the area of the view is expanded by the slop factor.     * This method is called while processing touch-move events to determine if the event     * is still within the view.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This picks a dominant color, looking for high-saturation, high-value, repeated hues.     * @param bitmap The bitmap to scan     * @param samples The approximate max number of samples to use.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.724	0.000
// This is an out-param, for getting the hsv values for an rgb	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First get the best hue, by creating a histogram over 360 hue buckets,	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
// where each pixel contributes a score weighted by saturation, value, and alpha.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Drop mostly-transparent pixels.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the alpha channel.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Bucket colors by the 360 integer hues.	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Defensively avoid array bounds violations.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Go back over the RGB colors that match the winning hue,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.	UNKNOWN	DESIGN	0.850	0.000
// The highest-scoring RGB color wins.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Score by cumulative saturation * value.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// All the colors in the winning bucket are very similar. Last in wins.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * Finds a system apk which had a broadcast receiver listening to a particular action.     * @param action intent action used to find the apk     * @return a pair of apk package name and the resources.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.973	0.000
// launching the application	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Most Used	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set the all apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to determine the full scroll width	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
/**     * Initializes various states for this workspace.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Scale the fling-to-delete threshold by the density	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Hook up the page indicator	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Unhook the page indicator	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Convenience methods to map points from self to parent and vice versa	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Convenience methods to get the actual width/height of the PagedView (since it is measured	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to be larger to account for the minimum possible scale)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Convenience methods to get the offset ASSUMING that we are centering the pages in the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// PagedView both horizontally and vertically	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Add a page change listener which will be called when a page is _finished_ listening.     *     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.     */	UNKNOWN	DESIGN	0.826	0.000
/**     * Called by subclasses to mark that data is ready, and that we can begin loading and laying     * out pages.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns the index of the currently displayed page.     *     * @return The index of the currently displayed page.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Updates the scroll of the current page immediately to its final scroll position.  We use this     * in CustomizePagedView to allow tabs to share the same PagedView while resetting the scroll of     * the previous tab page.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the current page is invalid, just reset the scroll position to zero	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Called during AllApps/Home transitions to avoid unnecessary work. When that other animation     * {@link #updateCurrentPageScroll()} should be called, to correctly set the final state and     * re-enable scrolling.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.857	0.000
// We need to clean up the next page here to avoid computeScrollHelper from	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// updating current page on the pass.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We need to clean up the next page here to avoid computeScrollHelper from	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// updating current page on the pass.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When in free scroll mode, we need to clamp to the free scroll page range.	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// Ensure that it is clamped by the actual set of children in all cases	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Sets the current page.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dont introduce any checks like mCurrentPage == currentPage here-- if we change the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the default	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * The restore page will be set in place of the current page at the next (likely first)     * layout.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Should be called whenever the page changes. In the case of a scroll, we wait until the page     * has settled.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Update the page indicator (when we arent reordering)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// a method that subclasses can override to add behavior	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// a method that subclasses can override to add behavior	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Registers the specified listener on each page contained in this workspace.     *     * @param l The listener used to respond to long clicks.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In free scroll mode, we clamp the scrollX	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the last motion events when scrolling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we moved this functionality to a helper function so SmoothPagedView can reuse it	UNKNOWN	WITHOUT_CLASSIFICATION	0.923	0.000
// Dont bother scrolling if the page does not need to be moved	UNKNOWN	WITHOUT_CLASSIFICATION	0.735	0.000
// Load the associated pages if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont want to trigger a page end moving unless the page has settled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// and the user has stopped scrolling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Notify the user when the page changes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We measure the dimensions of the PagedView to be larger than the pages so that when we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// zoom out (and scale down), the view is still contained in the parent	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// NOTE: We multiply by 2f to account for the fact that depending on the offset of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// viewport, we can be at most one and a half screens offset once we scale down	UNKNOWN	WITHOUT_CLASSIFICATION	0.925	0.000
// Return early if we arent given a proper dimension	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* Allow the height to be set as WRAP_CONTENT. This allows the particular case         * of the All apps view on XLarge displays to not take up more space then it needs. Width         * is still not allowed to be set as WRAP_CONTENT since many parts of the code expect         * each page to have the same width.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The children are given the same width and height as the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// unless they were set to WRAP_CONTENT	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// disallowing padding in paged view (just pass 0)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This method should be called once before first layout / measure pass.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// Update the viewport offsets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Prevent full screen pages from showing in the viewport	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// when they are not the current page.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the page indicator, we dont update the page indicator as we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// add/remove pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This ensures that when children are added, they get the correct transforms / alphas	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in accordance with any scroll effects.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the page indicator, we dont update the page indicator as we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// add/remove pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: We should find a better way to hook into this before the view	UNKNOWN	DESIGN	1.000	0.000
// gets removed form its parent...	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: We should find a better way to hook into this before the view	UNKNOWN	DESIGN	1.000	0.000
// gets removed form its parent...	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: We should find a better way to hook into this before the view	UNKNOWN	DESIGN	1.000	0.000
// gets removed form its parent...	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the page indicator, we dont update the page indicator as we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// add/remove pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find out which screens are visible; as an optimization we only call draw on them	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mOverScrollX is equal to getScrollX() when were within the normal scroll range.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Otherwise it is equal to the scaled overscroll position.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set mForceScreenScrolled before calling screenScrolled so that screenScrolled can	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set it for the next frame	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Clip to the bounds	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw all the children, leaving the drag view for last	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw the drag view on top (if there is one)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX-RTL: This will be fixed in a future CL	UNKNOWN	DESIGN	0.834	0.000
// XXX-RTL: This will be fixed in a future CL	UNKNOWN	DESIGN	0.834	0.000
/**     * If one of our descendant views decides that it could be focused now, only     * pass that along if its on the current page.     *     * This happens when live folders requery, and if theyre off page, they     * end up calling requestFocus, which pulls it on page.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * {@inheritDoc}     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// We need to make sure to cancel our long press if	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// a scrollable widget takes over touch events	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Return true if a tap at (x, y) should trigger a flip to the previous page.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
/**     * Return true if a tap at (x, y) should trigger a flip to the next page.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.973	0.000
/** Returns whether x and y originated within the buffered viewport */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*         * This method JUST determines whether we want to intercept the motion.         * If we return true, onTouchEvent will be called and we do the actual         * scrolling there.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Skip touch handling if there are no pages to swipe	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*         * Shortcut the most recurring case: the user is in the dragging         * state and he is moving his finger.  We want to intercept this         * motion.         */	UNKNOWN	WITHOUT_CLASSIFICATION	0.981	0.000
/*                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check                 * whether the user has moved far enough from his original down touch.                 */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if mActivePointerId is INVALID_POINTER, then we must have missed an ACTION_DOWN	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// event. in that case, treat the first occurence of a move event as a ACTION_DOWN	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// i.e. fall through to the next case (dont break)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// (We sometimes miss ACTION_DOWN events in Workspace because it ignores all events	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// while its small- this was causing a crash before we checked for INVALID_POINTER)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remember location of down touch	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*                 * If being flinged and user touches the screen, initiate drag;                 * otherwise dont.  mScroller.isFinished should be false when                 * being flinged.                 */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check if this can be the beginning of a tap on the side of the pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to scroll the current page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*         * The only time we want to intercept motion events is if we are in the         * drag mode.         */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * Determines if we should change the touch state to start scrolling after the     * user moves their touch point too far.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Disallow scrolling if we dont have a valid pointer index	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Disallow scrolling if we started the gesture from outside the viewport	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Scroll if the user moved far enough along the X axis	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//mAllowLongPress = false;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try canceling the long press. It could also have been scheduled	UNKNOWN	WITHOUT_CLASSIFICATION	0.835	0.000
// by a distant descendant, so use the mAllowLongPress flag to block	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// everything	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// While layout transitions are occurring, a childs position may stray from its baseline	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position. This method returns the magnitude of this stray at any given time.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This curve determines how the effect of scrolling over the limits of the page dimishes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// as the user pulls further and further from the bounds	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want to reach the max over scroll effect when the user has	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// over scrolled half the size of the screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clamp this factor, f, to -1 < f < 1	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clamp this factor, f, to -1 < f < 1	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Using the formula in overScroll, assuming that f = 1.0 (which it should generally not	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// exceed). Used to find out how much extra wallpaper we need for the over scroll effect	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Skip touch handling if there are no pages to swipe	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*             * If being flinged and user touches, stop the fling. isFinished             * will be false if being flinged.             */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remember where the motion event started	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Scroll to follow the motion event	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only scroll and update mLastMotionX if we have moved some discrete amount.  We	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// keep the remainder because we are actually testing if weve moved from the last	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// scrolled position (which is discrete).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the last motion position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the parent down so that our zoom animations take this new movement into	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// account	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the closest page to the touch point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Change the drag view if we are hovering over the drop target	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Setup the scroll to the correct page before we swap the views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For each of the pages between the paged view and the drag view,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// animate them from the previous position to the new position in	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the layout (as a result of the drag view moving in the layout)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dragViewIndex < pageUnderPointIndex, so after we remove the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drag view all subsequent views to pageUnderPointIndex will	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shift down.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Animate the view translation from its old position to its new	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In the case that the page is moved far to one direction and then is flung	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in the opposite direction, we use a threshold to determine whether we should	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// just return to the starting page, or if we should skip one further.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We give flings precedence over large moves, which is why we short-circuit our	UNKNOWN	WITHOUT_CLASSIFICATION	0.778	0.000
// test for a large move if a fling has been registered. That is, a large	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// move to the left and fling to the right will register as a fling to the right.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// at this point we have not moved beyond the touch slop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we can just page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// at this point we have not moved beyond the touch slop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we can just page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the last motion position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the parent down so that our zoom animations take this new movement into	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// account	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Check the velocity and see if we are flinging-to-delete	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the callback to wait for the side page hover timeout	UNKNOWN	WITHOUT_CLASSIFICATION	0.984	0.000
// End any intermediate reordering states	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Setup the scroll to the correct page before we swap the views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For each of the pages between the paged view and the drag view,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// animate them from the previous position to the new position in	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the layout (as a result of the drag view moving in the layout)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dragViewIndex < pageUnderPointIndex, so after we remove the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drag view all subsequent views to pageUnderPointIndex will	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shift down.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Animate the view translation from its old position to its new	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Handle mouse (or ext. device) by shifting the page depending on the scroll	UNKNOWN	WITHOUT_CLASSIFICATION	0.979	0.000
// This was our active pointer going up. Choose a new	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// active pointer and adjust accordingly.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: Make this decision more intelligent.	UNKNOWN	DESIGN	1.000	0.000
// We want the duration of the page snap animation to be influenced by the distance that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the screen has to travel, however, we dont want this duration to be effected in a	UNKNOWN	WITHOUT_CLASSIFICATION	0.922	0.000
// purely linear fashion. Instead, we use this method to moderate the effect that the distance	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// of travel has on the overall snap duration.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// center the values about 0.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the velocity is low enough, then treat this more as an automatic page advance	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// as opposed to an apparent physical response to flinging	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Here we compute a distance that will be used in the computation of the overall	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// snap duration. This is a function of the actual distance that needs to be traveled;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we keep this value close to half screen size in order to reduce the variance in snap	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// duration as a function of the distance the page needs to travel.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we want the pages snap velocity to approximately match the velocity at which the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// user flings, so we scale the duration by a value near to the derivative of the scroll	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// interpolator at zero, ie. 5. We use 4 to make it a little slower.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Trigger a compute() to finish switching pages if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Defer loading associated pages until the scroll settles	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * @return True is long presses are still allowed for the current touch     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Set true to allow long-press events to be triggered, usually checked by     * {@link Launcher} to accept or block dpad-initiated long-presses.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First, clear any pages that should no longer be loaded	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Next, load any new pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Force all scrolling-related behavior to end	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update all the pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We must force a measure after weve loaded the pages to update the content width and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set a new page as the current page if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mark each of the pages as dirty	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load any pages that are necessary for the current window of views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the page is moving, then snap it to the final position to ensure we dont get	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// stuck between pages	UNKNOWN	WITHOUT_CLASSIFICATION	0.880	0.000
// Animate the drag view back to the original position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the touch state to reordering (allows snapping to pages, dragging a child, etc.)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We must invalidate to trigger a redraw to update the layers such that the drag view	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// is always drawn on top	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Trigger the callback when reordering has settled	UNKNOWN	WITHOUT_CLASSIFICATION	0.949	0.000
// Check if we are within the reordering range	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the drag view under the pointer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For simplicity, we call endReordering sometimes even if reordering was never started.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In that case, we dont want to do anything.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we havent flung-to-delete the current child, then we just animate the drag view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// back into position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Snap to the current page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animate the drag view back to the front position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Handled in post-delete-animation-callbacks	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
/*     * Flinging to delete - IN PROGRESS     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do a quick dot product test to ensure that we are flinging upwards	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For each of the pages around the drag view, animate them from the previous	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position to the new position in the layout (as a result of the drag view moving	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in the layout)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// NOTE: We can make an assumption here because we have side-bound pages that we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//       will always have pages to animate in from the left	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Setup the scroll to the correct page before we swap the views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dragViewIndex < pageUnderPointIndex, so after we remove the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drag view all subsequent views to pageUnderPointIndex will	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shift down.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Simulate the page being offscreen with the page spacing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animate the view translation from its old position to its new	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Note: Hacky, but we want to skip any optimizations to not draw completely	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// hidden views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For each of the pages around the drag view, animate them from the previous	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position to the new position in the layout (as a result of the drag view moving	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in the layout)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// NOTE: We can make an assumption here because we have side-bound pages that we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//       will always have pages to animate in from the left	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Setup the scroll to the correct page before we swap the views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dragViewIndex < pageUnderPointIndex, so after we remove the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drag view all subsequent views to pageUnderPointIndex will	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shift down.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Simulate the page being offscreen with the page spacing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animate the view translation from its old position to its new	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Note: Hacky, but we want to skip any optimizations to not draw completely	UNKNOWN	WITHOUT_CLASSIFICATION	0.993	0.000
// hidden views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// NOTE: Because it takes time for the first frame of animation to actually be	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// called and we expect the animation to be a continuation of the fling, we have	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to account for the time that has elapsed since the fling finished.  And since	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we dont have a startDelay, we will always get call to update when we call	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// start() (which we want to ignore).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* Anonymous inner class ctor */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create and start the animation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* Drag to delete */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create and start the complex animation	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* Accessibility */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont let the view send real scroll events.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// refactor the limits	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clear the current state	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// add application to the bag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// obtain the cached app information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if does not exist, create one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// increment count	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set the current time for the last execution	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the informations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// obtain the cached app information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if does not exist, create one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// obtain the cached app information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if does not exist, create one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set the current time for the last execution	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// obtain the cached app information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if does not exist, create one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// obtain the cached app information	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//update age	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// remove data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if does not exist return	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if its being used in the lists refactor the lists	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// most used	UNKNOWN	WITHOUT_CLASSIFICATION	0.886	0.000
// calculate the most used	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// calculate the most recent	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the recent apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Process the most used apps	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Called once the last instance of your widget is removed from the	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// homescreen	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// Widget instance is removed from the homescreen	UNKNOWN	WITHOUT_CLASSIFICATION	0.937	0.000
// Obtain appropriate widget and update it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the widgets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clear the current data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// obtain the current data saved	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if no information is available log it and continue	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the code	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if no information is available log it and continue	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the code	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// generate the mostUsed row	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get app icon and label	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// debug String with app count	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// generate the mostUsed row	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get application icon and label	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// debug String with app count	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// create the intent for this app	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * (non-Javadoc)     *      * @see     * android.appwidget.AppWidgetProvider#onUpdate(android.content.Context,     * android.appwidget.AppWidgetManager, int[])     *      * OnUpdate ==============================================================     * context The Context in which this receiver is running. appWidgetManager A     * AppWidgetManager object you can call updateAppWidget(ComponentName,     * RemoteViews) on. appWidgetIds The appWidgetIds for which an update is     * needed. Note that this may be all of the AppWidget instances for this     * provider, or just a subset of them.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Called in response to the ACTION_APPWIDGET_UPDATE broadcast when this	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// AppWidget provider	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is being asked to provide RemoteViews for a set of AppWidgets.	UNKNOWN	WITHOUT_CLASSIFICATION	0.945	0.000
// Override this method to implement your own AppWidget functionality.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the widget data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Called once the last instance of your widget is removed from the	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// homescreen	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// Widget instance is removed from the homescreen	UNKNOWN	WITHOUT_CLASSIFICATION	0.937	0.000
// Obtain appropriate widget and update it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the widgets	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*     * (non-Javadoc)     *      * @see     * android.appwidget.AppWidgetProvider#onUpdate(android.content.Context,     * android.appwidget.AppWidgetManager, int[])     *      * OnUpdate ==============================================================     * context The Context in which this receiver is running. appWidgetManager A     * AppWidgetManager object you can call updateAppWidget(ComponentName,     * RemoteViews) on. appWidgetIds The appWidgetIds for which an update is     * needed. Note that this may be all of the AppWidget instances for this     * provider, or just a subset of them.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Called in response to the ACTION_APPWIDGET_UPDATE broadcast when this	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// AppWidget provider	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is being asked to provide RemoteViews for a set of AppWidgets.	UNKNOWN	WITHOUT_CLASSIFICATION	0.945	0.000
// Override this method to implement your own AppWidget functionality.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the widget data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete everything	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// SELECT query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// args to SELECT query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// SELECT query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// args to SELECT query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// SELECT query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// args to SELECT query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// SELECT query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// args to SELECT query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cols to return	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// select query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// args to select query	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Load the preview image if possible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//noinspection UnusedAssignment	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// check if the package is valid	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// check if it exists in our existing cache	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// not in cache; we need to load it from the db	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// its not in the db... we need to generate it	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// write to db on a thread pool... this can be done lazily and improves the performance	UNKNOWN	DESIGN	0.962	0.000
// of the first time widget previews are loaded	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete all the records; theyll be repopulated as this is a cache	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// should cache the string builder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Generate a preview image if we couldnt load one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This Drawable is not directly drawn, so theres no need to mutate it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw the icon in the top left corner	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Scale to fit width only - let the widget preview be clipped in the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// vertical dimension	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If a bitmap is passed in, we use it; otherwise, we create a bitmap of the right size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw the scaled preview into the final bitmap	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Render the icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draw a desaturated/scaled version of the icon in the background as a watermark	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the bounds	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Dumps all files that are open in this process without allocating a file descriptor.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is a gigantic hack but unfortunately the only way to resolve an fd	UNKNOWN	DESIGN	1.000	0.000
// to a file name. Note that we have to loop over all possible fds because	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// reading the directory would require allocating a new fd. The kernel is	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// currently implemented such that no fd is larger then the current rlimit,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// which is why its safe to loop over them in such a way.	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// getCanonicalPath() uses readlink behind the scene which doesnt require	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// a file descriptor.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Those are the files that dont point anywhere on the file system.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// getCanonicalPath() wrongly interprets these as relative symlinks and	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// resolves them within /proc/<pid>/fd/.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ignoring exceptions for non-existing file descriptors.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Catch everything. This is called from an exception handler that we shouldnt upset.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Delete all the records; theyll be repopulated as this is a cache	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Returns true if {@param srcPackage} has the permission required to start the activity from     * {@param intent}. If {@param srcPackage} is null, then the activity should not need     * any permissions     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Not a valid target	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// No permission is needed	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The activity requires some permission but there is no source.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Source does not have sufficient permissions.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/* We have to fix that once we go to M */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// if (!Utilities.ATLEAST_MARSHMALLOW) {	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//     // These checks are sufficient for below M devices.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//     return true;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// }	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// // On M and above also check AppOpsManager for compatibility mode permissions.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if (TextUtils.isEmpty(AppOpsManager.permissionToOp(target.activityInfo.permission))) {	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//     // There is no app-op for this permission, which could have been disabled.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
//     return true;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// }	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// // There is no direct way to check if the app-op is allowed for a particular app. Since	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// // app-op is only enabled for apps running in compatibility mode, simply block such apps.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// try {	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//     return pm.getApplicationInfo(srcPackage, 0).targetSdkVersion >= Build.VERSION_CODES.M;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// } catch (NameNotFoundException e) { }	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// return false;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**	UNKNOWN	DESIGN	0.765	0.000
/**	UNKNOWN	DESIGN	0.765	0.000
// get the current prefs and clear to update	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Get the singleton instance of the fonts manager.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Setup the fonts used within the application.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// recursive search	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//                setupTheVideo();	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//                setupDefinitionsSteps();	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//setupEdgeGlowTutorialSteps();	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// button	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// increment the step counter	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// increment the step counter	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// decrement the step counter	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// increment the step counter	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// decrement the step counter	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
//mMainBackground.setBackgroundResource(R.color.oobe_background);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//startAnimation(new EdgeGlowTutorialAnimationHelper());	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//setTextView(mOOBETextGroup10);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* mNextButton.setVisibility(visibilityNext);        mBackButton.setVisibility(visibilityBack);        mStartButton.setVisibility(visibilityStart);        mSkipButton.setVisibility(visibilitySkip);*/	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//            Log.i(, send change locale request);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//alphaAnim.addKeyframe(0, 1600, null);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//alphaAnim.addKeyframe(0, 2000, null);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// - DynamicGrid.pxFromDp(110, mDisplayMetrics);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// - DynamicGrid.pxFromDp(110, mDisplayMetrics);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//textEditAnimationOff.setFillAfter(true);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*titleView.animate().alpha(0f).setDuration(1000).setListener(null);        titleView.animate().alpha(1f).setDuration(1000).setListener(null);        textView.animate().alpha(1f).setStartDelay(10000).setDuration(400000).setListener(null);*/	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// editView.startAnimation(textEditAnimation);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//spriteRoot.addChild(spriteHandShadow);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//spriteMenu.addChild(spriteAppIconSelected);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animation setup	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Animation setup	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * **************************************     * <p/>     * setupRemoveFavAnimation()     * <p/>     * ***************************************     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * **************************************     * <p/>     * setupAddFavAnimation()     * <p/>     * ***************************************     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * **************************************     * <p/>     * setupMoveFavAnimation()     * <p/>     * ***************************************     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//alphaAnim.addKeyframe(1, 4250, null);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//xAnim.addKeyframe(((SCREEN_WIDTH/2) + DynamicGrid.pxFromDp(50f,mDisplayMetrics)), 1500, null);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//xAnim.addKeyframe(((SCREEN_WIDTH/2) + DynamicGrid.pxFromDp(50f,mDisplayMetrics)), 1500, null);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* scaleAnim.addKeyframe(1f, 2600, null);        scaleAnim.addKeyframe(20.0f, 4000, decelerateInterpolator);*/	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// + DynamicGrid.pxFromDp(77f,mDisplayMetrics);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// + DynamicGrid.pxFromDp(77f,mDisplayMetrics);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* (non-Javadoc)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/* (non-Javadoc)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Load the favorites apps from the shared preferences and get the Android     * application info from each, so we can get the app name and icon.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Store the selected apps in the shared preferences as strings which is the     * package names of the apps. The package name of an app serves as the     * unique identifier of the app.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Convert string array into a single string, where each element in the     * string array is separated by the delimiter string.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.991	0.000
/**     * Convert a string into an array of strings, using the delimiter as     * separator.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Defines a variable to store the action type for the incoming	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// event	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Handles each of the expected events	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Moving an icon to an occupied position replaces the	UNKNOWN	WITHOUT_CLASSIFICATION	0.894	0.000
// current one	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// toggle the red glow when removing favorites	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the Item data	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 0 is the origin	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 1 is the index	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// obtain the applicationInfo	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when not removing an icon swap is performed	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// remove the favorite	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// only setup the icon if a valid id is obtained	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// hide zone remove zone	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
//are we dragging mostly to the right?	UNKNOWN	WITHOUT_CLASSIFICATION	0.934	0.000
// Subtract the number of columns in order to get the correct item	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// due to the header	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the listener	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Setup the list with all the apps installed on the device.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// set the drag listener to enable favorite icon removal	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// display a circle around the possible destinations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set the item with the origin of the drag and the index of the dragged	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Setup the list with the selected app list, which is the holder of the     * apps that has been selected to become the favorite apps.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set the listeners	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The last argument is set to false since this hasnt the ability	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to remove icons, it only switches them	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log.d(TAG, Adding app :  +	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// applicationInfo.getApplicationTitle());	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// pass the main view and the instance setup the drag and visibility	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// of some views	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Update the icon and label of a favorite     *      * @param applicationInfo     *            App information that contains the icon and label     * @param icon     *            the icon to update     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
/**     * Performs the animation when replacing one favorite     *      * @param viewToFadeIn     *            view that will appear. When null it means that we are swapping     *            two favorites     * @param viewToFadeOut     *            view that will disappear.     * @param applicationInfo     *            app info that is used to swap two favorites     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the new icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// get the new icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Capture the back button press, to make sure we save the selected apps     * before exiting.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Serializes the item id and origin that is being dragged.     *      * @param appOrigin     *            the origin: can be SELECT_APPS_DRAG or ALL_APPS_DRAG     * @param appIndex     *            the item index     * @return the serialized item info     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Deserializes the item id and origin that is being dragged.     *      * @param toDeserialize     *            string to deserialize     * @return an array containing {appOrign, appIndex}     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Show the zone where favorites can be removed	UNKNOWN	WITHOUT_CLASSIFICATION	0.989	0.000
// display a circle around the possible destinations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set the drag info	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set the item with the origin of the drag and the index of the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dragged view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// hide the circle around the possible destinations	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the red glow only makes sense when removing favorites	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Displays a background on the favorite possible positions when configuring     * it     *      * @param selectedFavorite     *            the favorite position where the background will not be shown.     *            -1 means that all backgrounds will be shown.     * @param showBackground     *            true: displays the background; false: removes the background     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// to avoid the addition of Fairphone home launcher to	UNKNOWN	WITHOUT_CLASSIFICATION	0.988	0.000
// appSwitcher	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// CHECKS IF THE ANIMATION IS STARTING FROM THE LEFT OR RIGHT	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: CAtch the onMeasure and setup the correct sizes after that,	UNKNOWN	WITHOUT_CLASSIFICATION	0.910	0.000
// for now just calculate the initial size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// IF ALL APPS ICON	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the right ComponentName in order to launch Dialer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// or Contacts correctly	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// WHEN THE USER SETS THE FINGER ON AN ITEM	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// IF ALL APPS ICON	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// CHECKS IF THE ANIMATION IS STARTING FROM THE LEFT OR RIGHT	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// IF ALL APPS ICON	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set edit menu button timer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// set the X coords	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Defines local variables	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Calculate the canvas size 	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The drag shadow is a ColorDrawable. This sets its dimensions to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// be the same as the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Canvas that the system will provide. As a result, the drag shadow	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// will fill the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Canvas.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Sets the size parameters width and height values. These get back	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// to the system	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// through the size parameter.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Sets the touch points position to be in the middle of the drag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shadow	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Defines a callback that draws the drag shadow in a Canvas that the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// system constructs	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// from the dimensions passed in onProvideShadowMetrics().	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Draws the ColorDrawable in the Canvas passed in from the system.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shadow.draw(canvas);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add a user badge in the bottom right of the image.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return default icon below.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Guardo la referencia del scroll para poder usar ambos	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Registramos un DataSetObserver para que cuando se produzcan cambios en el adaptador original lo podamos reflejar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//en el fakeAdapter	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Adds the header view     *      * @param v     *            la vista     * @param data     *            extra data     * @param isSelectable     *            foo     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Aade la vista al layout     *      * @param v     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Nos indica si la cabecera se pinta por delante o por detrs del scroll de     * la lista     *      * @return boolean     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Define si la cabecera se pinta por delante del scroll o si el scroll va     * por encima y la cabecera est fija     *      * @param Boolean     *            isInFront     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Permite cambiar entre una cabecera fija o scrollable     *      * @param Boolean     *            fixed     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Para evitar ciclos infinitos de onDraw / drawHeaders porque si en onDraw le pongo el topMargin efecta	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//repintado, entonces llama a drawHeaders y as....	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Elimina la cabecera     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// they sent us a bad intent	UNKNOWN	WITHOUT_CLASSIFICATION	0.967	0.000
// else, we are replacing the package, so a PACKAGE_ADDED will be sent	UNKNOWN	WITHOUT_CLASSIFICATION	0.961	0.000
// later, we will update the package at this time	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// EXTRA_REPLACING is available Kitkat onwards. For lower devices, it is broadcasted	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when moving a package or mounting/un-mounting external storage. Assume that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// it is a replacing operation.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// they sent us a bad intent	UNKNOWN	WITHOUT_CLASSIFICATION	0.967	0.000
// else, we are replacing the package, so a PACKAGE_ADDED will be sent	UNKNOWN	WITHOUT_CLASSIFICATION	0.961	0.000
// later, we will update the package at this time	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// EXTRA_REPLACING is available Kitkat onwards. For lower devices, it is broadcasted	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when moving a package or mounting/un-mounting external storage. Assume that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// it is a replacing operation.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// try again later	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// try again later	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * This should be called by the implementations to register a package update.     */	UNKNOWN	DESIGN	0.585	0.000
// no longer necessary to track this package	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Adds {@link UserHandle} to the intent in for L or above.     * Pre-L the launcher doesnt support showing apps for multiple     * profiles so this is a no-op.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// No op	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Called on mWorker thread.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Not yet ready	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Nothing to update	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try again later	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Replay all updates with a one time update for this installed package. No	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// need to store this record for future updates, as the app list will get	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// refreshed on resume.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// 1 is top	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The great Android hackatlon, the love, the magic.	UNKNOWN	DESIGN	0.988	0.000
// The two leftmost bits in the height measure spec have	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// a special meaning, hence we cant use them to describe height.	UNKNOWN	WITHOUT_CLASSIFICATION	0.935	0.000
// Any other height should be respected as is.	UNKNOWN	WITHOUT_CLASSIFICATION	0.979	0.000
/**     * Setup the list with all the apps installed on the device.     *     * @param view     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
//fire the easter egg	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//fire the easter egg	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Redraw the drawer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Redraw the drawer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Clean up after dragging.     *     * @param target where the item was dragged to (can be null if the item was     *               flung)     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Exit spring loaded mode if we have not successfully dropped or	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// have not handled the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// drop in Workspace	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// We delay entering spring-loaded mode slightly to make sure the UI	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// thready is free of any work.	UNKNOWN	WITHOUT_CLASSIFICATION	0.996	0.000
// We dont enter spring-loaded mode if the drag has been	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cancelled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Go into spring loaded mode (must happen before we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// startDrag())	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont enter spring-loaded mode if the drag has been	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cancelled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Go into spring loaded mode (must happen before we	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// startDrag())	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mForceDrawAllChildrenNextFrame = !toWorkspace;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return early if this is not initiated from a touch	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if (!v.isInTouchMode()) return false;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// When we have exited all apps or are in transition, disregard long	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// clicks	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if (!mLauncher.isAgingAppDrawerVisible() ||	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// !mLauncher.isAllAppsVisible() ||	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// mLauncher.getWorkspace().isSwitchingState()) return false;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// // Return if global dragging is not enabled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if (!mLauncher.isDraggingEnabled()) return false;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Return early and wait for onFlingToDeleteCompleted if this was the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// result of a fling	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Display an error message if the drag failed due to there not being	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// enough space on the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// target layout we were dropping on.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We just dismiss the drag when we fling, so cleanup here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// otherwise it may crash	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//Open the searchview bar	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// otherwise it may crash	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the final location.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the affected components	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the current widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.966	0.000
// estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dimension if unsuccessful	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Use the first non-custom page to estimate the child position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Prevent any Un/InstallShortcutReceivers from updating the db while we are dragging	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Re-enable any Un/InstallShortcutReceiver and now process any queued items	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Initializes various states for this workspace.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set the wallpaper dimensions when Launcher starts up	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want to show layout transitions when pages are deleted, to close the gap.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * @return The open folder on the current screen, or null if there is none     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Disable all layout transitions before removing all pages to ensure that we dont get the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// transition animations competing with us changing the scroll when we add pages or the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// custom content screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Since we increment the current page when we call addCustomContentPage via bindScreens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// (and other places), we need to adjust the current page back when we clear the pages	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Remove the pages and clear the screen models	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
// Re-enable the layout transitions	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the index to insert this view into.  If the empty screen exists, then	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// insert it before that.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want no padding on the custom content	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that the current page and default page are maintained.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the custom content hint	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that the current page and default page are maintained.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the custom content hint	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the custom content to the full screen custom page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Verify that the child is removed from any existing parent.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Cancel any pending removal of empty screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If this is the last item on the final screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Invalid and dangerous operation if workspace is loading	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the final screen is empty, convert it to the extra empty screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if this is the last non-custom content screen, convert it to the empty screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the model if we have changed any screens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont strip empty screens if the workspace is still loading	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If were not going to strip the empty screens after removing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the extra empty screen, do it right away.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// XXX: Do we need to update LM workspace screens below?	UNKNOWN	DESIGN	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Invalid and dangerous operation if workspace is loading	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the page indicator marker	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the model for the new screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Log to disk	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont strip empty screens if the workspace is still loading.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is dangerous and can result in data loss.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We enforce at least one page to add new items to. In the case that we remove the last	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// such screen, we convert the last screen to the empty screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if this is the last non-custom content screen, convert it to the empty screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update the model if we have changed any screens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// See implementation for parameter definition.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// At bind time, we use the rank (screenId) to compute x and y for hotseat items.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// See implementation for parameter definition.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// See implementation for parameter definition.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Adds the specified child in the specified screen. The position and dimension of     * the child are defined by x, y, spanX and spanY.     *     * @param child The child to add in one of the workspaces screens.     * @param screenId The screen in which to add the child.     * @param x The X position of the child in the screens grid.     * @param y The Y position of the child in the screens grid.     * @param spanX The number of cells spanned horizontally by the child.     * @param spanY The number of cells spanned vertically by the child.     * @param insert When true, the child is inserted at the beginning of the children list.     * @param computeXYFromRank When true, we use the rank (stored in screenId) to compute     *                          the x and y position in which to place hotseat items. Otherwise     *                          we use the x and y position to compute the rank.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// DEBUGGING - Print out the stack trace to see where we are adding from	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This should never happen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Show folder title	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the canonical child id to uniquely represent this view in this screen	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// TODO: This branch occurs when the workspace is adding views	UNKNOWN	DESIGN	1.000	0.000
// outside of the defined grid	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// maybe we should be deleting these items from the LauncherModel?	UNKNOWN	WITHOUT_CLASSIFICATION	0.994	0.000
/**     * Called directly from a CellLayout (not by the framework), after weve been added as a     * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout     * that it should intercept touch events, which is not something that is normally supported.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.978	0.000
/** This differs from isSwitchingState in that we take into account how far the transition     *  has completed. */	UNKNOWN	WITHOUT_CLASSIFICATION	0.902	0.000
// Ignore pointer scroll events if the custom content doesnt allow scrolling.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the current widget which is inflated with the wrong orientation	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Pass swipes to the right to the custom content page.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont allow workspace scrolling if the current custom content screen doesnt allow	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// scrolling.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Above MAX_SWIPE_ANGLE, we dont want to ever start scrolling the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// increase the touch slop to make it harder to begin scrolling the workspace. This	UNKNOWN	WITHOUT_CLASSIFICATION	0.970	0.000
// results in vertically scrolling widgets to more easily. The higher the angle, the	UNKNOWN	WITHOUT_CLASSIFICATION	0.739	0.000
// more we increase touch slop.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Below START_DAMPING_TOUCH_SLOP_ANGLE, we dont do anything special	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// were snapping to a particular screen	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// this is when user is actively dragging a particular screen, they might	UNKNOWN	WITHOUT_CLASSIFICATION	0.917	0.000
// swipe it either left or right (but we wont advance by more than one screen)	UNKNOWN	WITHOUT_CLASSIFICATION	0.875	0.000
// If we are in springloaded mode, then force an event to check if the current touch	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is under a new page (to scroll to)	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Exclude the leftmost page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Exclude the last extra empty screen (if we have > MIN_PARALLAX_PAGE_SPAN pages)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: do different behavior if its  a live wallpaper?	UNKNOWN	DESIGN	0.999	0.000
// Sometimes the left parameter of the pages is animated during a layout transition;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// this parameter offsets it to keep the wallpaper from animating as well	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont use up all the wallpaper parallax until you have at least	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// MIN_PARALLAX_PAGE_SPAN pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// On RTL devices, push the wallpaper offset to the right if we dont have enough	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// pages (ie if numScrollingPages < MIN_PARALLAX_PAGE_SPAN)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set wallpaper offset steps (1 / (number of screens - 1))	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont animate if were going from 0 screens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont announce if apps is on top of us.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//child.setBackgroundAlphaMultiplier(1 - alpha);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In case accessibility state has changed, we need to perform this on every	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// attach to window	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Update wallpaper dimensions if they were changed since last onResume	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// (we also always set the wallpaper dimensions in the constructor)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Force the wallpaper offset steps to be set again, because another app might have changed	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// them	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Call back to LauncherModel to finish binding after the first draw	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In software mode, we dont want the items to continue to be drawn into bitmaps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// make sure were caching at least two pages always	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// enable layers between left and right screen inclusive, except for the	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// customScreen, which may animate its content during transitions.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// force layers to be enabled just for the call to buildLayer	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*    *    * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we    * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace    *    * These methods mark the appropriate pages as accepting drops (which alters their visual    * appearance).    *    */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Compose a drag bitmap with the view scaled to the icon size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If this is a text view, use its drawable instead	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Compose the bitmap to create the icon from	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The outline is used to visualize where the item will land if dropped	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The outline is used to visualize where the item will land if dropped	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reordering handles its own animations, disable the automatic ones.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Invalid and dangerous operation if workspace is loading	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Re-enable auto layout transitions for page deletion.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Initialize animation arrays for the first time if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
//getResources().getInteger(R.integer.config_workspaceUnshrinkTime);	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we are animating to/from the small state, then hide the side pages and fade the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// current page in	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in low power mode the animation doesnt play, so set the end value here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in low power mode the animation doesnt play,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// so set the end value here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// create a dummy animation so we dont need to do null checks later	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For animation optimations, we may need to provide the Launcher transition	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// with a set of views on which to force build layers in certain scenarios.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in low power mode the animation doesnt play, so set the end value here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// in low power mode the animation doesnt play,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// so set the end value here	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want to avoid the extra layout pass by setting the views to GONE unless	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// accessibility is on, in which case not setting them to GONE causes a glitch.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want the views to be visible for animation, so fade-in/out is visible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Invalidate here to ensure that the pages are rendered during the state change transition.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Draw the View v into the given Canvas.     *     * @param v the view to draw     * @param destCanvas the canvas to draw on     * @param padding the horizontal and vertical padding to use when drawing     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// For FolderIcons the text can bleed into the icon area, and so we need to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// hide the text completely (which cant be achieved by clipping).	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore text visibility of FolderIcon if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns a new bitmap to show when the given View is being dragged around.     * Responsibility for the bitmap is transferred to the caller.     * @param expectedPadding padding to add to the drag view. If a different padding was used     * its value will be changed     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.     * Responsibility for the bitmap is transferred to the caller.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.     * Responsibility for the bitmap is transferred to the caller.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// center the image	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Make sure the drag was started by a long press as opposed to a long click.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The outline is used to visualize where the item will land if dropped	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The drag bitmap follows the touch point around on the screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Note: The drag region is used to calculate drag layer offsets, but the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dragVisualizeOffset in addition to the dragRect (the size) to position the outline.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Clear the pressed state if necessary	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Notify launcher of drag start	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Compose a new drag bitmap that is of the icon size	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Find the childs location on the screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Note: The drag region is used to calculate drag layer offsets, but the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dragVisualizeOffset in addition to the dragRect (the size) to position the outline.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Start the drag	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Recycle temporary bitmaps	UNKNOWN	WITHOUT_CLASSIFICATION	0.978	0.000
/**     * {@inheritDoc}     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// If its an external drop (e.g. from All Apps), check if it should be accepted	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont accept the drop if were not over a screen at time of drop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want the point to be mapped to the dragTarget.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont accept the drop if theres no room for the item	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if the drag started here, we need to remove it from the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the dragView is null, we cant animate	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if the drag started here, we need to remove it from the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want the point to be mapped to the dragTarget.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Move internally	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First we find the cell nearest to point at which the item is	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dropped, without any consideration to whether there is an item there.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the item being dropped is a shortcut and the nearest drop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// cell also contains a shortcut, then create a folder with the two shortcuts.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Aside from the special case where were dropping a shortcut onto a shortcut,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// we need to find the nearest cell location that is vacant	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// if the widget resizes on drop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Reparent the view	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// update the items position after drop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We post this call so that the widget has a chance to be placed	UNKNOWN	WITHOUT_CLASSIFICATION	0.981	0.000
// in its final location	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If we cant find a drop location, we return the item to its original position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Prepare it to be animated into its new position	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This must be called after the view has been re-parented	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/** Return a rect that has the cellWidth/cellHeight (left, top), and     * widthGap/heightGap (right, bottom) */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Here we store the final page that will be dropped to, if the workspace in fact	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// receives the drop	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the user drops while the page is scrolling, we should use that page as the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// destination instead of the page that is being hovered over.	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// Reset the scroll area and previous drag target	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont want to cancel the re-order alarm every time the target cell changes	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// as this feels to slow / unresponsive.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Any pending reorders are canceled	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/*    *    * Convert the 2D coordinate xy from the parent Views coordinate space to this CellLayouts    * coordinate space. The argument xy is modified with the return result.    *    * if cachedInverseMatrix is not null, this method will just use that matrix instead of    * computing it itself; we use this to avoid redundant matrix inversions in    * findMatchingPageForDragOver    *    */	UNKNOWN	DESIGN	0.693	0.000
/*    *    * Convert the 2D coordinate xy from this CellLayouts coordinate space to    * the parent Views coordinate space. The argument xy is modified with the return result.    *    */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
/*     *     * This method returns the CellLayout that is currently being dragged to. In order to drag     * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second     * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one     *     * Return null if no CellLayout is currently being dragged over     *     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We loop through all the screens (ie CellLayouts) and see which ones overlap	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// with the item being dragged and then choose the one thats closest to the touch point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The custom content screen is not a valid drag over option	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Transform the touch coordinates to the CellLayouts local coordinates	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If the touch point is within the bounds of the cell layout, we can return immediately	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Get the center of the cell layout in screen coordinates	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Calculate the distance between the center of the CellLayout	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// and the touch point	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This is used to compute the visual center of the dragView. This point is then	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// used to visualize drop locations and determine where to drop an item. The idea is that	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the visual center represents the users interpretation of where the item is, and hence	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// is the appropriate point to use when determining drop location.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First off, the drag view has been shifted in a way that is not represented in the	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// x and y values or the x/yOffsets. Here we account for that shift.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// These represent the visual top and left of drag view if a dragRect was provided.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If a dragRect was not provided, then they correspond to the actual view left and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// top, as the dragRect is in that case taken to be the entire dragView.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// R.dimen.dragViewOffsetY.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In order to find the visual center, we shift by half the dragRect	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Skip drag over events while we are dragging over side pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we have proper spans for the item that we are dropping	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Identify whether we have dragged over a side page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Handle the drag over	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want the point to be mapped to the dragTarget.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Otherwise, if we arent adding to or creating a folder and theres no pending	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// reorder, then we schedule a reorder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This shouldnt happen ever, but just in case, make sure we clean up the mess.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// We want the workspace to have the whole area of the display (it will find the correct	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// cell layout to drop to in the existing drag/drop logic.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Add the item specified by dragInfo to the given layout.     * @return true if successful     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Drop an item that didnt originate on one of the workspace screens.     * It may have come from Launcher (e.g. from all apps or customize), or it may have     * come from another app altogether.     *     * NOTE: This can also be called when we are outside of a drag event, when we want     * to add an item to one of the workspace screens.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Normally removeExtraEmptyScreen is called in Workspace#onDragEnd, but when	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// adding an item that may not be dropped right away (due to a config activity)	UNKNOWN	WITHOUT_CLASSIFICATION	0.860	0.000
// we defer the removal until the activity returns.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// When dragging and dropping from customization tray, we deal with creating	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// widgets/shortcuts/folders in a slightly different way	UNKNOWN	DESIGN	0.931	0.000
// This is for other drag/drop cases, like dragging from All Apps	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Came from all apps -- make a copy	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// First we find the cell nearest to point at which the item is	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// dropped, without any consideration to whether there is an item there.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// when dragging and dropping, just find the closest free spot	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Add the item to DB before adding to screen ensures that the container and other	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// values of the info is properly updated.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We wrap the animation call in the temporary set and reset of the current	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// cellLayout to its final transform -- this means we animate the drag view to	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// the correct final location.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Normally removeExtraEmptyScreen is called in Workspace#onDragEnd, but when	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// adding an item that may not be dropped right away (due to a config activity)	UNKNOWN	WITHOUT_CLASSIFICATION	0.860	0.000
// we defer the removal until the activity returns.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// When dragging and dropping from customization tray, we deal with creating	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// widgets/shortcuts/folders in a slightly different way	UNKNOWN	DESIGN	0.931	0.000
// Now we animate the dragView, (ie. the widget or shortcut preview) into its final	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// location and size on the home screen.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// The animation will scale the dragView about its center, so we need to center about	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// In the case where weve prebound the widget, we remove it from the DragLayer	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Return the current {@link CellLayout}, correctly picking the destination     * screen while a scroll is in progress.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.638	0.000
/**     * Return the current CellInfo describing our current drag; this method exists     * so that Launcher can sync this object with the correct info when the activity is created/     * destroyed     *     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
/**     * Calculate the nearest cell where the given object would be dropped.     *     * pixelX and pixelY should be in the coordinate system of layout     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.997	0.000
// hardware layers on children are enabled on startup, but should be disabled until	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// needed	UNKNOWN	WITHOUT_CLASSIFICATION	0.995	0.000
/**     * Called at the end of a drag which originated on the workspace.     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/// maybe move this into a smaller part	UNKNOWN	DESIGN	0.823	0.000
// Null check required as the AllApps button doesnt have an item info	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Null check required as the AllApps button doesnt have an item info	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If dataUri is not null / empty or if this component isnt one that would	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// have previously showed up in the AllApps list, then this is a widget-type	UNKNOWN	WITHOUT_CLASSIFICATION	0.896	0.000
// shortcut, so ignore it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// If dataUri is not null / empty or if this component isnt one that would	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// have previously showed up in the AllApps list, then this is a widget-type	UNKNOWN	WITHOUT_CLASSIFICATION	0.896	0.000
// shortcut, so ignore it.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Null check required as the AllApps button doesnt have an item info	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Do nothing	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We dont dispatch restoreInstanceState to our children using this code path.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Some pages will be restored immediately as their items are bound immediately, and	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// others we will need to wait until after their items are bound.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We always want to exit the current layout to ensure parity of enter / exit	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Ensure that we are not dragging over to the custom content screen	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Workspace is responsible for drawing the edge glow on adjacent pages,	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// so we need to redraw the workspace when this may have changed.	UNKNOWN	WITHOUT_CLASSIFICATION	0.967	0.000
/**     * Returns a specific CellLayout     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Returns a list of all the CellLayouts in the workspace.     */	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
/**     * We should only use this to search for specific children.  Do not use this method to modify     * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from     * the hotseat and workspace pages     */	UNKNOWN	DESIGN	0.999	0.000
// not done, process all the shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// not done, process all the shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Removes ALL items that match a given package name, this is usually called when a package	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// has been removed and we want to remove all components (widgets, shortcuts, apps) that	UNKNOWN	WITHOUT_CLASSIFICATION	0.814	0.000
// belong to that package.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Filter out all the ItemInfos that this is going to affect	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Removes items that match the application info specified, when applications are removed	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// as a part of an update, this is called to ensure that other widgets and application	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// shortcuts are not removed.	UNKNOWN	WITHOUT_CLASSIFICATION	0.987	0.000
// Just create a hash table of all the specific components that this will affect	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove all the things	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove all the apps from their folders	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove all the other children	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Note: We can not remove the view directly from CellLayoutChildren as this	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// does not re-mark the spaces as unoccupied.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Strip all the empty screens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
/**     * Map the operator over the shortcuts and widgets, return the first-non-null value.     *     * @param recurse true: iterate over folder children. false: op get the folders themselves.     * @param op the operator to map over the shortcuts     */	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// map over all the shortcuts on the workspace	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// map over all the children in the folder	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Break the appinfo list per user	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Create a map of the apps to test against	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Auto install icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try to find the best match activity.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Could not find a default activity. Remove this item.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// process next shortcut.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the shortcut.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// process all the shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Auto install icon	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Try to find the best match activity.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Could not find a default activity. Remove this item.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// process next shortcut.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Restore the shortcut.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// process all the shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For auto install apps update the icon as well as label.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only update the icon for restored apps.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// process all the shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// For auto install apps update the icon as well as label.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Only update the icon for restored apps.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// process all the shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mark this info as broken.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// process all the shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Note that package states are sent only for myUser	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Mark this info as broken.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// process all the shortcuts	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Iterate non recursively as widgets cant be inside a folder.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Remove the provider not ready flag	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// process all the widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Re-inflate the widgets which have changed status	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// widgetRefresh will automatically run when the packages are updated.	UNKNOWN	WITHOUT_CLASSIFICATION	0.999	0.000
// Remove the provider not ready flag	UNKNOWN	WITHOUT_CLASSIFICATION	0.992	0.000
// process all the widget	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Exclude the leftmost page	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Exclude the last extra empty screen (if we have > MIN_PARALLAX_PAGE_SPAN pages)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// TODO: do different behavior if its  a live wallpaper?	UNKNOWN	DESIGN	0.999	0.000
// Sometimes the left parameter of the pages is animated during a layout transition;	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// this parameter offsets it to keep the wallpaper from animating as well	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont use up all the wallpaper parallax until you have at least	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// MIN_PARALLAX_PAGE_SPAN pages	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// On RTL devices, push the wallpaper offset to the right if we dont have enough	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// pages (ie if numScrollingPages < MIN_PARALLAX_PAGE_SPAN)	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Set wallpaper offset steps (1 / (number of screens - 1))	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// Dont animate if were going from 0 screens	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want to avoid the extra layout pass by setting the views to GONE unless	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// accessibility is on, in which case not setting them to GONE causes a glitch.	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// We want the views to be visible for animation, so fade-in/out is visible	UNKNOWN	WITHOUT_CLASSIFICATION	1.000	0.000
// This shouldnt happen ever, but just in case, make sure we clean up the mess.	UNKNOWN	WITHOUT_CLASSIFICATION	0.998	0.000
// Remove the current widget	UNKNOWN	WITHOUT_CLASSIFICATION	0.966	0.000